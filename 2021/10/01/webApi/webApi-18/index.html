<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>那些被忽略但很好用的 Web API / RequestIdleCallback | Max&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="時間管力大師就是要忙裡偷閒  各位應該知道 JavaScript 是單執行緒(單線程)的程式語言，也就是一次只能處理一件事情。這樣的特性會使得事件的執行必定有個先後順序，這時候就會希望重要的事情能夠排序在前面，剩下比較不重要的任務等空閒時再處理即可，這時候就可以靠 RequestIdleCallback 來幫助我們。  RequestIdleCallbackRequestIdleCallback">
<meta property="og:type" content="article">
<meta property="og:title" content="那些被忽略但很好用的 Web API &#x2F; RequestIdleCallback">
<meta property="og:url" content="https://maxleebk.com/2021/10/01/webApi/webApi-18/index.html">
<meta property="og:site_name" content="Max&#39;s Blog">
<meta property="og:description" content="時間管力大師就是要忙裡偷閒  各位應該知道 JavaScript 是單執行緒(單線程)的程式語言，也就是一次只能處理一件事情。這樣的特性會使得事件的執行必定有個先後順序，這時候就會希望重要的事情能夠排序在前面，剩下比較不重要的任務等空閒時再處理即可，這時候就可以靠 RequestIdleCallback 來幫助我們。  RequestIdleCallbackRequestIdleCallback">
<meta property="og:locale">
<meta property="article:published_time" content="2021-10-01T07:32:00.000Z">
<meta property="article:modified_time" content="2023-10-23T04:01:13.720Z">
<meta property="article:author" content="Max Lee">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="WebApi">
<meta property="article:tag" content="13th鐵人賽">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Max&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-landing">
      <a href="/" id="header-avatar"></a>
      <div id="header-title">
        <h1 id="logo-wrap">
          <a href="/" id="logo">Max&#39;s Blog</a>
        </h1>
        
      </div>
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Article</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
      </nav>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-webApi/webApi-18" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        <div class="article-header-wrap">
          
  
    <h1 class="article-title" itemprop="name">
      那些被忽略但很好用的 Web API / RequestIdleCallback
    </h1>
  

          <div>
            <p class="article-date">
  Posted by Max on
  <time datetime="2021-10-01T07:32:00.000Z" itemprop="datePublished">2021-10-01</time>
</p>
          </div>
        </div>
      </header>
    
    
        <div class="article-excerpt" itemprop="articleBody">
          <div class="post-cate">
            
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/" rel="tag">13th鐵人賽</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WebApi/" rel="tag">WebApi</a></li></ul>

            
          </div>
          
        </div>
      
        <div class="article-entry" itemprop="articleBody">
          <blockquote>
<p>時間管力大師就是要忙裡偷閒</p>
</blockquote>
<p>各位應該知道 JavaScript 是單執行緒(單線程)的程式語言，也就是一次只能處理一件事情。這樣的特性會使得事件的執行必定有個先後順序，這時候就會希望重要的事情能夠排序在前面，剩下比較不重要的任務等空閒時再處理即可，這時候就可以靠 RequestIdleCallback 來幫助我們。</p>
<hr>
<h2 id="RequestIdleCallback"><a href="#RequestIdleCallback" class="headerlink" title="RequestIdleCallback"></a>RequestIdleCallback</h2><p>RequestIdleCallback 會在瀏覽器「每一幀」中剩下的空閒裡來執行當中的 Callback。</p>
<br/>

<p>我們之前在介紹 RequestAnimationFrame 時有提過「幀數(FPS)」的概念，也就是「一秒鐘內能夠更新多少幀」，假如在一秒內能夠更新 60 幀，則 FPS 為 60，每一幀的時間約為 16.7 ms(毫秒)。</p>
<p>對於瀏覽器來說每一次「重繪(Repaint)」就是「一幀」，而這一幀要花多少時間就要看當下的網路或硬體狀況而定了。在這每一幀中，瀏覽器都有可能正在執行任務，若這個任務完成時，當下那一幀還沒結束時，就會有一個短暫的空閒時間。</p>
<blockquote>
<p>以 60FPS 為例，每一幀的空閒時間必定小於等於 16.7 ms。</p>
</blockquote>
<br/>

<p>而只要有這個空閒時間 RequestIdleCallback 就會去執行當中的 Callback，來完成那些我們覺得不重要的任務，換句話說，如果瀏覽器一直處於繁忙狀態的話，那該任務就會一直無法執行。</p>
<br/>

<h4 id="Window-requestIdleCallback"><a href="#Window-requestIdleCallback" class="headerlink" title="# Window.requestIdleCallback"></a># Window.requestIdleCallback</h4><p><code>requestIdleCallback</code> 有兩個參數要傳入：</p>
<ul>
<li>callback: 需要在空閒時間(Idle)執行的函示。</li>
<li>timeout: 這是一個可選參數，你可以設定一個時間來強制執行 <code>callback</code>，以避免瀏覽器因為持續繁忙的忽略(單位:毫秒)。</li>
</ul>
<blockquote>
<p>大部分情況不建議使用 <code>timeout</code>，因為會使用 <code>requestIdleCallback</code> 就代表不想影響主線程的任務進行 。</p>
</blockquote>
<pre><code class="javascript">const handlerId = requestIdleCallback(function () &#123;
  //..做些不住要的事
&#125;, 500);
cancelIdleCallback(handlerId); // 取消requestIdleCallback</code></pre>
<p><br/><br/></p>
<h4 id="IdleDeadline"><a href="#IdleDeadline" class="headerlink" title="# IdleDeadline"></a># IdleDeadline</h4><p>而我們傳入的 Callback Function 會被丟進一個由 <code>requestIdleCallback</code> 提供的參數，該參數通常取名為 <code>deadline</code>，並且有兩個屬性可以使用：</p>
<ul>
<li>didTimeout: 這是一個唯讀屬性，以布林值來表示 Callback 是否是因為 <code>timeout</code> 被觸發的。</li>
<li>timeRemaining: 它是一個 method，執行後會傳傳一個毫秒數，用來表示當下這一幀的剩餘時間。</li>
</ul>
<pre><code class="javascript">requestIdleCallback(function (deadline) &#123;
  // 如果你在 requestIdleCallback 中沒有傳入 timeout 參數，didTimeout 必定為 false
  console.log(deadline.didTimeout);
  console.log(deadline.timeRemaining());
&#125;, 500);</code></pre>
<p><br/><br/></p>
<h4 id="實際測試"><a href="#實際測試" class="headerlink" title="# 實際測試"></a># 實際測試</h4><p>由於 JavaScript 是單執行緒，所以要是我今天進行了一個需要耗費大量時間的任務，那使用者的 UI 操作其實也會受到影響。<br>就像下面這個範例中，在 <code>count</code> 被函式 <code>add</code> 加到 1000000 以前，你不管怎麼敲擊鍵盤，<code>keydown</code> 事件都不會被觸發，因為瀏覽器正在忙著算數：</p>
<pre><code class="javascript">window.addEventListener(&quot;keydown&quot;, function () &#123;
  console.log(&quot;Hey !!!!!!!!!&quot;);
&#125;);

let count = 0;
add();
function add() &#123;
  if (count &lt; 10000) &#123;
    console.log(count++);
    add();
  &#125;
&#125;</code></pre>
<p>但是我們只要用 <code>requestIdleCallback</code> 來改寫一下，那狀況就不一樣了，因為這時候 <code>add</code> 這項任務的優先度會往後排，所以當我按下鍵盤時，瀏覽器會先處理 <code>keydown</code> 事件，等到閒置下來後才會繼續進行。</p>
<pre><code class="javascript">window.addEventListener(&quot;keydown&quot;, function () &#123;
  console.log(&quot;Hey !!!!!!!!!&quot;);
&#125;);

let count = 0;
requestIdleCallback(add);
function add(deadline) &#123;
  if (deadline.timeRemaining() &gt; 0) &#123;
    if (count &lt; 10000) &#123;
      console.log(count++);
      requestIdleCallback(add);
    &#125;
  &#125;
&#125;</code></pre>
<p><br/><br/></p>
<h4 id="使用情境"><a href="#使用情境" class="headerlink" title="# 使用情境"></a># 使用情境</h4><p>在了解 RequestIdleCallback 的效果後，我第一個想到的實際應用會是 LazyLoad，想像以下，如果我們有個網頁，當中有幾十甚至幾百張的高畫質圖片需要顯示，可想而知瀏覽器的負擔會相當的大，非常有可能會影響頁面的效能與任務執行，但如果們我利用 <code>requestIdleCallback</code> 來處理，就可以在不影響主執行緒的情況下載入圖片。</p>
<pre><code class="javascript">const images = [
  &quot;https://img/001.png&quot;,
  &quot;https://img/002.png&quot;,
  //.....
  &quot;https://img/099.png&quot;,
  &quot;https://img/100.png&quot;,
];

requestIdleCallback(loadImage);
function loadImage(deadline) &#123;
  if (deadline.timeRemaining() &gt; 0) &#123;
    if (images.length) &#123;
      const imgSrc = images.shift();
      const img = new Image(250, 150);
      img.onload = document.body.appendChild(img);
      img.src = imgSrc;
      requestIdleCallback(loadImage);
    &#125;
  &#125;
&#125;</code></pre>
<p><br/><br/></p>
<p>不曉得使用過 React 的朋友有沒有了解過 React Fiber 呢？其實它的原理就和 RequestIdleCallback 一樣，將大量沒那麼優先的工作拆成許多小片段，在瑣碎的時間裡慢慢完成，也因為這樣的機制，使得我們可以去中斷它，將一些突發的重要任務(例如使用者的 UI 事件)插在這些小片段中，宛如有另一條執行緒一般。</p>
<hr>
<p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a target="_blank" rel="noopener" href="https://ithelp.ithome.com.tw/articles/10276904">iT 邦幫忙</a> -</p>

        </div>
      
    
  </div>

  <footer class="article-footer">
    <!-- 
      <a href="https://maxleebk.com/2021/10/01/webApi/webApi-18/#disqus_thread" class="article-comment-link">Comments</a>
     -->
    <div>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/" rel="tag">13th鐵人賽</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/WebApi/" rel="tag">WebApi</a></li></ul>

    </div>
    <a data-url="https://maxleebk.com/2021/10/01/webApi/webApi-18/" data-id="clo2desq7002iobop6sey60ax" class="article-share-link">分享</a>
  </footer>
  
    
<nav id="article-nav">
  
    <div id="article-nav-older" class="article-nav-link-wrap">
      
      <strong class="article-nav-caption">前一篇文章</strong></br>
      <a href="/2021/09/30/webApi/webApi-17/" class="article-nav-title">那些被忽略但很好用的 Web API / BroadcastChannel</a>
      
    </div>
  
  
    <div id="article-nav-newer" class="article-nav-link-wrap">
      
      <strong class="article-nav-caption">下一篇文章</strong></br>
      <a href="/2021/10/02/webApi/webApi-19/" class="article-nav-title">
        
          那些被忽略但很好用的 Web API / MutationObserver
        
      </a>
      
    </div>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Max Lee ｜ Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Article</a>
  
</nav>
    
<script>
  var disqus_shortname = 'f820602h';
  
  var disqus_url = 'https://maxleebk.com/2021/10/01/webApi/webApi-18/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

<!-- Highlight.js -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@latest/build/styles/vs2015.min.css">
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@latest/build/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>