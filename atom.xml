<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Max&#39;s Blog</title>
  
  <subtitle>Max Your Mind</subtitle>
  <link href="https://maxleebk.com/atom.xml" rel="self"/>
  
  <link href="https://maxleebk.com/"/>
  <updated>2023-10-23T03:50:24.524Z</updated>
  <id>https://maxleebk.com/</id>
  
  <author>
    <name>Max Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>開始點敏捷的工程師</title>
    <link href="https://maxleebk.com/2022/12/27/scrum-master/"/>
    <id>https://maxleebk.com/2022/12/27/scrum-master/</id>
    <published>2022-12-27T04:00:00.000Z</published>
    <updated>2023-10-23T03:50:24.524Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因緣際會下接下了公司團隊的 Scrum Master 角色，從 2022 六月開始至今已經擔任了六個月的時間，希望用此篇記錄一下我在這個職務下所見所得，希望可以幫助跟我一樣是第一次接觸或承接這樣職務的人。</p></blockquote><br/><h2 id="前言與背景"><a href="#前言與背景" class="headerlink" title="前言與背景"></a>前言與背景</h2><br/><p>因為此篇重點會是講述我擔任 Scrum Master 的經驗與歷程，所以會以「認為讀者都對 Scrum 有一定認知」的前提下寫這篇文章，如果對於我文中提到的相關名詞有疑問，透過 Google 應該都可以找到解答，謝謝見諒！</p><br/><h4 id="成為-Scrum-Master-的契機"><a href="#成為-Scrum-Master-的契機" class="headerlink" title="# 成為 Scrum Master 的契機"></a># 成為 Scrum Master 的契機</h4><p>我在目前的公司已經任職「前端工程師」三年多時間，我們公司除了一些真的很大型的產品團隊之外，大部分團隊的 Scrum Master 都是由 PO/PM 兼任，但剛好我所屬的產品團隊近期進入了產品快速發展時期，大量的專案開發加上產品的運營和維護，讓我們的 PM 實在沒有辦法額外負荷 SM 的工作，所以在主管的考量下，希望由我來兼任 SM 角色，好減輕 PM 的負擔。</p><p>再加上由於工程的人力相對來說比較充裕，以及主管的信任等因素，我就這麼接下這個職務了。</p><hr><h2 id="旅程開始"><a href="#旅程開始" class="headerlink" title="旅程開始"></a>旅程開始</h2><br/><h4 id="成長曲線"><a href="#成長曲線" class="headerlink" title="# 成長曲線"></a># 成長曲線</h4><p>首先我想用一張簡單的曲線圖來說明一下我這六個月的成長階段，透過這張圖可以看出，我經歷了三個階段，而這三個階段的轉變時機則是透過「Scrum 讀書會」促成的，後面我便會從這三個階段及兩個轉捩點來說說我的經歷。</p><blockquote><p>這邊也提前先說明一下，圖上的「Scrum 讀書會」是由產品團隊的一位成員發起的活動，邀請所有團隊成員提前閱讀 2020 新發布的 <a href="https://scrumguides.org/docs/scrumguide/v2020/2020-Scrum-Guide-Chinese-Traditional.pdf">Scrum Guide</a> 以及 2022 <a href="https://rsg.taipei/about/#organiser">Regional Scrum Gathering</a> 活動的<a href="https://www.youtube.com/watch?v=24DXcoFmCHc">前導影片</a>，最後在讀書會當天各自提出見解與問題來進行交流討論。</p></blockquote><br/><img src="scrum.png" style="max-width: 800px; margin: 16px auto 0;" /><br/><h4 id="階段一：團隊秘書-amp-行政管理"><a href="#階段一：團隊秘書-amp-行政管理" class="headerlink" title="# 階段一：團隊秘書 &amp; 行政管理"></a># 階段一：團隊秘書 &amp; 行政管理</h4><p><strong>我的心情</strong><br>因為我一開始是對 Scrum Master 實際職責其實是一知半解的，所以我並沒有太多的緊張，反而蠻平常心的，認為只是多處理幾件行政庶務而已。</p><p><strong>我做了什麼</strong><br>在這個階段裡，基本上我做的工作就只是提醒成員開會，並按照過去的流程依樣畫葫蘆，以及把成員的任務進度及狀態做些簡單的管理與追蹤等…沒有做什麼太複雜的工作。</p><p><strong>踩到什麼誤區</strong><br>就如這個階段的標題一樣，我在這個階段所扮演的角色，其實就是「團隊秘書與行政」，工作項目都是一些雞毛蒜皮的小事。而我想這正是因為我對 Scrum Master 的理解太過片面，我對以往 SM 的觀察太過表面，以至於只能模仿，卻無法理解 Scrum 的深層內涵。</p><img src="step1.png" style="max-width: 700px; margin: 16px auto 0;" /><br/><br/><h4 id="轉變：Scrum-讀書會準備期"><a href="#轉變：Scrum-讀書會準備期" class="headerlink" title="# 轉變：Scrum 讀書會準備期"></a># 轉變：Scrum 讀書會準備期</h4><p>第一階段在維持了大約 2 個多月之後，團隊便有了舉辦讀書會的規劃，讀書會的召集人給了我大約兩個禮拜的時間，讓我們閱讀 Scrum Guide 和相關影片，並在讀書會當天要發表一段自己的觀看心得，同時也可以提出自己的疑問和大家討論。</p><p><strong>接觸到的新事物</strong></p><ul><li><a href="https://scrumguides.org/docs/scrumguide/v2020/2020-Scrum-Guide-Chinese-Traditional.pdf">2020 Scrum Guide</a></li><li><a href="https://www.youtube.com/watch?v=24DXcoFmCHc">2022 Regional Scrum Gathering 前導影片</a></li></ul><p><strong>領悟及感受</strong></p><ul><li><p>在看過了這些相關資料之後，我才發現原來 Scrum Guide 有提到不少概念和原則，而且好像有些東西是目前團隊沒有做到的。會說「好像」是因為 Scrum Guide 的部分內容並不是那麼具體，所以我實際上是「感覺」我們沒做到。</p></li><li><p>「那既然沒有完全遵照 Scrum Guide 還是可以好好工作，那差別在哪？」是當時一個油然而生的感受，因為我發現公司內的每個團隊遵循 Scrum 的程度有高有低，但身為開發人員的我．似乎在工作上也沒有太大的差別。</p></li><li><p>在看過這些資料或其他網路文章時，大家都會宣揚說 Scrum 能夠帶來什麼好處，但卻沒什麼人會跟你說你應該要怎麼一步步的實踐它，這讓我感到很困擾。</p></li></ul><img src="change1.png" style="max-width: 700px; margin: 16px auto 0;" /><br/><br/><h4 id="階段二：超級英雄-amp-敏捷警察"><a href="#階段二：超級英雄-amp-敏捷警察" class="headerlink" title="# 階段二：超級英雄 &amp; 敏捷警察"></a># 階段二：超級英雄 &amp; 敏捷警察</h4><p><strong>我的心情</strong><br>隨著開始準備讀書會，我開始進到第二個階段，在這個階段裡我的心情其實有點複雜。</p><p>因為就如前面所說的，我其實有點懷疑遵循 Scrum 的意義，不過身為團隊的 SM，我又覺得還是有責任要讓團隊的各個規範對齊 Scrum Guide，但 Scrum Guide 的內容又有不是很具體，所以儘管我很想嘗試做些什麼，卻又不知道該從何開始，導致我也會開始懷疑自己，變得很緊張。</p><p><strong>我做了什麼</strong><br>在這個階段裡，我做的工作基本一樣，只不過我會一直找各種文章來看，希望從中得到指引，或是希望團隊成員能給我一些具體的意見，讓我知道我接下來該做接什麼，才能將 Scrum 真正地在團隊內運作。</p><p><strong>踩到什麼誤區</strong><br>後來回頭看看這個階段並自我檢討後，才發現我有點太心急了，自認為 Scrum Master 要幫成員準備好一切，只要有哪個環節不符合 Scrum Guide 就會覺得不對勁，一直想要做些什麼來證明我是可以擔起這個職務的。所以這個階段才會被我稱作為「超級英雄與敏捷警察」。</p><p>並且現在我也才知道，Scrum Guide 其實就像是媽媽在家裡教你做菜，她不會告訴你鹽要加多少，或是肉要燉多久才會嫩，因為實際在品嚐的是你與你的成員，所以你應該自己找到符合你們的調味，而不是期待 Scrum Guide 像一本食譜，總是給你明確的數字與步驟。</p><img src="step2.png" style="max-width: 700px; margin: 16px auto 0;" /><br/><br/><h4 id="轉變：Scrum-讀書會結束後"><a href="#轉變：Scrum-讀書會結束後" class="headerlink" title="# 轉變：Scrum 讀書會結束後"></a># 轉變：Scrum 讀書會結束後</h4><p>第二階段其實並沒有維持很久，因為在讀書會結束之後，我大該花了一兩天的時間去釐清跟整理，就讓我有了新的領悟跟想法。</p><p><strong>接觸到的新事物</strong></p><ul><li>讀書會中成員的想法</li><li>無數的網路文章</li></ul><p><strong>領悟及感受</strong></p><ul><li><p>在讀書會中，其實每個團隊成員都有提出他們找到的問題與改善的方向，這時候就會感受到其實一個團隊該如何運作 Scrum 並不是 SM 一人的責任，而是整個團隊要一起不斷的檢討與改善才能成型。</p></li><li><p>另外也獲得一個資訊，是大部分的成員都對 Sprint Goal 和有蠻大的關注，所以我認為這可能會是我第一個可以下手改善的部分。</p></li></ul><blockquote><p>最後我整理了大家的想法並且自己反覆看了一些網路文章後，我終於理出一個自己身為 SM 該完成的終極目標：<br><strong><em>因為完成 Sprint Goal 代表團隊產出了價值，而且會為成員帶來向心力及成就感，所以<code>想辦法提升 Sprint Goal 的完成機率與程度</code>就對了</em></strong></p></blockquote><img src="change2.png" style="max-width: 700px; margin: 16px auto 0;" /><hr><h2 id="邁向-Master-的途中"><a href="#邁向-Master-的途中" class="headerlink" title="邁向 Master 的途中"></a>邁向 Master 的途中</h2><br/><p>經歷了前面的兩個階段與轉變，我認為我目前已經開始慢慢步向正軌，朝著真正的 Scrum Master 前進，所以我稱這個階段為「邁向 Master 的途中」，雖然因為我目前正處於這個階段，所以還不太能為這個階段做一些比較完整的總結，不過我還是希望把這個階段額外拉出來，和大家分享一下截至目前為止我在這個階段所做的一些行動。</p><br/><img src="mine.png" style="max-width: 800px; margin: 16px auto 0;" /><br/><h4 id="心智圖"><a href="#心智圖" class="headerlink" title="# 心智圖"></a># 心智圖</h4><p>首先，因為已經在讀書會結束之後找到了我作為 Scrum Master 的終極目標 - <code>提升 Sprint Goal 的完成機率與程度</code>，所以我做的第一件事情是以「Sprint Goal」為題，進行心智圖的繪製，透過不斷地向自己提問「Why? What? How?」來產生分支，然後再以完成終極目標的前提去回答這些問題，如此一來 Sprint 中的每個環節就更可以知道如何執行。</p><p>後面我就會透過三個案例來說明我是如何利用這一套心智圖框架來和團隊一起改善現有流程的。</p><p><br/><br/></p><h4 id="目前的-Planning-有什麼可以改善的？"><a href="#目前的-Planning-有什麼可以改善的？" class="headerlink" title="# 目前的 Planning 有什麼可以改善的？"></a># 目前的 Planning 有什麼可以改善的？</h4><p><strong>我觀察到的現況</strong></p><ol><li>首先比較弔詭的是，我們團隊其實沒有訂定過 Sprint Goal，大家只能看著一連串的 Sprint Backlog 來大概感受產品在這個 Sprint 的走向。</li><li>另外每次在召開 Planning 之前，確切的任務工單是沒有被列出來的，都是先透過 PM 口頭說明的方式來大致了解這個 Sprint 的工作項目。</li></ol><p><strong>問題</strong></p><ul><li>由於沒有 Sprint Goal，導致團隊成員對 Sprint 沒有共識，焦點會分散在各自的任務上而缺乏凝聚力，對於任務的意義性與重要程度也會沒有明顯感受。</li><li>沒有明確的任務數量、範疇、排序等資訊，則會影響成員預估工時的準確性，最後就可能會讓 Sprint Backlog 做不完，使得 Sprint Goal 的完成度降低。</li></ul><p><strong>改善方式</strong></p><ul><li>首先當務之急，當然是請 PM 在每個 Sprint 開始前先訂定一個初步的 Sprint Goal，等到 Planning 時，在與成員討論並定案。</li><li>而為了增加工時估算的精準度，我也請 PM 前一定要將所有工單建立完畢，並按照握們這次的目標制定任務的優先順序，而在 Planning 時，也要請成員預估自己在這個 Sprint 可以花費的時間，若認為時間不夠，才可以在當下將部分任務排除，進而提升 Sprint Goal 的完成度。</li></ul><blockquote><p><strong>架構套用</strong></p><ol><li>因為要提升 Sprint Goal 完成度 → 所以必須要先有 Sprint Goal</li><li>因為要提升 Sprint Goal 完成度 → 所以一開始就要精確的圈出可完成的範圍，否則沒完成的任務將降低完成度</li></ol></blockquote><p><br/><br/></p><h4 id="目前的總結會議-Review-Retrospective-有什麼可以改善的？"><a href="#目前的總結會議-Review-Retrospective-有什麼可以改善的？" class="headerlink" title="# 目前的總結會議(Review + Retrospective)有什麼可以改善的？"></a># 目前的總結會議(Review + Retrospective)有什麼可以改善的？</h4><p><strong>我觀察到的現況</strong></p><ol><li>目前 Review 的回顧方式是請所有成員將自己手上的任務說明一遍狀況，沒有固定形式，大家說明的詳細程度也不一樣，感覺只是一場大型的站立會議。</li><li>Retrospective 的流程是固定不變的，所以感覺成員有點出現疲態。</li></ol><p><strong>問題</strong></p><ul><li>Review 沒有具體展現團隊在這個 Sprint 完成了什麼事以及 Sprint Goal 的推進，而是只有個別成員的工作日誌，成員缺乏目標感以及成就感。</li><li>Retrospective 中，團隊成員的重點都放在感謝與自我檢討，缺乏團隊的核心問題思考，Retro 應該是用來改進團隊運作與流程的時間。</li></ul><p><strong>改善方式</strong></p><ul><li>Review 的第一件事應該是回顧所有工作項，並計算完成與未完成的項目，就可以求得這個 Sprint 的 Sprint Goal 完成度，具體的數值才能讓成員感受到實質的產品推進，而非用感覺的。</li><li>取消工作日誌式的報告，取而代之的是「成果發表」，請該 Sprint 有完成任何「價值」的成員在會議中用簡報形式向整個團隊展示成果，除了增加個別成員的成就感，也能讓整個團隊真正了解這個 Sprint 我們達成了什麼。<code>企劃、設計、功能開法、研究報告等...都是可以發表的內容。</code></li><li>經常變換 Retro 的形式與活動流程，刺激成員的思考，讓主題聚焦在挖掘團隊的核心問題，而不是流於表面。</li></ul><blockquote><p><strong>架構套用</strong></p><ol><li>因為要提升 Sprint Goal 完成度 → 首先要先有機制可以知道我們每次完成了多少</li><li>因為要提升 Sprint Goal 完成度 → 所以要提升成員的成就感、向心力，讓成員覺得自己做的事情有意義</li><li>因為要提升 Sprint Goal 完成度 → 所以要透過有效果的 Retro 來不斷改善團隊的運作</li></ol></blockquote><p><br/><br/></p><h4 id="怎麼制定-Daily-Scrum-的形式？"><a href="#怎麼制定-Daily-Scrum-的形式？" class="headerlink" title="# 怎麼制定 Daily Scrum 的形式？"></a># 怎麼制定 Daily Scrum 的形式？</h4><p><strong>我觀察到的現況</strong></p><ol><li>會想要改善 Daily Scrum，是因為有多數成員都在讀書會上提到，覺得目前的站立會議過於流水帳，常常會抓不到重點。</li><li>有時候部分成員已經完成這個 Sprint 的任務時，他便只能把一些庶務、會議或非團隊相關的事項拿出來說。</li></ol><p><strong>問題</strong></p><ul><li>由於每天的站立中，哪些任務會被提及，取決於負責人有沒有向大家說明，所以大家在站立中是無法得知所有任務的確切進度的。</li><li>當大家對於任務推進沒有具體感受時，很可能就會缺乏目標感，並漸漸淡忘 Sprint Goal 的存在。</li></ul><p><strong>改善方式</strong></p><ul><li>為了讓大家每天都可以知道所有任務的進度，哪些被擱置，哪些已經被完成等…報告的順序由任務排序取代人員排序。</li><li>與團隊成員討論站立的報告重點與句型。</li></ul><blockquote><p><strong>架構套用</strong></p><ol><li>因為要提升 Sprint Goal 完成度 → 所以要可以讓大家清楚知道每天的目標進度，提升目標感</li><li>因為要提升 Sprint Goal 完成度 → 有效果的站立報告才能讓成員提前發現困難並解決，否則將降低完成度</li></ol></blockquote><br/><p>以上就是三個我實際有作出改善的例子，目前團隊跑起來也算順暢，成員也有給出很好的回饋。不過就像我前面領悟到的一樣，團隊的狀況、產品的發展、成員的變動等等都有可能會使原本可行的流程變得過時，所以 Scrum Master 的職責就是不斷為了維護團隊的終極目標而對這些流程與規範進行調整。</p><p>也因此，我的改善方案未必能為直接的幫助所有讀者，我只能分享解決問題的方式讓各位參考，實際還是要針對你的團隊狀況，並與你的團隊成員討論，找出最符合你們的方案。</p><hr><h2 id="心得感想"><a href="#心得感想" class="headerlink" title="心得感想"></a>心得感想</h2><p>最後，想透過幾個問答來總結這幾個月的心得，也算是回答過去自己的一些疑問。</p><p><strong>認為擔任 ScrumMaster 有什麼好處或心得？</strong><br>可以透過不同角度參與產品是很好的經驗，會有很多新的學習機會。且可以順勢改善一些流程來幫助工程方面的作業。</p><p><strong>有沒有遵循或採用 Scrum 有差別嗎？</strong><br>是有差別的，差別並不是工作內容，而是怎麼看待目前的工作內容背後的意義。每個成員都可以參與動態調整團隊所需的開發或行政流程，而非被動接收指令。</p><p><strong>對於之後也想要 SM 的人有什麼建議？</strong><br>學習與未解之題相處。你需要不斷發現隱藏的問題、引導成員說出問題、嘗試與成員一起解決問題，然後再次發現更多問題。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;因緣際會下接下了公司團隊的 Scrum Master 角色，從 2022 六月開始至今已經擔任了六個月的時間，希望用此篇記錄一下我在這個職務下所見所得，希望可以幫助跟我一樣是第一次接觸或承接這樣職務的人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br</summary>
      
    
    
    
    
    <category term="Agile" scheme="https://maxleebk.com/tags/Agile/"/>
    
    <category term="Scrum" scheme="https://maxleebk.com/tags/Scrum/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / 結語</title>
    <link href="https://maxleebk.com/2021/10/14/webApi/webApi-30/"/>
    <id>https://maxleebk.com/2021/10/14/webApi/webApi-30/</id>
    <published>2021-10-14T12:11:00.000Z</published>
    <updated>2023-10-23T03:50:24.668Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Web API – Application Programming Interface for The Web，翻譯成中文就是「給網頁使用的應用程序介面」</p></blockquote><p>一個月的時間，我們認識了至少 25 個 Web API，或許不是每一個都能立刻派上用場，但希望至少能讓各位對它們有個印象，未來遇到需求時腦中可以響起：「印象中某個 API 好像能夠做到。」 這麼一句話。</p><p>又或是把本系列文章當作一個字典，每當有功能卡住時，上來翻翻晃晃，說不定就能找到符合情境的 API。另外如果有發現文章中與實際使用上有出入的地方，還請一定要跟我說一聲，避免錯誤的內容傳遞給大家。</p><hr><h2 id="選題動機"><a href="#選題動機" class="headerlink" title="選題動機"></a>選題動機</h2><br/><p>我想應該有不少前端朋友都和我一樣，可能都是透過一些業界課程開始接觸及學習前端知識的，無論是實體課程還是線上課程，而大部分的課程會著重在 JS 基礎語法與觀念，然後學習一些常用的字串、數字、陣列操作等等的原生方法，Web API 的範疇也都圍繞在 DOM 元素的操作及事件上。</p><p>這並不是壞事，因為起初確實需要將基礎打好，多熟悉語法與原生方法，不過也因為這樣，當我們遇到一些功能需求時，會<strong>以既定的觀念或目前掌握的工具來實踐</strong>，卻沒發現原來早就有某個 Web API 已經能輕鬆完成這些任務。而且最可惜地方在於，並不是這些 API 太複雜困難才沒有使用，而是因為根本沒有機會去認識它，所以才沒有使用。</p><p>也因為這個原因，我才決定撰寫這個主題，希望能將這些被埋沒的 Web API 丟到各位的印象裡，儘管現在用不上，但至少你已經對它有基本的認識了，未來才不會又用舊方法硬幹。</p><br/><img src="think.png" style="max-width: 400px; margin: 16px auto 0;" /><hr><h2 id="參賽心得"><a href="#參賽心得" class="headerlink" title="參賽心得"></a>參賽心得</h2><br/><p>今年是第二次參加鐵人賽了，由於去年獲得佳作的題目是比較聚焦深入的，所以一直在思考今年是不是也應該以這種形式內容來參賽，但後來還是認為應該把自己真的想整理、分享的寫出來就好，而不是為了獎項去迎合。</p><p>雖然說今年決定的這個主題並不是很困難，對於比較資深的前端來說，可能不是一個很有資訊量的內容，但如果你跟我一樣，是位 Junior 的話，非常希望這次的系列文章對你有幫助。</p><p>今年選擇不囤積文章，讓自己真的以「每天寫一篇」的形式來完賽，沒想到這真的是一個很大的挑戰，由於白天還有工作，下班後也有健身的習慣，所以每天能夠寫文章的時間大約只有三到四個小時，我必須要將大量的資訊歸納成條列式的內容，甚至還要寫些小範例，真的是好幾天都是壓線完成。但也很感謝自己有堅持不懈，今年又順利完賽了。</p><img src="success.png" style="max-width: 400px; margin: 16px auto 0;" /><blockquote><p>本次系列文章中的所有範例列表：<a href="https://codepen.io/max-lee/pens/tags/?selected_tag=2021ithome">https://codepen.io/max-lee/pens/tags/?selected_tag=2021ithome</a></p></blockquote><hr><h2 id="未來期許"><a href="#未來期許" class="headerlink" title="未來期許"></a>未來期許</h2><br/><p>目前對於明年是否參賽以及參賽主題都還沒有任何想法，只期許自己可以不斷吸收新知並且抱持一個樂於分享的心情，並且只要在準備好的狀況下，就要把握機會將自己所擁有的訊息歸納整理並傳遞出去。非常感謝對此系列文章有興趣的各位，順利的話，明年再繼續和鐵人賽的大家見面。</p><img src="grow.png" style="max-width: 400px; margin: 16px auto 0;" /><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10281832">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Web API – Application Programming Interface for The Web，翻譯成中文就是「給網頁使用的應用程序介面」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一個月的時間，我們認識了至少 25 個 Web A</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / Geolocation</title>
    <link href="https://maxleebk.com/2021/10/13/webApi/webApi-29/"/>
    <id>https://maxleebk.com/2021/10/13/webApi/webApi-29/</id>
    <published>2021-10-13T11:19:00.000Z</published>
    <updated>2023-10-23T03:50:24.668Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我的字典裡沒有放棄，因為已鎖定你</p></blockquote><p>現在有不少網站都有地圖相關的功能，而為了解決地圖繪製、路線運算、區域標示…等等複雜的功能，通常大家都會選用第三方的套件或服務，例如 Google Map API、Leaflet、MapBox 之類的，也因為有了這些好用的地圖套件，所以瀏覽器本身的 Geolocation API 可能就容易被遺忘。</p><hr><h2 id="Geolocation"><a href="#Geolocation" class="headerlink" title="Geolocation"></a>Geolocation</h2><p>當然，Geolocation API 並沒有上述那些套件的強大功能，它能做的就是取得使用者目前的地理座標位置，不過，要是你的功能並沒有那麼複雜，單單只是想知道用戶位置的話，其他大可不用殺雞焉用牛刀，Geolocation API 就可以滿足你了。</p><p><br/><br/></p><h4 id="Navigator-geolocation"><a href="#Navigator-geolocation" class="headerlink" title="# Navigator.geolocation"></a># Navigator.geolocation</h4><p>Geolocation 的支援度是非常高的，電腦、手機，各家瀏覽器基本上都是可以使用的，不過在使用前你依然可以先進行檢查，若瀏覽器支援的話，只要透過 <code>navigator.geolocation</code> 就能取得 Geolocation 實體。</p><pre><code class="javascript">if (&quot;geolocation&quot; in navigator) &#123;  console.log(navigator.geolocation);&#125; else &#123;  alert(&quot;你的裝置或瀏覽器不支援定位功能&quot;);&#125;</code></pre><p><br/><br/></p><h4 id="Geolocation-getCurrentPosition"><a href="#Geolocation-getCurrentPosition" class="headerlink" title="# Geolocation.getCurrentPosition"></a># Geolocation.getCurrentPosition</h4><p>有了 Geolocation 實體後，就可以用 <code>getCurrentPosition</code> method 來取得座標位置了，該方法有三個參數，其中第一個為必傳，後兩個為選填：</p><ul><li><strong>success</strong>： 一個回呼函式，會在成功取得位置資訊時觸發，該函式會接到一個 Position 物件。</li><li><strong>error</strong>： 一個回呼函式，會在方法發生錯誤時觸發，該函式則會接到 PositionError 物件。</li><li><strong>options</strong>： 一個物件，其中的屬性可以用來設定獲取位置時的規則。</li></ul><br/><p>參數 options 的詳細屬性：</p><ul><li><strong>enableHighAccuracy</strong>： 一個布林值，決定是否要以最高精準度來取得座標位置，預設為 <code>false</code>。</li><li><strong>timeout</strong>： 一個代表毫秒數的正數，規定設備必須要在多少時間內回應位置資訊，預設為 <code>Infinity</code>。</li><li><strong>maximumAge</strong>： 一個代表毫秒數的正數，表示可以接受多少毫秒以前的暫存位置，預設為 <code>0</code>。</li></ul><br/><blockquote><p><strong>注意</strong>： 若將 <code>enableHighAccuracy</code> 打開，位置資訊的回傳時間將會變長，且可能會使裝置消耗更多電量。</p></blockquote><pre><code class="javascript">function successHandler(position) &#123;  console.log(position);&#125;function errorHandler(err) &#123;  console.log(err);&#125;navigator.geolocation.getCurrentPosition(successHandler, errorHandler, &#123;  enableHighAccuracy: true,  timeout: 5000,  maximumAge: 0,&#125;);</code></pre><p>由於定位資訊屬於隱私範圍，所以在呼叫 <code>getCurrentPosition</code> 時，它會先確認裝置的授權狀態，若使用者不接受則會發生錯誤，若使用者未表明授權與否，則會出現詢問對話框。</p><img src="check.png" style="max-width: 500px; margin: 24px auto;" /><p><br/><br/></p><h4 id="Geolocation-watchPosition"><a href="#Geolocation-watchPosition" class="headerlink" title="# Geolocation.watchPosition"></a># Geolocation.watchPosition</h4><p>除了 <code>getCurrentPosition</code> 可以拿到執行當下的使用者定位之外，還有另外一個 method 是 <code>watchPosition</code>，它的功能與參數都與 <code>getCurrentPosition</code> 相同，差別是它會在使用者的位置發生改變時主動觸發 Success CallBack，等於是在監聽使用者的定位。</p><pre><code class="javascript">function successHandler(position) &#123;  console.log(position);&#125;function errorHandler(err) &#123;  console.log(err);&#125;// watchPosition 執行後會回傳一個獨一的 IDconst geoId = navigator.geolocation.watchPosition(successHandler, errorHandler);</code></pre><p><br/><br/></p><h4 id="Geolocation-clearWatch"><a href="#Geolocation-clearWatch" class="headerlink" title="# Geolocation.clearWatch"></a># Geolocation.clearWatch</h4><p>在上方 <code>watchPosition</code> 的範例中，我們用 <code>geoId</code> 來接它丟出來 ID 編號，我們可以將編號傳入 <code>clearWatch</code> method 中，便可以使對應的 <code>watchPosition</code> 停止監聽使用者定位。</p><pre><code class="javascript">const geoId = navigator.geolocation.watchPosition(successHandler, errorHandler);navigator.geolocation.clearWatch(geoId);</code></pre><p><br/><br/></p><h4 id="Position-物件"><a href="#Position-物件" class="headerlink" title="# Position 物件"></a># Position 物件</h4><p>就如前面所說，Success CallBack 在成功獲取位置資訊時會被觸發，並且可以拿到 Position 物件，其中就包含了許多與地理位置相關的屬性可以使用：</p><ul><li><strong>position.coords.longitude</strong>： 使用者所在位置的經度。</li><li><strong>position.coords.latitude</strong>： 使用者所在位置的緯度。</li><li><strong>position.coords.accuracy</strong>： 回傳經緯度的水平誤差(平面距離)，單位為公尺。</li><li><strong>position.coords.altitude</strong>： 使用者所在位置的海拔高度，單位為公尺。</li><li><strong>position.coords.altitudeAccuracy</strong>： 回傳高度的垂直誤差(垂直高度)，單位為公尺。</li><li><strong>position.coords.heading</strong>： 使用者面向的方位，會以順時針相對於正北方的夾角角度呈現。</li><li><strong>position.coords.speed</strong>： 使用者面對的數度，單位為公尺/秒。</li></ul><br/><blockquote><p><strong>注意</strong>： 以上屬性均為浮點數，部分屬性會在裝置無法提供時回傳 <code>null</code>。</p></blockquote><p><br/><br/></p><h4 id="PositionError-物件"><a href="#PositionError-物件" class="headerlink" title="# PositionError 物件"></a># PositionError 物件</h4><p>另一方面，Error CallBack 則會在發生錯誤時觸發，並取得 PositionError 物件，該物件中的 <code>code</code> 屬性將會告知我們目前的錯誤是何種類型及原因：</p><table><thead><tr><th align="center">錯誤代號</th><th align="center">錯誤名稱</th><th align="center">解釋</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">PERMISSION_DENIED</td><td align="center">沒有獲取裝置定位的權限</td></tr><tr><td align="center">2</td><td align="center">POSITION_UNAVAILABLE</td><td align="center">位置資訊獲取錯誤</td></tr><tr><td align="center">3</td><td align="center">TIMEOUT</td><td align="center">在 Timeout 前未取得定位資訊</td></tr></tbody></table><p><br/><br/></p><h4 id="簡單的小範例"><a href="#簡單的小範例" class="headerlink" title="# 簡單的小範例"></a># 簡單的小範例</h4><p>有了 Geolocation API 之後，我們就可以製作一些與位置有關的簡單小功能，像下方的範例就是取得使用者位置後，將經緯度丟給後端來計算距離最近的門市，然後將門市資訊提供給用戶。</p><pre><code class="html">&lt;button onclick=&quot;getPosition()&quot;&gt;搜尋最近的門市&lt;/button&gt;&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;&lt;script&gt;  const result = document.querySelector(&quot;#result&quot;);  function successHandler(position) &#123;    const &#123; longitude, latitude &#125; = position.coords;    // 取得經緯度後傳給後端進行門市的搜尋    axios.get(&quot;https://backend/store&quot;, &#123; longitude, latitude &#125;).then((res) =&gt; &#123;      const store = res.data;      result.innerHTML = &quot;離你最近的門市是&quot; + store.name + &quot;地址： &quot; store.address;    &#125;);  &#125;  function errorHandler(err) &#123;    alert(&quot;暫時無法取得您的所在位置，請稍後再試&quot;);  &#125;  function getPosition() &#123;    navigator.geolocation.getCurrentPosition(successHandler, errorHandler);  &#125;&lt;/script&gt;</code></pre><p><br/><br/></p><p>每每說到裝置定位、座標時，大家第一個想到的可能都是 Google Map 或其他地圖套件，但其實瀏覽器本身就有 Geolocation API 可以幫我們處理簡單的定位功能。所以要是你的功能未必要顯示地圖的話，其實你可以選擇使用它喔。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10281557">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我的字典裡沒有放棄，因為已鎖定你&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;現在有不少網站都有地圖相關的功能，而為了解決地圖繪製、路線運算、區域標示…等等複雜的功能，通常大家都會選用第三方的套件或服務，例如 Google Map API、Leafl</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / Notification</title>
    <link href="https://maxleebk.com/2021/10/12/webApi/webApi-28/"/>
    <id>https://maxleebk.com/2021/10/12/webApi/webApi-28/</id>
    <published>2021-10-12T10:31:00.000Z</published>
    <updated>2023-10-23T03:50:24.648Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>訂閱、分享、開啟小鈴鐺，才不會錯過通知喔～</p></blockquote><p>各位有沒有收過網站的通知呢？例如 Youtube 或 Netflix 的新片通知，或是 Facebook 的訊息通知等等…，這個其實就是今天要介紹的 Notification 所達成的效果。</p><hr><h2 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h2><p>不過實話是，真的要像 Youtube 那樣在使用者沒有拜訪網站的狀況下發送通知，是需要使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers">Service Worker</a> 以及後端的配合，有興趣的人可以看看 <a href="https://whien.medium.com/%E5%BB%BA%E7%AB%8B-service-worker-web-push-notification-web-notification-%E5%AF%A6%E4%BD%9C%E7%B4%80%E9%8C%84-8a3bb9ff09e8">這篇文章</a>，有詳細說明如何推送未拜訪網站情況下的通知，而今天我們的範疇就先聚焦在如何在「瀏覽情況下」發送通知吧。</p><img src="os.png" style="margin: 24px auto;" /><p>Notification 對於電腦瀏覽器到支援度是不錯的，但在行動裝置上就很糟糕了，iOS 全軍覆沒，Android 也是有使用上的限制，所以使用上還是需要注意一下的。</p><p><br/><br/></p><h4 id="Window-Notification"><a href="#Window-Notification" class="headerlink" title="# Window.Notification"></a># Window.Notification</h4><p>Notification 使用起來並不困難，它本身是一個建構函式，透過 <code>new</code> 關鍵字創建，並傳入一個必要參數即可：</p><pre><code class="javascript">// 檢查瀏覽器是否有支援 Notificationif (&quot;Notification&quot; in window) &#123;  let notification = new Notification(&quot;這是一則通知&quot;);&#125;</code></pre><p>Notification 的第一個參數是 <code>title</code>，會顯示為通知的標題，該參數為必傳參數，而除了 <code>title</code> 之外，你也可以傳入一個可選參數 <code>options</code>，它為一個物件，當中有更多關於通知的詳細設定，下面我只列出幾個我認為比較實用的，若對其他屬性有興趣的話可以看 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Notification/Notification">這裡</a>。</p><br/><ul><li><strong>body</strong>： 一組字串，會設定為通知的內文，位置會在 <code>title</code> 的下方。</li><li><strong>image</strong>： 一組圖片的 URL 字串，它會成為通知的主視覺圖片。</li><li><strong>icon</strong>： 一組圖片的 URL 字串，它會成為通知的圖標，位置大小依系統原生通知而定。</li><li><strong>data</strong>： 任意的資料格式，任何與通知相關的資料可以放在這，不會顯示在通知當中，一般情境下比較少用，</li><li><strong>requireInteraction</strong>： 一個布林值，決定通知必須要由使用者來關閉，而不是使其自動關閉，預設值為 <code>false</code></li></ul><br/><blockquote><p><strong>注意：</strong> 每個作業系統對於不同的設定屬性有不同的支援或做法，最終的行為可能不會相同，例如 macOS 不支援 <code>image</code> 圖片顯示。</p></blockquote><pre><code class="html">&lt;button onclick=&quot;notifyMe()&quot;&gt;click&lt;/button&gt;&lt;script&gt;  function notifyMe() &#123;    let notification = new Notification(&quot;這裡是通知的標題&quot;, &#123;      body: &quot;這裡是通知的內文&quot;,      icon: &quot;./max.jpg&quot;,      image: &quot;./max.jpg&quot;,      requireInteraction: true,    &#125;);  &#125;&lt;/script&gt;</code></pre><img src="mic.png" style="margin: 24px auto;" /><p>可以看到不同作業系統本身在通知的顯示上有很大的不同，而且針對同一個屬性也會有不同的行為模式：</p><ul><li>首先在 macOS 上，右邊的圖示是根據 <code>icon</code> 的設定顯示的，而非 <code>image</code>，但 Microsoft 就同時顯示了 <code>icon</code> 和 <code>image</code>。</li><li>再者，由於設定了 <code>requireInteraction</code>，所以當使用者沒有主動關閉中前 macOS 會將通知訊息疊加顯示，反之 Microsoft 並不會，要等到第一條通知被關閉後，第二條才會出現。</li></ul><p><br/><br/></p><h4 id="Notification-實體"><a href="#Notification-實體" class="headerlink" title="# Notification 實體"></a># Notification 實體</h4><p>如果我們在創建 Notification 時有將宣告在變數中，我們就可以取得 Notification 實體，並訪問它的相關屬性，而它的屬性其實就是當初在呼叫建構函式時所傳入的參數，像是這樣：</p><pre><code class="javascript">let notification = new Notification(&quot;這是一則通知&quot;, &#123;  body: &quot;這是 Ｍax 的通知&quot;,  icon: &quot;./max.jpg&quot;,  data: &#123; name: &quot;Max&quot; &#125;,  requireInteraction: true,&#125;);console.log(notification.title); // &quot;這是一則通知&quot;console.log(notification.body); // &quot;這是 Ｍax 的通知&quot;console.log(notification.data.name); // &quot;Max&quot;console.log(notification.requireInteraction); // true</code></pre><p>另外除了這些唯讀屬性外，我們還可以為通知綁定事件，而且事件的 Callback 也和其他事件一樣，可以接到一個 Event 物件，當中的 <code>event.target</code> 就會是被觸發事件的 Notification 實體。</p><p><strong>可監聽的事件有:</strong></p><ul><li><code>click</code>： 使用者點擊通知時觸發，關閉時的點擊不包含在內。</li><li><code>error</code>： 當通知發生錯誤時觸發。</li></ul><pre><code class="javascript">let notification = new Notification(&quot;這是一則通知&quot;, &#123;  body: &quot;這是 Ｍax 的通知&quot;,  icon: &quot;./max.jpg&quot;,  data: &#123; name: &quot;Max&quot; &#125;,  requireInteraction: true,&#125;);notification.addEventListener(&quot;click&quot;, function (event) &#123;  console.log(event.target.data.name); // &quot;Max&quot;  // 打開頁面是一個常見的點擊事件行為  window.open(&quot;https://maxleebk.com/&quot;, &quot;_blank&quot;);&#125;);</code></pre><p><br/><br/></p><h4 id="Window-Notification-permission"><a href="#Window-Notification-permission" class="headerlink" title="# Window.Notification.permission"></a># Window.Notification.permission</h4><p>由於 Notification 算是一個有點打擾使用者的功能，所以使用前是需要取得授權的，而 Notification 這個建構函示（class）本身有提供 <code>permission</code> 這個靜態屬性讓我們確認授權的狀態。</p><p>當我們訪問 <code>permission</code> 時會讀取到一個表示授權狀態的字串，其值可能會是以下三種：</p><ul><li><code>&quot;granted&quot;</code>： 表示使用者允許網站的通知功能。</li><li><code>&quot;denied&quot;</code>： 表示使用者阻擋網站的通知功能，直到使用者主動到瀏覽器設定中開啟通知。</li><li><code>&quot;default&quot;</code>： 表示使用者對於通知功能還沒有明確的授權與否。</li></ul><pre><code class="javascript">if (!window.Notification) &#123;  console.log(&quot;這個瀏覽器不支援 Notification&quot;);&#125; else if (Notification.permission === &quot;granted&quot;) &#123;  let notification = new Notification(&quot;這是一則通知&quot;);&#125; else if (Notification.permission === &quot;denied&quot;) &#123;  alert(&quot;建議您允許通知，以收到最新消息&quot;);&#125;</code></pre><p><br/><br/></p><h4 id="Window-Notification-requestPermission"><a href="#Window-Notification-requestPermission" class="headerlink" title="# Window.Notification.requestPermission"></a># Window.Notification.requestPermission</h4><p>若是授權狀態為 <code>&quot;default&quot;</code>，那表示使用者並未對通知功能表示明確的答覆，這時候就需要我們使用 <code>requestPermission</code> 來詢問，它本身會再去確認一次授權狀態，若發現狀態為 <code>&quot;default&quot;</code> 就會跳出詢問授權的對話框，並且在使用者答覆之後利用 Promise 將結果丟給我們。</p><pre><code class="javascript">if (!window.Notification) &#123;  console.log(&quot;這個瀏覽器不支援 Notification&quot;);&#125; else if (Notification.permission === &quot;granted&quot;) &#123;  let notification = new Notification(&quot;這是一則通知&quot;);&#125; else if (Notification.permission === &quot;denied&quot;) &#123;  alert(&quot;建議您允許通知，以收到最新消息&quot;);&#125; else if (Notification.permission === &quot;default&quot;) &#123;  Notification.requestPermission().then((result) =&gt; &#123;    // result 相當於 Notification.permission    if (result === &quot;granted&quot;) &#123;      let notification = new Notification(&quot;這是一則通知&quot;);    &#125;  &#125;);&#125;</code></pre><img src="pr.png" style="margin: 24px auto;" /><p>前面有說，其實 <code>requestPermission</code> 會自己再去確認一次狀態，如果為 <code>&quot;default&quot;</code> 才會詢問使用者，反之則會直接將授權狀態丟給我們，所以我們其實直接呼叫它就好，不一定要先透過 <code>permission</code> 來判斷。</p><pre><code class="javascript">Notification.requestPermission().then((result) =&gt; &#123;  if (result === &quot;granted&quot;) &#123;    let notification = new Notification(&quot;這是一則通知&quot;);  &#125; else if (result === &quot;denied&quot;) &#123;    alert(&quot;建議您允許通知，以收到最新消息&quot;);  &#125;&#125;);</code></pre><p><br/><br/></p><p>以上就是 Notification API 的大致內容了，但就如開頭所說，其實它還是搭配 Service Worker 才會有更強大的效果，尤其是網站有提供訂閱服務的話，那它的幫助絕對是非常大的，不過至少今天我們已經知道如何發送通知了，未來如果有機會和後端配合也可以快速上手。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10281329">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;訂閱、分享、開啟小鈴鐺，才不會錯過通知喔～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;各位有沒有收過網站的通知呢？例如 Youtube 或 Netflix 的新片通知，或是 Facebook 的訊息通知等等…，這個其實就是今天要介紹的 Notifi</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / Share</title>
    <link href="https://maxleebk.com/2021/10/11/webApi/webApi-27/"/>
    <id>https://maxleebk.com/2021/10/11/webApi/webApi-27/</id>
    <published>2021-10-11T12:52:00.000Z</published>
    <updated>2023-10-23T03:50:24.644Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>與你分享的快樂，勝過獨自擁有</p></blockquote><p>現代人看到有趣的網頁、新聞、消息等等時，最常做的事情就是分享到社群帳號中，而現在社群軟體數不勝數，Facebook、LINE、Instagram、twitter…等等。</p><p>起初，只有在 Android 和 iOS 的 APP 中你可以呼叫 OS 系統的原生分享介面，一般網頁則還是得一個個處理各家社群軟體的分享機制，所以你往往會在網頁中看到一排社群軟體的 LOGO 用來分享到不同地方。不過現在瀏覽器也提供了 Share API 來呼叫原生的分享介面了。</p><hr><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>雖然網頁終於有 Share API 來讓我們呼叫系統原生的分享介面，不過它的支援度還不是非常完善，其中對「電腦瀏覽器」不僅支援度低，就算有支援，也並沒有提供社群網站的分享，提供的分享途徑非常不實用。</p><img src="os.png" style="margin: 24px auto;" /><p><strong>而對於電腦的低支援度，我認為可能有兩點原因：</strong></p><ul><li><p><strong>系統權限：</strong><br>由於行動裝置中的 APP 都是依照手機 OS（Android、iOS）的規範編寫，所以手機 OS 能有相應的權限來開啟「社群軟體」的分享功能。反之電腦 OS (Microsoft、macOS) 沒有任何權限去啟動「社群網頁」的分享功能。</p></li><li><p><strong>操作習慣：</strong><br>電腦使用者一般的的分享手段還是以網址分享為主，這樣的手段在電腦操作上是快速且方便的，而行動裝置對於同樣的操作是麻煩的，所以才需要原生分享的幫助。</p></li></ul><br/><p>隨然我們平常多以電腦的視角在開發網頁，不過為了加強行動裝置的使用體驗，Share API 還是有使用的需求性。</p><p><br/><br/></p><h4 id="Navigator-share"><a href="#Navigator-share" class="headerlink" title="# Navigator.share"></a># Navigator.share</h4><p>只要執行這個 method 就能啟用分享功能，不過需要注意幾個限制才能順利使用：</p><ul><li>最重要的當然是瀏覽器要支援</li><li>它必須經由使用者的操作／手勢觸發</li><li>網站必須要有 https 的協定</li></ul><br/><p>另外，呼叫 <code>navigator.share</code> 時還需要傳入一個參數，用來設定分享內容或檔案：</p><ul><li><strong>ShareData：</strong> 該參數需為一個物件，當中的所有屬性都是「可選的」，但必須至少有一項，可接受的屬性有以下：<ul><li>title: 一組字串，分享訊息的標題</li><li>text: 一組字串，分享訊息的描述</li><li>url: 一組字串，分享訊息要帶上的連結</li><li>files: 一組 <a href="https://developer.mozilla.org/en-US/docs/Web/API/File/File">File 物件</a> 的陣列，會成為分享內容的附件</li></ul></li></ul><blockquote><p><strong>你需要注意</strong>： 不是每個瀏覽器都能辨識所有的屬性，若不能辨識時就會忽略。</p></blockquote><blockquote><p><strong>你需要注意</strong>： 就算瀏覽器能辨認，不同的分享途徑也可能會有不同的支援程度，例如臉書貼文就不支援 <code>files</code>，但 LINE、電子郵件就可以。</p></blockquote><pre><code class="javascript">const shareBtn = document.querySelector(&quot;.share&quot;);shareBtn.addEventListener(&quot;click&quot;, function () &#123;  const file = new File([&quot;foo&quot;], &quot;foo.txt&quot;, &#123; type: &quot;text/plain&quot; &#125;);  const shareData = &#123;    title: &quot;分享功能&quot;,    text: &quot;測試分享功能&quot;,    url: &quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share&quot;,    files: [file],  &#125;;  if (navigator.share) &#123;    // 有分享功能就分享    navigator      .share(shareData)      .then(() =&gt; alert(&quot;分享成功&quot;))      .catch((err) =&gt; alert(&quot;發生錯誤:&quot; + err));  &#125; else &#123;    // 沒有分享功能就複製網址到剪貼簿    navigator.clipboard      .writeText(location.href))      .then(() =&gt; alert(&quot;已複製網頁網址&quot;))      .catch(() =&gt; alert(&quot;複製失敗&quot;));  &#125;&#125;);</code></pre><p>上方就是一個最基本的使用方式，利用 <code>click</code> 來觸發事件，並且先確認瀏覽器的 <code>navigator</code> 有 <code>share</code> 這個 method 才去執行，並且傳入一組 <code>ShareData</code> 物件，這樣只要有有支援的瀏覽器以及分享途徑就會開啟並根據 <code>ShareData</code> 來組合分享訊息。</p><p>要注意的是，<code>navigator.share</code> 會回傳一個 Promise，你可以利用 <code>then</code> 和 <code>catch</code> 來處理分享成功或失敗的後續動作。</p><img src="share.png" style="margin: 24px auto;" /><p><br/><br/></p><p>要是你希望網站有良好的傳遞性，非常建議使用 Share API，尤其是那些支援行動裝置瀏覽的網站。儘管現在手機上的瀏覽器 APP 已經有內建的分享選項，但最直覺的操作還是直接顯示在網頁中的分享按鈕。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10280875">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;與你分享的快樂，勝過獨自擁有&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;現代人看到有趣的網頁、新聞、消息等等時，最常做的事情就是分享到社群帳號中，而現在社群軟體數不勝數，Facebook、LINE、Instagram、twitter…等等。&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / 拖拉式待辦清單</title>
    <link href="https://maxleebk.com/2021/10/10/webApi/webApi-26/"/>
    <id>https://maxleebk.com/2021/10/10/webApi/webApi-26/</id>
    <published>2021-10-10T09:39:00.000Z</published>
    <updated>2023-10-23T03:50:24.620Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>就算拖拖拉拉，也可以把待辦事項處理好</p></blockquote><p>昨天雖然已經知道該如何使用 Drag &amp; Drop API 了，不過今天會實際用它來做個「拖拉式待辦清單」，用具體的範例來讓我們更加理解它的運用技巧。</p><hr><h2 id="設計概念"><a href="#設計概念" class="headerlink" title="設計概念"></a>設計概念</h2><br/><h4 id="確立需求與功能"><a href="#確立需求與功能" class="headerlink" title="# 確立需求與功能"></a># 確立需求與功能</h4><ol><li>既然是待辦清單，那自然要可以新增待辦事項</li><li>每項任務可以透過拖曳來進行狀態的更換（待處理、進行中、已完成）</li><li>每項任務可以透過拖曳來進行排序的調換</li><li>每項任務可以透過拖曳來進行刪除</li></ol><br/><h2 id="開始實踐"><a href="#開始實踐" class="headerlink" title="開始實踐"></a>開始實踐</h2><br/><p>由於主要是為了示範 Drag &amp; Drop，所以就不額外使用前端框架，並且也不進行資料的處理，完全使用 DOM 的增刪操作來完成作品，如果各位想要完善範例的話可以再自行採用更方便的技術。</p><p>首先準備好我們 ToDo List 的結構和樣式，大致上長成下面這樣，樣式部分各位可以各自發揮，這邊就不秀出完整 CSS 了。</p><pre><code class="html">&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&quot;column&quot;&gt;    &lt;div class=&quot;title todo&quot;&gt;待處理&lt;/div&gt;    &lt;div class=&quot;input-wrap&quot;&gt;      &lt;input type=&quot;text&quot; placeholder=&quot;＋ 新增事項&quot; /&gt;      &lt;button&gt;新增&lt;/button&gt;    &lt;/div&gt;    &lt;ol class=&quot;list&quot;&gt;&lt;/ol&gt;  &lt;/div&gt;  &lt;div class=&quot;column&quot;&gt;    &lt;div class=&quot;title handle&quot;&gt;進行中&lt;/div&gt;    &lt;ol class=&quot;list&quot;&gt;&lt;/ol&gt;  &lt;/div&gt;  &lt;div class=&quot;column&quot;&gt;    &lt;div class=&quot;title complete&quot;&gt;已完成&lt;/div&gt;    &lt;ol class=&quot;list&quot;&gt;&lt;/ol&gt;  &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;delete&quot;&gt;刪除&lt;/div&gt;</code></pre><img src="layout.png" style="margin: 24px auto;" /><br/><h4 id="新增代辦任務"><a href="#新增代辦任務" class="headerlink" title="# 新增代辦任務"></a># 新增代辦任務</h4><p>首先我們先來透過 <code>&lt;input&gt;</code> 和 <code>&lt;button&gt;</code> 來完成「新增任務」的功能，透過點擊按鈕或按下 Enter 就會執行 <code>createToDo</code> 函式，用來創造一個 <code>li</code> 元素，並加上屬性及文字後丟掉「待處理」的 <code>ol</code> 中。</p><pre><code class="javascript">const input = document.querySelector(&quot;input&quot;);const button = document.querySelector(&quot;button&quot;);const todoList = input.parentElement.nextElementSibling;function createToDo(content) &#123;  const newItem = document.createElement(&quot;li&quot;);  newItem.classList.add(&quot;item&quot;);  // 記得要加上 draggable，這樣任務才可以拖曳  newItem.setAttribute(&quot;draggable&quot;, true);  newItem.textContent = content;  todoList.appendChild(newItem);  input.value = &quot;&quot;;&#125;input.addEventListener(&quot;keydown&quot;, (e) =&gt; &#123;  if (!input.value.trim() || e.which !== 13) return;  createToDo(input.value);&#125;);button.addEventListener(&quot;click&quot;, () =&gt; &#123;  if (!input.value.trim()) return;  createToDo(input.value);&#125;);</code></pre><img src="add.gif" style="margin: 24px auto;" /><p><br/><br/></p><h4 id="拖曳以改變任務狀態"><a href="#拖曳以改變任務狀態" class="headerlink" title="# 拖曳以改變任務狀態"></a># 拖曳以改變任務狀態</h4><p>接著我們要讓任務可以進行「拖曳」，且三個不同的區塊都要可以「被放置」任務，也就是 Drag &amp; Drop API 的部分了，分別把 Drag Source 和 Drop Location 監聽事件的流程包裝成函式，然後在新增任務時把元素加上 <code>drag</code> 相關事件，以及為三個狀態區塊加上 <code>drop</code> 相關事件。</p><pre><code class="javascript">// 用來暫存被 drag 的元素let source = null;function addDragEvt(element) &#123;  element.addEventListener(&quot;dragstart&quot;, (e) =&gt; &#123;    e.target.classList.add(&quot;dragging&quot;);    source = e.target;  &#125;);  element.addEventListener(&quot;dragend&quot;, (e) =&gt; &#123;    e.target.classList.remove(&quot;dragging&quot;);    source = null;  &#125;);&#125;function createToDo(content) &#123;  // ...前面省略  // 記得在 createToDo 中加入這一行來為新增的 li 監聽事件  addDragEvt(newItem);  todoList.appendChild(newItem);  input.value = &quot;&quot;;&#125;</code></pre><pre><code class="javascript">function addDropEvt(element) &#123;  element.addEventListener(&quot;dragover&quot;, (e) =&gt; &#123;    e.preventDefault();  &#125;);  element.addEventListener(&quot;drop&quot;, (e) =&gt; &#123;    e.currentTarget.querySelector(&quot;ol&quot;).appendChild(source);  &#125;);&#125;const columns = document.querySelectorAll(&quot;.column&quot;);columns.forEach((column) =&gt; &#123;  addDropEvt(column);&#125;);</code></pre><img src="drag.gif" style="margin: 24px auto;" /><p><br/><br/></p><h4 id="拖曳以改變任務排序"><a href="#拖曳以改變任務排序" class="headerlink" title="# 拖曳以改變任務排序"></a># 拖曳以改變任務排序</h4><p>現在各項任務已經可以通過拖曳放置在不同狀態的區塊了，現在要來處理排序問題了，我們可以先透過 <code>dragover</code> 事件來取得鼠標的位置，得以判斷使用者想要把項目放在哪一個位置，並且利用樣式的改變讓使用者能更清楚知道他放開滑鼠後，任務會被加在哪裡：</p><pre><code class="css">.item &#123;  position: relative;&#125;.item::before,.item::after &#123;  content: &quot;&quot;;  position: absolute;  display: block;  width: 100%;  height: 4px;  background: lightblue;  opacity: 0;&#125;.item.before::before &#123;  top: -2px;  left: 0;  opacity: 1;&#125;.item.after::after &#123;  bottom: -2px;  left: 0;  opacity: 1;&#125;</code></pre><pre><code class="javascript">// 用來暫存被 dragover 的元素let overItem = null;// 重置被 dragover 的元素function clearOverItem() &#123;  if (!overItem) return;  overItem.classList.remove(&quot;before&quot;);  overItem.classList.remove(&quot;after&quot;);  overItem = null;&#125;function addDropEvt(element) &#123;  element.addEventListener(&quot;dragover&quot;, (e) =&gt; &#123;    clearOverItem();    // 如果 dragover 的元素也是任務項目且不是目前被 drag 的 source 時執行    if (e.target.getAttribute(&quot;draggable&quot;) &amp;&amp; e.target !== source) &#123;      overItem = e.target;      if (e.offsetY &gt; overItem.offsetHeight / 2) &#123;        // 如果鼠標在元素的下半部顯示下方的藍條        overItem.classList.add(&quot;after&quot;);      &#125; else &#123;        // 反之，顯示上方的藍條        overItem.classList.add(&quot;before&quot;);      &#125;    &#125;    e.preventDefault();  &#125;);  //...以下省略&#125;</code></pre><img src="sort.gif" style="margin: 24px auto;" /><p>接著我們只要在修改一下 <code>drop</code> 事件，在當中判斷目前被 <code>dragover</code> 元素的狀態就可以放到對應的位置了：</p><pre><code class="javascript">function addDropEvt(element) &#123;  //...以上省略  element.addEventListener(&quot;drop&quot;, (e) =&gt; &#123;    const list = e.currentTarget.querySelector(&quot;ol&quot;);    if (overItem) &#123;      if (overItem.classList.contains(&quot;before&quot;)) &#123;        // 如果 overItem 有 before class 就將 source 移動到它的前面        list.insertBefore(source, overItem);      &#125; else &#123;        // 反之，有 after class 就將 source 移動到它的後面        list.insertBefore(source, overItem.nextElementSibling);      &#125;    &#125; else &#123;      // 如果沒有 overItem 也沒有更換狀態就不動作      if (e.currentTarget.contains(source)) return;      // 反之，加到最後面      else list.appendChild(source);    &#125;    clearOverItem();  &#125;);&#125;</code></pre><img src="done.gif" style="margin: 24px auto;" /><p><br/><br/></p><h4 id="拖曳以刪除任務"><a href="#拖曳以刪除任務" class="headerlink" title="# 拖曳以刪除任務"></a># 拖曳以刪除任務</h4><p>最後在把刪除的功能給補上，這樣一切就大功告成了。</p><pre><code class="javascript">const del = document.querySelector(&quot;.delete&quot;);del.addEventListener(&quot;dragover&quot;, (e) =&gt; &#123;  e.preventDefault();&#125;);del.addEventListener(&quot;drop&quot;, (e) =&gt; &#123;  source.remove();  clearOverItem();&#125;);</code></pre><p><br/><br/></p><p>整個範例做完後，希望各位對於 Drag &amp; Drop API 能有更深更具體的認識，如果你在動手做之前想先試玩看看的話，我把原始碼放在 <a href="https://codepen.io/max-lee/pen/rNzNXOX">CodePen</a> 囉，如果文章中的說明看不是很懂的話，也可以在 CodePen 看看，有任何問題或建議也好歡迎各位提出～</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10280490">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;就算拖拖拉拉，也可以把待辦事項處理好&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;昨天雖然已經知道該如何使用 Drag &amp;amp; Drop API 了，不過今天會實際用它來做個「拖拉式待辦清單」，用具體的範例來讓我們更加理解它的運用技巧。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / Drag &amp; Drop</title>
    <link href="https://maxleebk.com/2021/10/09/webApi/webApi-25/"/>
    <id>https://maxleebk.com/2021/10/09/webApi/webApi-25/</id>
    <published>2021-10-09T13:19:00.000Z</published>
    <updated>2023-10-23T03:50:24.616Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>就是要拖拖拉拉</p></blockquote><p>現在使用手機、平板來瀏覽網站的機會比起電腦來說，實在是多太多了，所以其實 Web API 也不斷針對這樣的趨勢在靠攏，像是我們前期介紹的 Battery API 就是一個案例。</p><p>使用者在長期使用行動裝置的情況下，已經習慣了系統 OS 或 APP 的操作，所以對於「拖曳物件」這個手勢動作已經是直覺反應了，而在網站開發中，Drag &amp; Drop API 就是協助我們完成「拖曳」功能的好幫手。</p><hr><h2 id="Drag-amp-Drop"><a href="#Drag-amp-Drop" class="headerlink" title="Drag &amp; Drop"></a>Drag &amp; Drop</h2><p>Drag &amp; Drop 其實是「拖」和「放」兩個動作，也就是除了「拖曳」元素外，也可以將其「放置」在特定位置。這也代表說整個過程中會與使用者交互的元素不只有一個，會發生的事件也不只有一個，在拖放的過程中至少會有兩個角色，各自也都有對應的事件：</p><br/><ul><li><strong>Drag Source</strong>： 被使用者點擊不放並「拖曳」的目標元素。</li></ul><table><thead><tr><th align="center">事件</th><th align="center">說明</th></tr></thead><tbody><tr><td align="center">dragstart</td><td align="center">當使用者<strong>開始</strong>拖曳時觸發（滑鼠開始移動時）</td></tr><tr><td align="center">drag</td><td align="center">開始拖曳到結束拖曳前都會不斷觸發（約幾百毫秒觸發一次）</td></tr><tr><td align="center">dragend</td><td align="center">當使用者<strong>結束</strong>拖曳時觸發（滑鼠按鍵放開時）</td></tr></tbody></table><br/><ul><li><strong>Drop Location</strong>： 一個可以「放置」 <code>drag source</code> 的元素。</li></ul><table><thead><tr><th align="center">事件</th><th align="center">說明</th></tr></thead><tbody><tr><td align="center">dragenter</td><td align="center">當使用者拖曳期間<strong>進入</strong>元素時觸發</td></tr><tr><td align="center">dragover</td><td align="center">當使用者拖曳期間<strong>經過</strong>元素時觸發（約幾百毫秒觸發一次）</td></tr><tr><td align="center">dragleave</td><td align="center">當使用者拖曳期間<strong>離開</strong>元素時觸發</td></tr><tr><td align="center">drop</td><td align="center">當使用者將拖曳的目標<strong>放置</strong>在元素時觸發</td></tr></tbody></table><p><br/><br/></p><h4 id="Attribute-draggable"><a href="#Attribute-draggable" class="headerlink" title="# Attribute:draggable"></a># Attribute:draggable</h4><p>通常來說，按住元素不放也是沒辦法拖曳的，若要使其可以拖曳必須要在 HTML 標籤上加入 <code>draggable</code> 屬性：</p><pre><code class="html">&lt;div class=&quot;box&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;</code></pre><blockquote><p>Drop Location 則不用額外添加屬性，任何元素都可以是 Drop Location。</p></blockquote><p><br/><br/></p><h4 id="交互事件"><a href="#交互事件" class="headerlink" title="# 交互事件"></a># 交互事件</h4><p>由於前面的表格已經大致說明了各個事件的觸發時機了，應該也都不難離解，所以我們就直接試試看能夠利用事件做些什麼效果，以及 Drag Source 和 Drop Location 之間該怎麼互動。</p><br/><p><strong>- 樣式改變</strong></p><p>我們可以利用 <code>dragstart</code> 和 <code>dragend</code> 來改變 Drag Source 的樣式，讓使用者能更清楚目前被拖曳的元素是哪一個，以及利用 <code>dragenter</code> 和 <code>dragleave</code> 來改變 Drop Location 的樣式：</p><pre><code class="html">&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;box&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;box&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;box&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="css">.container &#123;  background: white;&#125;.container.hover &#123;  background: aliceBlue;&#125;.box &#123;  background: lightblue;  cursor: grab;&#125;.box.dragging &#123;  background: lightgreen;  cursor: grabbing;&#125;</code></pre><pre><code class="javascript">const boxes = document.querySelectorAll(&quot;.box&quot;);boxes.forEach((box) =&gt; &#123;  box.addEventListener(&quot;dragstart&quot;, (e) =&gt; &#123;    e.target.classList.add(&quot;dragging&quot;);  &#125;);  box.addEventListener(&quot;dragend&quot;, (e) =&gt; &#123;    e.target.classList.remove(&quot;dragging&quot;);  &#125;);&#125;);const containers = document.querySelectorAll(&quot;.container&quot;);containers.forEach((container) =&gt; &#123;  container.addEventListener(&quot;dragenter&quot;, (e) =&gt; &#123;    e.target.classList.add(&quot;hover&quot;);  &#125;);  container.addEventListener(&quot;dragleave&quot;, (e) =&gt; &#123;    e.target.classList.remove(&quot;hover&quot;);  &#125;);&#125;);</code></pre><br/><p><strong>- 鼠標位置</strong></p><p>由於 <code>drag</code> 和 <code>dragover</code> 都是不斷觸發的事件，所以我們可以用來追蹤使用者游標的位置：</p><pre><code class="javascript">const boxes = document.querySelectorAll(&quot;.box&quot;);boxes.forEach((box) =&gt; &#123;  box.addEventListener(&quot;drag&quot;, (e) =&gt; &#123;    console.log(`滑鼠在視窗中的座標: $&#123;e.clientX&#125; / $&#123;e.clientY&#125;`);  &#125;);&#125;);const containers = document.querySelectorAll(&quot;.container&quot;);containers.forEach((container) =&gt; &#123;  container.addEventListener(&quot;dragover&quot;, (e) =&gt; &#123;    console.log(`滑鼠在 Drop Location 中的座標: $&#123;e.offsetX&#125; / $&#123;e.offsetY&#125;`);  &#125;);&#125;);</code></pre><br/><p><strong>- 移動元素</strong></p><p>最後只要搭配上 <code>drop</code> 事件，我們就可以達成移動元素的效果，不過有個要注意的事情是 <code>dragover</code> 和 <code>drop</code> 會有執行上的衝突，所以如果要讓 <code>drop</code> 的 Callback 能夠順利觸發，必須要在 <code>dragover</code> 中將預設行為給取消掉：</p><pre><code class="javascript">let source = null;const boxes = document.querySelectorAll(&quot;.box&quot;);boxes.forEach((box) =&gt; &#123;  box.addEventListener(&quot;dragstart&quot;, (e) =&gt; &#123;    source = e.target;  box.addEventListener(&quot;dragend&quot;, (e) =&gt; &#123;    source = null;  &#125;);&#125;);const containers = document.querySelectorAll(&quot;.container&quot;);containers.forEach((container) =&gt; &#123;  container.addEventListener(&quot;dragover&quot;, (e) =&gt; &#123;    e.preventDefault();  &#125;);  container.addEventListener(&quot;drop&quot;, (e) =&gt; &#123;    e.target.appendChild(source)    e.target.classList.remove(&quot;hover&quot;);  &#125;);&#125;);</code></pre><img src="move.gif" style="margin: 24px auto;" /><p><br/><br/></p><p>看過以上示範後是不是覺得 Drag &amp; Drop API 還蠻簡單的呢？只要先設定好需要拖曳的元素後，透過幾個事件的交互就可以達到這樣的效果。不過其實很多 API 都是這樣的，使用起來都很容易，但實際上要應用時就容易邏輯卡住，所以為了讓各位能對 Drag &amp; Drop 有更具體的印象，明天就來實際寫一個拖拉的 ToDo List 吧！</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10280217">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;就是要拖拖拉拉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;現在使用手機、平板來瀏覽網站的機會比起電腦來說，實在是多太多了，所以其實 Web API 也不斷針對這樣的趨勢在靠攏，像是我們前期介紹的 Battery API 就是一個案例。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / ScrollIntoView</title>
    <link href="https://maxleebk.com/2021/10/07/webApi/webApi-24/"/>
    <id>https://maxleebk.com/2021/10/07/webApi/webApi-24/</id>
    <published>2021-10-07T08:47:00.000Z</published>
    <updated>2023-10-23T03:50:24.604Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>將元素玩弄與指尖，說來就來，呼風喚雨</p></blockquote><p>既然有 IntersectionObserver 能夠偵測元素是否進入視窗中，那當然也會有 API 能夠主動讓元素進入到我們的視野當中，第一時間，各位可能有想到 <code>window.scrollTo</code> 來指定「捲軸」的滾動距離，但其實今天介紹的 ScrollIntoView 能夠更方便的做到這件事。</p><hr><h2 id="ScrollIntoView"><a href="#ScrollIntoView" class="headerlink" title="ScrollIntoView"></a>ScrollIntoView</h2><p>說到操作「捲軸」這件事，最常使用的可能會是 <code>window.scrollTo</code> 或 <code>window.scrollBy</code>，可以讓視窗動到任何位置，例如「回到頂部」功能就會使用 <code>scrollTo(0,0)</code> 來完成，不過如果是希望捲軸移動到某個指定元素的位置，那就還需要先計算元素之於文件頂部的距離才能做到，這時候反而運用 ScrollIntoView 就可以輕輕鬆鬆解決。</p><br/><h4 id="Element-scrollIntoView"><a href="#Element-scrollIntoView" class="headerlink" title="# Element.scrollIntoView"></a># Element.scrollIntoView</h4><p><code>scrollIntoView</code> 並不隸屬於 Window，反而是 Element 的 method，而執行 <code>scrollIntoView</code> 就會是需要進入視窗中的目標元素。</p><pre><code class="javascript">const element = document.getElementById(&quot;box&quot;);window.addEventListener(&quot;click&quot;, function () &#123;  element.scrollIntoView();&#125;);</code></pre><img src="intoView.gif" style="max-width: 600px; margin: 24px auto;" /><p>呼叫之後，視窗捲軸就會直接 <strong>「跳」</strong> 到 <strong>「元素頂部對齊視窗頂部」</strong> 的距離，而其實我們可以傳入參數來調整捲軸移動的方式與位置，可以接收的參數形式有兩種：</p><br/><ul><li><p><strong>alignToTop</strong>： 第一種是傳入布林值，這個布林值會決定是否要讓「捲軸位置」剛好讓元素頂部對齊視窗頂部。</p></li><li><p><strong>scrollIntoViewOptions</strong>： 第二種是傳入物件，這物件當中可以有三個屬性來調整更細節的捲動設定：</p><ul><li><code>behavior</code>： 這個屬性接受 <code>auto</code>、<code>smooth</code> 兩個值，決定了捲軸的移動方式要用「跳」的還是用「滑」的。預設為 <code>auto</code> 跳的</li><li><code>block</code>： 這個屬性決定了垂直捲軸的位置，接受 <code>start</code>、<code>center</code>、<code>end</code> 和 <code>nearest</code> 四種。預設為 <code>start</code></li><li><code>inline</code>： 這個屬性則決定水平捲軸的位置，也是 <code>start</code>、<code>center</code>、<code>end</code> 和 <code>nearest</code> 四種。預設為 <code>nearest</code></li></ul></li></ul><p>其中 <code>start</code> 代表對齊垂直捲軸的頂部、水平卷軸的左側，<code>end</code> 對齊垂直底部、水平右側，<code>center</code> 自然就是對齊中心點，而 <code>nearest</code> 則是依據元素當下位置來判斷最近的位置來對齊</p><pre><code class="javascript">element.scrollIntoView();element.scrollIntoView(true);element.scrollIntoView(false);element.scrollIntoView(&#123; block: &quot;end&quot; &#125;);element.scrollIntoView(&#123;  behavior: &quot;smooth&quot;,  block: &quot;center&quot;,  inline: &quot;nearest&quot;,&#125;);</code></pre><img src="align.png" style="margin: 24px auto;" /><p>另外如果目標元素被放在其他也有「捲軸」的元素中，那它會將每一層的捲軸都進行滾動，並且盡可能的達成我們指定的位置，會說「盡可能」是因為未必視窗會有垂直或水平捲軸，若沒有捲軸，ScrollIntoView 也是無能為力的。</p><pre><code class="html">&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&quot;placeholder&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;target&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;placeholder&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="javascript">const target = document.querySelector(&quot;.target&quot;);target.scrollIntoView(&#123;  behavior: &quot;smooth&quot;,  block: &quot;start&quot;,  inline: &quot;end&quot;,&#125;);</code></pre><img src="move.gif" style="max-width: 600px; margin: 24px auto;" /><p><br/><br/></p><p>不曉得有沒有人有發現其實 ScrollIntoView 的功能很像 HTML 中 <code>&lt;a&gt;</code> 標籤的錨點（Anchor Link）功能，所以這也是為什麼 ScrollIntoView 可能比較少用的原因，但其實錨點連結並不能實踐 <code>smooth</code> 滑動效果，也不能指定位置，所以如果你想讓 UI/UX 的體驗好一點，其實 ScrollIntoView 是更好的選擇喔。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10279669">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;將元素玩弄與指尖，說來就來，呼風喚雨&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然有 IntersectionObserver 能夠偵測元素是否進入視窗中，那當然也會有 API 能夠主動讓元素進入到我們的視野當中，第一時間，各位可能有想到 &lt;co</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / Animation On Scroll</title>
    <link href="https://maxleebk.com/2021/10/06/webApi/webApi-23/"/>
    <id>https://maxleebk.com/2021/10/06/webApi/webApi-23/</id>
    <published>2021-10-06T14:35:00.000Z</published>
    <updated>2023-10-23T03:50:24.600Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>學以致用是最快樂的事情</p></blockquote><p>昨天我們認識了 IntersectionObserver，知道它可以偵測到元素進入畫面的時機，而這個特性非常適合用來製作 Animation On Scroll 的捲動動畫效果，像是 <a href="https://michalsnik.github.io/aos/">AOS</a> 就是一個很經典的套件，雖然 AOS 其實不是用 IntersectionObserver 實踐的，但我們可以嘗試做出類似效果的工具。</p><hr><h2 id="設計概念"><a href="#設計概念" class="headerlink" title="設計概念"></a>設計概念</h2><br/><h4 id="確立需求與功能"><a href="#確立需求與功能" class="headerlink" title="# 確立需求與功能"></a># 確立需求與功能</h4><ol><li>既然是工具，就代表要幫我們簡化一些繁複的動作</li><li>這個工具需要在元素進入可視窗口時，進行指定樣式的變化</li><li>除了樣式變化，還希望可以設定 Callback，讓我們做一些額外的操作</li></ol><p><br/><br/></p><h4 id="機制規劃與設計"><a href="#機制規劃與設計" class="headerlink" title="# 機制規劃與設計"></a># 機制規劃與設計</h4><p><strong>1. 既然是工具，就代表要幫我們簡化一些繁複的動作</strong><br>在使用 IntersectionObserver 時，總是要進行的動作就是要建立實體然後註冊目標元素，我希望可以只用一個指令就處理完這些事。這個需求應該可以包裝一個「建構函式」來處理。</p><br/><p><strong>2. 這個工具需要偵測到元素進入可視窗口時，進行指定樣式的變化</strong><br>偵測元素的部分 IntersectionObserver 會幫我們處理，而元素的樣式變化最快的方式就是利用 <code>class</code> 的增減了，但用 <code>class</code> 可能會有撞名的風險，所以我們改用 <code>data-*</code> 屬性好了。而且改變屬性這件事應該由工具處理，而不是我們都要寫一遍。</p><br/><p><strong>3. 除了樣式變化，還希望可以設定 Callback，讓我們做一些額外的操作</strong><br>由於在第一點已經決定設計一個「建構函式」來幫我們創建 IntersectionObserver 實體，那原本在創建時該傳入的 Callback Function 和 options 物件就必須要先提供給「建構函式」，它才能幫我們建立實體。</p><p><br/><br/></p><h2 id="開始實踐"><a href="#開始實踐" class="headerlink" title="開始實踐"></a>開始實踐</h2><br/><h4 id="元素的樣式變換機制"><a href="#元素的樣式變換機制" class="headerlink" title="# 元素的樣式變換機制"></a># 元素的樣式變換機制</h4><p>整理完需求及機制後，就來開始動手吧，首先是為了讓元素可以透過 <code>data-*</code> 屬性的變化來轉換樣式，所以為想要有動畫效果的元素加上 <code>data-appear=&quot;hide&quot;</code>，表示元素還沒進入畫面，未來只要把 <code>data-appear</code> 改成 <code>show</code> ，元素就會有樣式的變化。</p><pre><code class="html">&lt;div class=&quot;box&quot; data-appear=&quot;hide&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="css">.box &#123;  width: 500px;  height: 500px;  transition: 0.3s;&#125;.box[data-appear=&quot;hide&quot;] &#123;  background: white;&#125;.box[data-appear=&quot;show&quot;] &#123;  background: pink;&#125;</code></pre><p><br/><br/></p><h4 id="自動建立實體與註冊元素"><a href="#自動建立實體與註冊元素" class="headerlink" title="# 自動建立實體與註冊元素"></a># 自動建立實體與註冊元素</h4><p>再來程式部分，先宣告一個叫做 <code>Appear</code> 建構函式，其中會有一個函式 <code>init</code>，要用來創建 IntersectionObserver 實體以及註冊要觀察的元素，未來只要執行 <code>appear.init()</code> 一行就搞定了，而且因為已經確定只要有 <code>data-appear</code> 屬性的元素就是要觀察的對象，所以直接全部抓出來註冊即可。</p><pre><code class="javascript">const Appear = function () &#123;  this.init = function (callback, options) &#123;    this.observer = new IntersectionObserver(callback, options);    const container = options.root || document;    const targetList = container.querySelectorAll(&quot;[data-appear]&quot;);    targetList.forEach((el) =&gt; &#123;      this.observer.observe(el);    &#125;);  &#125;;&#125;;const appear = new Appear();</code></pre><p><br/><br/></p><h4 id="Callback-包裝與元素屬性切換"><a href="#Callback-包裝與元素屬性切換" class="headerlink" title="# Callback 包裝與元素屬性切換"></a># Callback 包裝與元素屬性切換</h4><p>前面有說，工具需要自動改變元素的 <code>data-appear</code> 屬性，而不是由我們手動寫在 Callback 中，所以看來傳入 <code>init</code> 的 <code>callback</code> 參數不能直接放到 IntersectionObserver 中，需要另外在包裝一次。</p><p>包裝後的 Callback 就可以在元素進出畫面時進行 <code>data-appear</code> 屬性的調整了，另外我們也將 <code>entry.target</code> 和改變後的狀態傳進 <code>init</code> 的 <code>callback</code> 中，讓使用工具的人可以取得額外資訊。</p><pre><code class="javascript">const Appear = function () &#123;  this.init = function (callback, options) &#123;    // IntersectionObserver 要觸發的 Callback Function    const obCallback = function (entries) &#123;      entries.forEach((entry) =&gt; &#123;        // 取得元素進入當下的狀態        let state = entry.target.getAttribute(&quot;data-appear&quot;);        if (state === &quot;hide&quot; &amp;&amp; entry.isIntersecting) &#123;          // 從 hide 的狀態下進到畫面時...          state = &quot;show&quot;;          entry.target.setAttribute(&quot;data-appear&quot;, state);          callback(entry.target, state);        &#125; else if (state === &quot;show&quot; &amp;&amp; !entry.isIntersecting) &#123;          // 從 show 的狀態下離開畫面時...          state = &quot;hide&quot;;          entry.target.setAttribute(&quot;data-appear&quot;, state);          callback(entry.target, state);        &#125;      &#125;);    &#125;;    this.observer = new IntersectionObserver(obCallback, options);    const container = options.root || document;    const targetList = container.querySelectorAll(&quot;[data-appear]&quot;);    targetList.forEach((el) =&gt; &#123;      this.observer.observe(el);    &#125;);  &#125;;&#125;;const appear = new Appear();</code></pre><p><br/><br/></p><h4 id="自定義的函式參數"><a href="#自定義的函式參數" class="headerlink" title="# 自定義的函式參數"></a># 自定義的函式參數</h4><p>再來其實我覺得原本 IntersectionObserver 的 <code>options</code> 參數設定有點不是很容易懂，所以我們自己設計一個新的物件做為 <code>init</code> 的參數設定，以下是它的屬性名稱及預設值，順便也把 <code>callback</code> 一起放進去了：</p><pre><code class="javascript">const defaultOptions = &#123;  container: null,  offsetTop: 0,  offsetRight: 0,  offsetBottom: 0,  offsetLeft: 0,  threshold: 0,  callback: function () &#123;&#125;,&#125;;</code></pre><p>這樣在使用工具的人只要傳一個參數到 <code>init</code> 中就好，而且屬性名稱也比較好了解，傳進去後只要在 <code>init</code> 內部再轉換成原本 IntersectionObserver 接受的格式即可。</p><pre><code class="javascript">const Appear = function () &#123;  this.init = function (userOptions) &#123;    const options = &#123; ...defaultOptions, ...userOptions &#125;;    const obOptions = &#123;      root: options.container,      rootMargin: [        `$&#123;options.offsetTop&#125;px`,        `$&#123;options.offsetRight&#125;px`,        `$&#123;options.offsetBottom&#125;px`,        `$&#123;options.offsetLeft&#125;px`,      ].join(&quot; &quot;),      threshold: options.threshold,    &#125;;    //...其他省略    this.observer = new IntersectionObserver(obCallback, obOptions);  &#125;;&#125;;const appear = new Appear();</code></pre><p><br/><br/></p><h4 id="防呆機制與註銷"><a href="#防呆機制與註銷" class="headerlink" title="# 防呆機制與註銷"></a># 防呆機制與註銷</h4><p>最後為了避免有人重複執行 <code>init</code>，我們在最前面進行判斷來阻擋，額外也可以再做一個關閉 IntersectionObserver 的功能：</p><pre><code class="javascript">const Appear = function () &#123;  this.init = function (userOptions) &#123;    if (this.observer) return;    //...其他省略  &#125;;  // 註銷所有觀察元素並釋放 observer  this.destroy = function () &#123;    if (!this.observer) return;    this.observer.disconnect();    this.observer = null;  &#125;;&#125;;const appear = new Appear();</code></pre><p><br/><br/></p><h2 id="實際使用"><a href="#實際使用" class="headerlink" title="實際使用"></a>實際使用</h2><p>以上的 JS 程式碼我們可以包成一支 <code>appear.js</code> 檔案，只要未來有專案需要使用時直接引入並且呼叫 <code>init</code> 就可以了：</p><pre><code class="html">&lt;style&gt;  .box &#123;    width: 500px;    height: 500px;    margin: 30px auto;    transition: 0.3s;  &#125;  .box[data-appear=&quot;hide&quot;] &#123;    background: white;  &#125;  .box[data-appear=&quot;show&quot;] &#123;    background: pink;  &#125;&lt;/style&gt;&lt;div class=&quot;box&quot; data-appear=&quot;hide&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot; data-appear=&quot;hide&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot; data-appear=&quot;hide&quot;&gt;&lt;/div&gt;&lt;script src=&quot;appear.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  appear.init(&#123;    threshold: 0.5,    callback: function (target, state) &#123;      console.log(target, state);    &#125;,  &#125;);&lt;/script&gt;</code></pre><img src="result.gif" style="max-width: 800px; margin: 24px auto;" /><p><br/><br/></p><p>這樣的工具是不是非常實用呢？而且能夠自己做出一個以後也能夠不斷使用的小套件真的是非常有成就感，有興趣的小夥伴們也可以發揮自己的創新，把這個小工具不斷的擴充，增加新功能喔。完整原始碼，我就放在 CodePen，文章中如果有不清楚的，可以再去看看。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10279479">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;學以致用是最快樂的事情&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;昨天我們認識了 IntersectionObserver，知道它可以偵測到元素進入畫面的時機，而這個特性非常適合用來製作 Animation On Scroll 的捲動動畫效果，像是</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / IntersectionObserver</title>
    <link href="https://maxleebk.com/2021/10/05/webApi/webApi-22/"/>
    <id>https://maxleebk.com/2021/10/05/webApi/webApi-22/</id>
    <published>2021-10-05T12:11:00.000Z</published>
    <updated>2023-10-23T03:50:24.576Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>當你進入我的眼簾，我們的命運就有了交集～</p></blockquote><p>看到 Observer，應該就知道今天要介紹的又是「觀察者」系列的 API 了，而且這次的觀察者可能比前面的 MutationObserver 和 ResizeObserver 還要實用。只要有了它，Scroll Animation 就只是一塊小蛋糕了。</p><hr><h2 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h2><p>IntersectionObserver 幫我們觀察的是元素的「相交（intersect）」變動，也就是元素與指定可視窗口的「相交與否」發生變動時觸發。</p><p>簡單來說就是頁面元素因捲動而進入到可視範圍中，或是離開了可視範圍時，IntersectionObserver 就會執行指定任務，所以我們可以利用它來偵測「某個元素是不是進入視窗中」了，而且還可以調整許多細微的偵測設定，相當強大。</p><img src="inter.gif" style="max-width: 600px; margin: 24px auto;" /><br/><h4 id="Window-IntersectionObserver"><a href="#Window-IntersectionObserver" class="headerlink" title="# Window.IntersectionObserver"></a># Window.IntersectionObserver</h4><p>和其他「觀察者」一樣，<code>IntersectionObserver</code> 為一個建構函示，需要使用 <code>new</code> 關鍵字來創建實體，並且需要傳入 Callback Function 作為參數，該 Callback 會獲得一個存放 IntersectionObserverEntry 的陣列以及「觀察者（observer）」自身實體，</p><br/><ul><li><strong>IntersectionObserverEntry</strong>： 其中會有一些關於觀測元素與可視範圍交互的相關資訊，後面會詳細介紹。</li><li><strong>IntersectionObserver</strong>： 呼叫 Callback 的 IntersectionObserver 實體，即為該 Function 的 <code>this</code>。</li></ul><br/><pre><code class="javascript">const observer = new IntersectionObserver((entries, owner) =&gt; &#123;  console.log(owner); // IntersectionObserver 實體  entries.forEach((entry) =&gt; &#123;    console.log(entry); // IntersectionObserverEntry 物件  &#125;);&#125;);</code></pre><br/><p>另外，IntersectionObserver 除了 Callback 之外還有一個可選的 <code>options</code> 參數可以設定：</p><pre><code class="javascript">const callback = function (entries) &#123;  console.log(entries);&#125;;const observer = new IntersectionObserver(callback, &#123;  root: null,  rootMargin: &quot;0px 0px 0px 0px&quot;,  threshold: 0.0,&#125;);</code></pre><br/><p>這個 <code>options</code> 參數須為物件，並接受上面這三個屬性：</p><ul><li><strong>root</strong>： 這個屬性將決定要以哪個元素的可視窗口作為觀察依據，預設為 <code>null</code>，表示以 Viewport 作為判斷依據，也可以設定成其他元素。</li><li><strong>rootMargin</strong>： 這個屬性決定的是窗口的縮放，設定規則和 CSS 的 <code>margin</code>，可以給定一個值，也可以四邊各自設定，正值為外擴，負值為內縮。</li><li><strong>threshold</strong>： 這個屬性是設定觸發的<strong>比例門檻</strong>，當目標元素與可視範圍的相交範圍「經過」了這道門檻，Callback 就會被觸發，舉例來說：<ul><li>預設值 <code>0</code>： 當相交範圍的比例「開始大於 0%」或「開始小於 0%」 的瞬間會觸發。</li><li>設定為 <code>1</code>： 當相交範圍的比例「開始大於 100%」或「開始小於 100%」 的瞬間會觸發。</li><li>設定成陣列 <code>[0, 0.5, 1]</code>： 規則如上，但目標元素就會有三個觸發時機。</li></ul></li></ul><img src="options2.png" style="margin: 24px auto;" /><p><br/><br/></p><h4 id="IntersectionObserver-observe"><a href="#IntersectionObserver-observe" class="headerlink" title="# IntersectionObserver.observe"></a># IntersectionObserver.observe</h4><p>老樣子，觀察者們都需要我們使用 <code>observe</code> method 來指定觀察對象：</p><pre><code class="javascript">const observer = new IntersectionObserver((entries) =&gt; &#123;  console.log(entries);&#125;);const div = document.querySelector(&quot;div&quot;);observer.observe(div);</code></pre><p><br/><br/></p><h4 id="IntersectionObserver-unobserve"><a href="#IntersectionObserver-unobserve" class="headerlink" title="# IntersectionObserver.unobserve"></a># IntersectionObserver.unobserve</h4><p>若要註銷某元素的觀察，IntersectionObserver 一樣有 <code>unobserve</code> method 可以使用：</p><pre><code class="javascript">const observer = new IntersectionObserver((entries) =&gt; &#123;  console.log(entries);&#125;);const div = document.querySelector(&quot;div&quot;);observer.observe(div);observer.unobserve(div);</code></pre><p><br/><br/></p><h4 id="IntersectionObserver-disconnect"><a href="#IntersectionObserver-disconnect" class="headerlink" title="# IntersectionObserver.disconnect"></a># IntersectionObserver.disconnect</h4><p>當然也可以一次性的註銷所有元素的觀察，同樣要記得，IntersectionObserver 實體並不會消失，只是沒有觀測中的元素而已，你依然可以再次使用 <code>observe</code> 來註冊一個新的觀察：</p><pre><code class="javascript">const observer = new IntersectionObserver((entries) =&gt; &#123;  console.log(entries);&#125;);const box1 = document.querySelector(&quot;.box1&quot;);const box2 = document.querySelector(&quot;.box2&quot;);observer.observe(box1);observer.disconnect();observer.observe(box2);</code></pre><p><br/><br/></p><h4 id="IntersectionObserverEntry-物件"><a href="#IntersectionObserverEntry-物件" class="headerlink" title="# IntersectionObserverEntry 物件"></a># IntersectionObserverEntry 物件</h4><p>IntersectionObserver 和之前介紹的 MutationObserver 和 ResizeObserver 不同，它是<strong>「非同步」</strong>觸發的，畢竟「相交與否」這件事情是一個瞬間，不會有不斷疊加的狀態，所以也就不需要考慮連續觸發導致的效能問題，也就是說儘管你非常快速的來回捲動，它也不會將事件合併。</p><p>而 IntersectionObserverEntry 需要用陣列存放，是因為會有多個觀測中的元素同時進入／離開可視範圍的可能，這時候每一筆的 IntersectionObserverEntry 便代表一個元素的變動，而其中有許多屬性可以提供我們使用，下面就一一向各位介紹：</p><br/><ul><li><strong>IntersectionObserverEntry.target</strong><br>發生進出變動的目標元素(element)，每個「觀察者」都會提供的資訊。</li></ul><br/><ul><li><strong>IntersectionObserverEntry.isIntersecting</strong><br><code>isIntersecting</code> 是當中非常實用的屬性，用來表示目前元素是否與可是範圍（root）相交，也就是目標元素是否進入到可視範圍中。</li></ul><pre><code class="javascript">const observer = new IntersectionObserver((entries) =&gt; &#123;  entries.forEach((entry) =&gt; &#123;    if (entry.isIntersecting) &#123;      // 目標元素進入 viewport 時執行    &#125; else &#123;      // 目標元素離開 viewport 時執行    &#125;  &#125;);&#125;);</code></pre><br/><ul><li><strong>IntersectionObserverEntry.intersectionRatio</strong><br>這個屬性提供的是目前元素與觀察窗口的相交比例，會是一個 0~1 的數值，計算方式是 <code>相交面積 / 目標元素面積</code>。</li></ul><br/><ul><li><strong>IntersectionObserverEntry.boundingClientRect</strong><br>這個屬性會提供目標元素的尺寸、座標資訊，而它就等於拿 <code>target</code> 去執行昨天介紹的 <code>getBoundingClientRect</code> 所得到的結果。</li></ul><br/><ul><li><strong>IntersectionObserverEntry.rootBounds</strong><br>這個拿到的也會是 <code>getBoundingClientRect</code> 資訊，但計算的是可視窗口的尺寸、座標，要記得有 <code>rootMargin</code> 的影響。</li></ul><br/><ul><li><strong>IntersectionObserverEntry.intersectionRect</strong><br>和前面都一樣，不過提供的區塊範圍很特別，是目標元素與可視窗口的「交疊範圍」。</li></ul><img src="rect.png" style="max-width: 600px; margin: 24px auto;" /><p><br/><br/></p><h4 id="使用情境"><a href="#使用情境" class="headerlink" title="# 使用情境"></a># 使用情境</h4><p>IntersectionObserver 的使用情境很多，可以做「捲動特效」或是「無限捲動」，下面我們就來試試寫個無間捲動的功能看看，先看效果：</p><img src="infinity.gif" style="max-width: 600px; margin: 24px auto;" /><pre><code class="html">&lt;ul class=&quot;list&quot;&gt;  &lt;li class=&quot;item&quot;&gt;    &lt;div class=&quot;avatar&quot;&gt;&lt;/div&gt;    &lt;div&gt;      &lt;h3&gt;Name&lt;/h3&gt;      &lt;h5&gt;        Lorem ipsum dolor sit, amet consectetur adipisicing elit. Rem tenetur odit.rem ipsum dolor sit, amet consectetur        adipisicing elit. Rem tenetur odit      &lt;/h5&gt;    &lt;/div&gt;  &lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code class="javascript">const ul = document.querySelector(&quot;ul&quot;);// 這個 function 會一次新增20筆項目到 ul 中// 用來模擬獲取資料後渲染畫面const getMoreItem = () =&gt; &#123;  const fragment = document.createDocumentFragment();  for (let i = 0; i &lt;= 20; i++) &#123;    const item = document.querySelector(&quot;li:first-child&quot;);    const newItem = item.cloneNode(true);    fragment.appendChild(newItem);  &#125;  ul.appendChild(fragment);&#125;;const observer = new IntersectionObserver(  function (entries, observer) &#123;    // 每當目標元素進入畫面後就新增20筆，並且重置觀察的元素    if (entries[0].isIntersecting) &#123;      getMoreItem();      observer.unobserve(entries[0].target);      observer.observe(document.querySelector(&quot;li:nth-last-child(2)&quot;));    &#125;  &#125;,  &#123; root: ul &#125; // 觀察窗口為 ul 的元素範圍);getMoreItem();observer.observe(document.querySelector(&quot;li:nth-last-child(2)&quot;));</code></pre><p>無限捲動的功能是非常常見的一個功能，平常在滑 FB 或 IG 時，貼文能不段的出現就是使用無線捲動，而使用 IntersectionObserver 就可以輕鬆做到。</p><p>我們實踐的概念也非常簡單，就是在目標元素進入窗口時去向後端獲取資料並渲染在畫面上，然後不斷的重新觀察倒數第二個 <code>li</code>，所以可以看到 Callback 中有執行 <code>unobserve</code> 來註銷原本的元素，然後又再次使用 <code>observe</code> 來註冊新元素。</p><p><br/><br/></p><p>IntersectionObserver 是不是非常方便呢？昨天我們還在用 <code>getBoundingClientRect</code> 來計算元素是否進入畫面，今天已經連計算都不用計算，完全交由「觀察者」來幫忙偵測，我們只要坐等通知就好了，大家快把它學起來，當個懶惰的工程師吧！</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10279046">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;當你進入我的眼簾，我們的命運就有了交集～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到 Observer，應該就知道今天要介紹的又是「觀察者」系列的 API 了，而且這次的觀察者可能比前面的 MutationObserver 和 ResizeOb</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / GetBoundingClientRect</title>
    <link href="https://maxleebk.com/2021/10/04/webApi/webApi-21/"/>
    <id>https://maxleebk.com/2021/10/04/webApi/webApi-21/</id>
    <published>2021-10-04T08:54:00.000Z</published>
    <updated>2023-10-23T03:50:24.564Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>小孩才做選擇，成年人當然是尺寸、座標全都要！</p></blockquote><p>昨天介紹的 ResizeObserver API 可以觀察到元素的尺寸變動時執行回呼，並且會提供元素變動後的「尺寸」、「座標」等資訊，而今天介紹的 GetBoundingClientRect 雖然無法再觀察元素變動了，但我們可以主動出擊，直接索取目前元素的相關資訊。</p><hr><h2 id="GetBoundingClientRect"><a href="#GetBoundingClientRect" class="headerlink" title="GetBoundingClientRect"></a>GetBoundingClientRect</h2><p>GetBoundingClientRect 可以使我們取得 Element 元素的寬高以及相對於視窗可視範圍(Viewport)的座標位置，對於前端老鳥來說可能不是那麼陌生，但對於新手來說，它不太會是第一批認識的 Web API，大部分可能都會先認識 <code>clientWidth</code>、<code>scrollWidth</code>、<code>offsetWidth</code>、<code>scrollTop</code>、<code>clientTop</code>、<code>offsetTop</code>…等等，這一大堆眼花撩亂讓人容易混淆的系列屬性。</p><br/><h4 id="元素的各種寬高與位置"><a href="#元素的各種寬高與位置" class="headerlink" title="# 元素的各種寬高與位置"></a># 元素的各種寬高與位置</h4><p>為了讓各位更好的理解 GetBoundingClientRect，先來幫各位整理及複習前面提到的這一大堆元素屬性，</p><ul><li><strong>offsetWidth / offsetHeight</strong>： 元素 <code>borderBox</code> 的寬/高，包含 <code>padding</code>、<code>border</code></li><li><strong>clientWidth / clientHeight</strong>： 元素 <code>paddingBox</code> 的寬/高，包含 <code>padding</code>，不包含 <code>border</code></li><li><strong>scrollWidth / scrollHeight</strong>： 元素包含 <code>padding</code> 及外溢內容的寬/高，不包含 <code>border</code></li></ul><img src="width.png" style="max-width: 600px; margin: 24px auto;" /><ul><li><strong>offsetTop / offsetLeft</strong>： 元素 <code>borderBox</code> 相對於 <code>offsetParent</code> 的垂直/水平距離</li><li><strong>clientTop / clientLeft</strong>： 元素 <code>paddingBox</code> 相對於 <code>borderBox</code> 的垂直/水平距離</li><li><strong>scrollTop / scrollLeft</strong>： 元素 <code>paddingBox</code> 被捲動的垂直/水平距離</li></ul><img src="top.png" style="max-width: 600px; margin: 24px auto;" /><p><br/><br/></p><h4 id="Element-getBoundingClientRect"><a href="#Element-getBoundingClientRect" class="headerlink" title="# Element.getBoundingClientRect"></a># Element.getBoundingClientRect</h4><p>其實剛剛介紹的眾多屬性，相信大家或多或少都有使用過，尤其在一些捲動事件中常常會出現它們的身影，不過在今天之後，你使用它們的機會可能會漸漸減少了。</p><p><code>getBoundingClientRect</code> 的使用方式非常簡單，它屬於 Element 的原生 method，直接互叫即可：</p><pre><code class="javascript">const div = document.querySelector(&quot;div&quot;);console.log(div.getBoundingClientRect());</code></pre><br/><p>執行過後便會回傳一個 DOMRect 物件，該物件中就會有指定元素的相關尺寸與座標訊息：</p><ul><li><strong>width</strong>： 元素的 <code>borderBox</code> 寬度，相當於 <code>offsetWidth</code></li><li><strong>height</strong>： 元素的 <code>borderBox</code> 高度，相當於 <code>offsetHeight</code></li><li><strong>x</strong>： 元素的 <code>borderBox</code> 左上角相對於視窗的水平(Ｘ)座標</li><li><strong>y</strong>： 元素的 <code>borderBox</code> 左上角相對於視窗的垂直(Ｙ)座標</li><li><strong>left</strong>： 元素的 <code>borderBox</code> 左上角相對於視窗的水平(Ｘ)座標，等同 <code>x</code></li><li><strong>top</strong>： 元素的 <code>borderBox</code> 左上角相對於視窗的垂直(Ｙ)座標，等同 <code>y</code></li><li><strong>right</strong>： 元素的 <code>borderBox</code> 右下角相對於視窗的水平(Ｘ)座標</li><li><strong>bottom</strong>： 元素的 <code>borderBox</code> 右下角相對於視窗的垂直(Ｙ)座標</li></ul><br/><blockquote><p>DOMRect 跟昨天介紹的 <code>ResizeObserverEntry.contentRect</code> 所回傳的 DOMRectReadOnly 格式是一樣的，但當中數值所代表的意義完全不同，不要被混淆囉。</p></blockquote><img src="rect.png" style="margin: 24px auto;" /><p>有了這些資訊後，針對一些捲動事件的需求其實就會變得簡單許多，像是我們常常會做的事情是「判斷某元素是否進入可視範圍」，就可以來看看使用 <code>getBoundingClientRect</code> 後的差別：</p><pre><code class="javascript">const div = document.querySelector(&quot;div&quot;);// 不使用 getBoundingClientRectwindow.addEventListener(&quot;scroll&quot;, function (e) &#123;  if (div.offsetTop + div.offsetHeight &lt;= window.pageYOffset) &#123;    console.log(&quot;元素底端已離開畫面&quot;);  &#125; else if (div.offsetTop &lt;= window.pageYOffset + window.innerHeight) &#123;    console.log(&quot;元素頂端已進入畫面&quot;);  &#125;&#125;);// 使用 getBoundingClientRectwindow.addEventListener(&quot;scroll&quot;, function (e) &#123;  const &#123; top, bottom &#125; = div.getBoundingClientRect();  if (bottom &lt;= 0) &#123;    console.log(&quot;元素底端已離開畫面&quot;);  &#125; else if (top &lt;= window.innerHeight) &#123;    console.log(&quot;元素頂端已進入畫面&quot;);  &#125;&#125;);</code></pre><p>可以看到，如果不使用 <code>getBoundingClientRect</code> 需進行較複雜的計算，而且如果該元素的 <code>offsetParent</code> 不是 <code>body</code> 的話，這個計算就會出現 Bug。反之使用 <code>getBoundingClientRect</code> 的程式碼簡潔又容易理解，而且因為 <code>top</code> 和 <code>bottom</code> 的數值是直接相對視窗計算出來的，所以也不用去顧慮元素的 <code>offsetParent</code>。</p><blockquote><p>小技巧： 利用 <code>window.pageYOffset</code> + <code>getBoundingClientRect().top</code> 就可以計算出元素相對於文件(document)的絕對座標喔。</p></blockquote><p><br/><br/></p><h4 id="實際練習"><a href="#實際練習" class="headerlink" title="# 實際練習"></a># 實際練習</h4><p>為了讓大家更能感受到 <code>getBoundingClientRect</code> 的強大，我們來做一個 「動態 Highlight」 的小練習，需求是「當游標滑到文章中的粗體字時會自動添加底色，且底色在不同關鍵字之間切換時，要有移動的過渡效果」。先看效果：</p><img src="bounding.gif" style="max-width: 700px; margin: 24px auto;" /><pre><code class="css">.highlight &#123;  position: fixed;  background: yellowgreen;&#125;</code></pre><pre><code class="javascript">const highlight = document.querySelector(&quot;.highlight&quot;);const bold = document.querySelectorAll(&quot;b&quot;);let hoverElement;bold.forEach((el) =&gt; &#123;  el.addEventListener(&quot;mouseenter&quot;, function () &#123;    hoverElement = this;    highlight.style.transition = &quot;0.3s&quot;;    setHighlight();  &#125;);&#125;);// 為了在視窗滾動時不會跑版，要在 scroll 進行重新定位window.addEventListener(&quot;scroll&quot;, function () &#123;  highlight.style.transition = &quot;0s&quot;;  if (hoverElement) setHighlight();&#125;);function setHighlight() &#123;  const &#123; width, height, top, left &#125; = hoverElement.getBoundingClientRect();  highlight.textContent = hoverElement.textContent;  highlight.style.width = width + &quot;px&quot;;  highlight.style.height = height + &quot;px&quot;;  highlight.style.top = top + &quot;px&quot;;  highlight.style.left = left + &quot;px&quot;;&#125;</code></pre><p>整體概念就是在指定的元素上綁定 <code>mouseenter</code> 事件，並在事件發生時使用 <code>getBoundingClientRect</code> 來取得該元素的尺寸座標資訊，然後將其設定在 Highlight 元素的樣式上。</p><p>不要認為這樣的功能效果好像很簡單，如果沒有 <code>getBoundingClientRect</code> 的話，做起來是特別麻煩的，想要實際玩玩看的話，這邊提供我已經寫好的 <a href="https://codepen.io/max-lee/pen/GREVWGa">CodePen</a>，並且也鼓勵大家發揮創意來試試看其他的應用，感受一下它的好用之處。</p><p><br/><br/></p><p>希望經過今天的介紹，各位已經開始愛上 <code>getBoundingClientRect</code> 了，我本身就蠻常使用的，比較記下一堆容易搞混的屬性，只需要一行我就可以取得那些經常使用的資訊，而且還可以剩下很多麻煩的計算，何樂不為呢？</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10278542">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;小孩才做選擇，成年人當然是尺寸、座標全都要！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;昨天介紹的 ResizeObserver API 可以觀察到元素的尺寸變動時執行回呼，並且會提供元素變動後的「尺寸」、「座標」等資訊，而今天介紹的 GetBou</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / ResizeObserver</title>
    <link href="https://maxleebk.com/2021/10/03/webApi/webApi-20/"/>
    <id>https://maxleebk.com/2021/10/03/webApi/webApi-20/</id>
    <published>2021-10-03T14:33:00.000Z</published>
    <updated>2023-10-23T03:50:24.560Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你的改變，我看得見！</p></blockquote><p>今天要介紹的是 ResizeObserver，它和昨天的 MutationObserver 非常相像，都是透過「觀察者模式」的設計方式來監測元素，不過 ResizeObserver 監測的變動是元素的「大小」。</p><hr><h2 id="ResizeObserver"><a href="#ResizeObserver" class="headerlink" title="ResizeObserver"></a>ResizeObserver</h2><p>各位應該有使用過 window 的 <code>resize</code> 事件吧？只要視窗大小有更動，事件就會觸發並執行 Callback，然後各位也一定跟我一樣，肖想著把 <code>resize</code> 事件綁定在一般元素上，可想而知是不會成功的，但 ResizeObserver 的出現，終於可以實現我們的願望了。</p><br/><h4 id="Window-ResizeObserver"><a href="#Window-ResizeObserver" class="headerlink" title="# Window.ResizeObserver"></a># Window.ResizeObserver</h4><p>ResizeObserver： 一樣是一個建構函式，所以需要使用 <code>new</code> 關鍵字來建立實體，建立時需要傳入一個 Callback Function 作為參數，該 Function 可以接到由 ResizeObserver 提供的一個陣列作為參數，該陣列中會一個或多個 ResizeObserverEntry 物件：</p><br/><ul><li><strong>ResizeObserverEntry</strong>： 該物件中會有一些屬性，讓我們可以取得一些有關元素的「大小」、「位置」資訊，後面會再詳細介紹。</li></ul><br/><pre><code class="javascript">const observer = new ResizeObserver(function (entries) &#123;  console.log(entries);&#125;);</code></pre><p><br/><br/></p><h4 id="ResizeObserver-observe"><a href="#ResizeObserver-observe" class="headerlink" title="# ResizeObserver.observe"></a># ResizeObserver.observe</h4><p>就和昨天說的一樣，ResizeObserver 創建後並不會直接開始進行觀察，我們需要透過 <code>observe</code> 來註冊想要監測的元素，這樣 ResizeObserver 才會在該元素發生變動時進行動作，這裡有兩個參數傳入：</p><br/><ul><li><strong>target</strong>： 一個要受到觀察的 Element 元素。</li><li><strong>options</strong>：這是一個可選的參數，用來初始化觀測的設定選項，目前只有一個屬性：<ul><li>box: 這個屬性會決定要觀測元素的哪一種「盒模型(Box Model)」。可接受的值有 <code>content-box</code> 和 <code>border-box</code> 兩種，預設為 <code>content-box</code>。（其實有第三種，但使用度很低）</li></ul></li></ul><blockquote><p>如果對盒模型不太熟悉的朋友可以看<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model#%E4%BB%80%E4%B9%88%E6%98%AFcss_%E7%9B%92%E6%A8%A1%E5%9E%8B">這裡</a>瞭解一下</p></blockquote><br/><pre><code class="javascript">const observer = new ResizeObserver(function (entries) &#123;  console.log(entries);&#125;);const div = document.querySelector(&quot;div&quot;);observer.observe(div, &#123;  box: &quot;border-box&quot;,&#125;);</code></pre><p>這樣只要受到監測的元素發生寬高的變化，ResizeObserver 就會執行我們指定的行為了。</p><p><br/><br/></p><h4 id="ResizeObserver-disconnect"><a href="#ResizeObserver-disconnect" class="headerlink" title="# ResizeObserver.disconnect"></a># ResizeObserver.disconnect</h4><p>和 MutationObserver 一樣，只要使用 <code>disconnect</code> 這個 method 就可以註銷目前所有被觀察的元素，後續只要再次呼叫 <code>observe</code> 來註冊一個被觀察的元素，ResizeObserver 依然會持續運作。</p><pre><code class="javascript">const observer = new ResizeObserver(function (entries) &#123;  console.log(entries);&#125;);observer.disconnect();</code></pre><p><br/><br/></p><h4 id="ResizeObserver-unobserve"><a href="#ResizeObserver-unobserve" class="headerlink" title="# ResizeObserver.unobserve"></a># ResizeObserver.unobserve</h4><p>ResizeObserver 除了 <code>disconnect</code> 之外，還額外多了一個 <code>unobserve</code> method，它可以讓我們註銷「單個」元素的觀察，當某個元素已經不在需要受到監測，就可以將其做為參數，<code>unobserve</code> 便會把它從 ResizeObserver 的監測中移除。</p><pre><code class="javascript">const observer = new ResizeObserver(function (entries) &#123;  console.log(entries);&#125;);const div = document.querySelector(&quot;div&quot;);observer.observe(div, &#123;  box: &quot;border-box&quot;,&#125;);observer.unobserve(div);</code></pre><p><br/><br/></p><h4 id="ResizeObserver-特性"><a href="#ResizeObserver-特性" class="headerlink" title="# ResizeObserver 特性"></a># ResizeObserver 特性</h4><p>一樣的，ResizeObserver 為了優化效能問題，如果有一連串連續且即時的元素尺寸變動，那 ResizeObserver 並不會一次次觸發，而是會將它們合併成一次變動，並且只會紀錄最終的結果。</p><p>而如果同一時間中，有多個觀測中的元素都發生了尺寸變動，那 ResizeObserver 就會有相應數量的紀錄，這也就是為什麼會以陣列形式來包裝 ResizeObserverEntry 物件。</p><pre><code class="javascript">const observer = new ResizeObserver(function (entries) &#123;  entries.forEach((entry) =&gt; &#123;    console.log(entry); // ResizeObserverEntry 物件  &#125;);&#125;);const element1 = document.querySelector(&quot;#element1&quot;);const element2 = document.querySelector(&quot;#element2&quot;);observer.observe(element1);observer.observe(element2);element1.style.width = &quot;300px&quot;;element1.style.height = &quot;200px&quot;;element2.style.width = &quot;300px&quot;;element2.style.height = &quot;200px&quot;;// 看似是四次變動，但 ResizeObserver 只會視為「兩個元素的一次變動」// 因此 callback 只會觸發一次，且 entries 中會有兩組 ResizeObserverEntry</code></pre><p><br/><br/></p><h4 id="ResizeObserverEntry-物件"><a href="#ResizeObserverEntry-物件" class="headerlink" title="# ResizeObserverEntry 物件"></a># ResizeObserverEntry 物件</h4><p>ResizeObserverEntry 的屬性雖然不多，但都較為複雜，所以下面就一一拉出來說明：</p><br/><ul><li><strong>ResizeObserverEntry.target</strong><br>這是其中比較單純的屬性，讀取到的會是變動的元素(element)。</li></ul><br/><ul><li><p><strong>ResizeObserverEntry.contentRect</strong><br>這個屬性的值為一個 DOMRectReadOnly 物件，該物件會紀錄很多 <code>target</code> 的相關資訊：</p><ul><li><strong>x</strong>： 變動元素之 <code>contentBox</code> 在該元素中的Ｘ座標，通常等於 padding 寬度。</li><li><strong>y</strong>： 變動元素之 <code>contentBox</code> 在該元素中的Ｙ座標，通常等於 padding 寬度。</li><li><strong>width</strong>： 變動元素之 <code>contentBox</code> 的寬度。</li><li><strong>height</strong>： 變動元素之 <code>contentBox</code> 的高度。</li><li><strong>top</strong>： 變動元素之 <code>contentBox</code> 的「頂邊」的Ｙ座標，通常與 <code>y</code> 相同。</li><li><strong>bottom</strong>： 變動元素之 <code>contentBox</code> 的「底邊」的Ｙ座標，通常與 <code>y + height</code> 相同。</li><li><strong>left</strong>： 變動元素之 <code>contentBox</code> 的「左側」的Ｘ座標，通常與 <code>x</code> 相同。</li><li><strong>right</strong>： 變動元素之 <code>contentBox</code> 的「右側」的Ｘ座標，通常與 <code>x + width</code> 相同。</li></ul></li></ul><img src="rect.png" style="max-width: 600px; margin: 24px auto;" /><br/><ul><li><p><strong>ResizeObserverEntry.borderBoxSize</strong><br>這個屬性會是一個陣列，而陣列中會是一個或多個 borderBoxSize 物件，該物件中又會有兩個屬性：</p><ul><li><p><strong>blockSize</strong>： 這個屬性的值會是一個數值，該數值通常代表元素的高，會說通常是因為，這取決於元素被設定的書寫方向，<code>blockSize</code> 代表的是「垂直」於書寫方向的元素邊長尺寸(單位:px)。</p></li><li><p><strong>inlineSize</strong>： 而 <code>inlineSize</code> 剛好相反，它代表的是「平行」於書寫方向的元素邊長尺寸(單位:px)。</p></li></ul></li></ul><br/><ul><li><p><strong>ResizeObserverEntry.contentBoxSize</strong><br>這個屬性會是一個陣列，而陣列中會是一個或多個 contentBoxSize 物件，而物件中一樣會有兩個屬性，其實跟 borderBoxSize 物件是一樣的，但是兩者的差別在於尺寸的計算方式，borderBoxSize 是依照 <code>border-box</code> 的方式計算，contentBoxSize 則是依 <code>content-box</code> 進行計算。</p><ul><li><p><strong>blockSize</strong>： 「垂直」於書寫方向的元素邊長尺寸(單位:px)。</p></li><li><p><strong>inlineSize</strong>： 「平行」於書寫方向的元素邊長尺寸(單位:px)。</p></li></ul></li></ul><img src="box.png" style="max-width: 600px; margin: 24px auto;" /><p>以上這些資訊我們都可以在 Callback 中取得，想要做任何判斷或計算都是非常方便，所以大家可以根據需求去決定需要利用的資訊有哪些。</p><pre><code class="javascript">const observer = new ResizeObserver(function (entries) &#123;  entries.forEach((entry) =&gt; &#123;    const target = entry.target;    const borderBox = entry.borderBoxSize[0];    console.log(`$&#123;target.id&#125; 寬度: $&#123;borderBox.inlineSize&#125; 高度: $&#123;borderBox.blockSize&#125;`);  &#125;);&#125;);</code></pre><p><br/><br/></p><p>相比 MutationObserver，ResizeObserver 的使用情境就比較多了，因為今天元素的變動會受到很多因素影響，且大部分都不是我們可以完全預測掌控的，例如視窗大小的壓縮、元素內容的增加/減少、RWD 的控制的等等，這時就可以透過 ResizeObserver 來監測元素的大小，並做出相對應的動作。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10278080">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;你的改變，我看得見！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天要介紹的是 ResizeObserver，它和昨天的 MutationObserver 非常相像，都是透過「觀察者模式」的設計方式來監測元素，不過 ResizeObserver 監</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / MutationObserver</title>
    <link href="https://maxleebk.com/2021/10/02/webApi/webApi-19/"/>
    <id>https://maxleebk.com/2021/10/02/webApi/webApi-19/</id>
    <published>2021-10-02T09:19:00.000Z</published>
    <updated>2023-10-23T03:50:24.560Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我的改變，你看得見！</p></blockquote><p>在開發網頁過程中，我們最常做的事情就是對資料進行修改後運用在 DOM 元素上，像是新增 / 刪除節點、調整樣式、改寫內容或是屬性(attribute)的調整，而這些「修改 DOM」的動作通常散落在程式碼的各個角落，發生時機也並不相同，在這樣的情況下，我們能不能追蹤這些動作呢？</p><hr><h2 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h2><p>MutationObserver API 就是用來解決上述問題的，它可以讓我們追蹤 DOM 的變化，無論是子節點的變動或內容、屬性的變動，並且獲得相關的資訊，以便作出後續的行動。</p><br/><h4 id="Window-MutationObserver"><a href="#Window-MutationObserver" class="headerlink" title="# Window.MutationObserver"></a># Window.MutationObserver</h4><p>MutationObserver 本身是建構函式，所以我們需要用 <code>new</code> 關鍵字來建立實體，建立時需要傳入一個 Callback Function 作為參數，該 Function 可以接到由 MutationObserver 提供的 MutationRecords 陣列和 MutationObserver 實體作為參數：</p><br/><ul><li><strong>MutationRecords</strong>： 這個陣列會存放 MutationRecord 物件，該物件記錄著 DOM 變動的相關資訊，後面再詳細介紹。</li><li><strong>MutationObserver</strong>： 呼叫此 Callback Function 的 MutationObserver 實體，其實就等於該 Function 的 <code>this</code>。</li></ul><br/><pre><code class="javascript">const observer = new MutationObserver(function (mutations, owner) &#123;  console.log(mutation, owner);&#125;);</code></pre><p><br/><br/></p><h4 id="MutationObserver-observe"><a href="#MutationObserver-observe" class="headerlink" title="# MutationObserver.observe"></a># MutationObserver.observe</h4><p>我們可以把剛剛 <code>new</code> 出來的 MutationObserver 實體譬喻成一個「觀察者」，當這位觀察者監測到節點變動，他就會執行設定好的任務(callback)，但他目前並未被指派要觀察哪一個元素，所以我們要透過 <code>observe</code> 這個 method 來指定「被觀察的對象」，其中需要傳入兩個參數：</p><br/><ul><li><strong>target</strong>： 一個要受到觀察的 DOM 節點。</li><li><strong>options</strong>：一個初始化設定物件，用來指定 DOM 節點的哪些項目需要被觀察等相關設定。</li></ul><table><thead><tr><th align="center">屬性</th><th align="center">解釋</th><th align="center">型別、預設值</th></tr></thead><tbody><tr><td align="center">childList</td><td align="center">是否觀察節點的直屬子節點變動</td><td align="center">boolean、<code>false</code></td></tr><tr><td align="center">subtree</td><td align="center">是否觀察節點的所有子節點變動</td><td align="center">boolean、<code>false</code></td></tr><tr><td align="center">attributes</td><td align="center">是否觀察節點的屬性變動</td><td align="center">boolean、<code>false</code></td></tr><tr><td align="center">characterData</td><td align="center">是否觀察節點中的內容變動</td><td align="center">boolean、<code>false</code></td></tr><tr><td align="center">attributeOldValue</td><td align="center">是否紀錄變動前的屬性值</td><td align="center">boolean、<code>false</code></td></tr><tr><td align="center">characterDataOldValue</td><td align="center">是否紀錄變動前的內容值</td><td align="center">boolean、<code>false</code></td></tr><tr><td align="center">attributeFilter</td><td align="center">需要觀察的屬性名稱，如果為空則全部觀察</td><td align="center">array[string]、<code>[]</code></td></tr></tbody></table><br/><pre><code class="javascript">const observer = new MutationObserver(function (mutations) &#123;  console.log(mutations);&#125;);const div = document.querySelector(&quot;div&quot;);observer.observe(div, &#123;  childList: true,  attributes: true,  characterData: true,&#125;);</code></pre><p>如此一來，只要元素有被觀察到我們所指定項目的變動，MutationObserver 就會去執行 Callback。</p><p><br/><br/></p><h4 id="MutationObserver-disconnect"><a href="#MutationObserver-disconnect" class="headerlink" title="# MutationObserver.disconnect"></a># MutationObserver.disconnect</h4><p>另外還可以透過 <code>disconnect</code> 來註銷目前已經被觀察的 DOM，但 MutationObserver 實體並不會消失，只是暫時不再進行觀察，直到你又使用 <code>observe</code> 來註冊一個被觀察對象。</p><pre><code class="javascript">const observer = new MutationObserver(function (mutations) &#123;  console.log(mutations);&#125;);observer.disconnect();</code></pre><p><br/><br/></p><h4 id="MutationRecord-物件"><a href="#MutationRecord-物件" class="headerlink" title="# MutationRecord 物件"></a># MutationRecord 物件</h4><p>前面有說，MutationObserver 在執行 Callback 時會提供一個 MutationRecords 陣列，裡面會存放 MutationRecord 物件，這個段落我們要來了解為何 MutationRecord 要存放在陣列中，以及它到底存放著哪些資訊供我們使用。</p><br/><ul><li><p><strong>首先要先知道一個 MutationObserver 的特性：</strong></p><p>MutationObserver 並非事件監聽，事件是同步執行的，而 MutationObserver 則是非同步執行的，這意味著，如果目前執行的一段程序中有多次的節點變動，MutationObserver 會等到一切結束後才呼叫 Callback。</p><p>這是為了避免大量 DOM 操作所帶來的效能問題，也因此，MutationObserver 會將該程序時間內所有的變動記錄下來並包裝成陣列給我們。</p></li></ul><pre><code class="javascript">const observer = new MutationObserver(function (mutations) &#123;  mutations.forEach((record) =&gt; &#123;    console.log(record); // MutationRecord 物件  &#125;);&#125;);const div = document.querySelector(&quot;div&quot;);observer.observe(div, &#123;  childList: true,  attributes: true,  characterData: true,&#125;);div.textContent = &quot;example&quot;;div.style.background = &quot;pink&quot;;// 此時 MutationObserver 只會呼叫一次 Callback// 而 mutations 中會有兩個 MutationRecord</code></pre><br/><br/><ul><li><strong>接著來看一下 MutationRecord 中有哪些屬性：</strong><br>以下這些並非全部的屬性，只介紹了幾個比較實用的，如果想知道完整內容的話可以看<a href="https://developer.mozilla.org/zh-TW/docs/Web/API/MutationObserver#mutationobserverinit">這裡</a>。</li></ul><table><thead><tr><th align="center">屬性</th><th align="center">解釋</th><th align="center">型別</th></tr></thead><tbody><tr><td align="center">type</td><td align="center">觀察到的變動類型</td><td align="center">string</td></tr><tr><td align="center">target</td><td align="center">變動的節點</td><td align="center">Node</td></tr><tr><td align="center">addedNodes</td><td align="center">被新增的節點，如果沒有會是 <code>null</code></td><td align="center">Node</td></tr><tr><td align="center">removedNodes</td><td align="center">被刪除的節點，如果沒有會是 <code>null</code></td><td align="center">Node</td></tr><tr><td align="center">attributeName</td><td align="center">觀察到的變動屬性之名稱</td><td align="center">string</td></tr><tr><td align="center">oldValue</td><td align="center">變動前的值</td><td align="center">string</td></tr></tbody></table><blockquote><p>MutationRecord.oldValue 只有在 <code>observe()</code> 的 <code>options</code> 有開啟設定時才會有值。</p></blockquote><p><br/><br/></p><h4 id="使用情境"><a href="#使用情境" class="headerlink" title="# 使用情境"></a># 使用情境</h4><p>老實說，一定要使用 MutationObserver 的情況並不多，可能比較需要使用的情境會是：「專案中使用了第三方套件，為了觀測該套件所進行的一些 DOM 操作」，由於我們無法直接對第三方套件的程式碼進行修改，導致無法掌控 DOM 變動的程序，所以只能透過 MutationObserver 來追蹤。</p><p>但因為平常的 DOM 操作其實都是由我們主動執行的，所以真的需要在節點變動後做什麼事情就直接放在後面一起執行就好了，例如：</p><pre><code class="html">&lt;button onclick=&quot;changeContent()&quot;&gt;改變內容&lt;/button&gt;&lt;button onclick=&quot;changeColor()&quot;&gt;改變顏色&lt;/button&gt;&lt;div&gt;Hi I&#39;m Max&lt;/div&gt;&lt;script&gt;  const div = document.querySelector(&quot;div&quot;);  // 當 DOM 變動時我們想做的事情  function onDomMutation(info) &#123;    console.log(info);  &#125;  function changeContent() &#123;    const oldValue = div.textContent;    div.textContent = &quot;Hi I&#39;m Tom&quot;;    onDomMutation(&#123;      target: div,      oldValue,      type: &quot;characterData&quot;,    &#125;);  &#125;  function changeColor() &#123;    const oldValue = div.style;    div.style.color = &quot;red&quot;;    onDomMutation(&#123;      target: div,      oldValue,      type: &quot;attributes&quot;,    &#125;);  &#125;&lt;/script&gt;</code></pre><p><strong>其實透過上面這樣的寫法依然可以做到類似的效果，但我認為 MutationObserver 最主要的優點是「減少耦合」，就像之前介紹的 CustomEvent 一樣，透過「觀察者模式」的 Design Patterns 來讓原本是許多「一對一的依賴關係」整合成單個「一對多的依賴關係」。</strong></p><pre><code class="html">&lt;button onclick=&quot;changeContent()&quot;&gt;改變內容&lt;/button&gt;&lt;button onclick=&quot;changeColor()&quot;&gt;改變顏色&lt;/button&gt;&lt;div&gt;Hi I&#39;m Max&lt;/div&gt;&lt;script&gt;  const div = document.querySelector(&quot;div&quot;);  const observer = new MutationObserver(function (mutations) &#123;    mutations.forEach((record) =&gt; &#123;      console.log(record);    &#125;);  &#125;);  observer.observe(div, &#123;    childList: true,    attributes: true,    characterData: true,  &#125;);  function changeContent() &#123;    div.textContent = &quot;Hi I&#39;m Tom&quot;;  &#125;  function changeColor() &#123;    div.style.color = &quot;red&quot;;  &#125;&lt;/script&gt;</code></pre><p><br/><br/></p><p>不曉得經過這樣的解釋後，各位有沒有理解使用 MutationObserver 的好處呢？後面我們還會陸續介紹幾個也是採用「觀察者模式(Observer Pattern)」的 API，可以期待一下喔。另外有使用過 Vue 的朋友，你知道 <code>$nextTick</code> 其實就是基於 MutationObserver 實踐出來的喔，有興趣的人可以去看看<a href="https://github.com/vuejs/vue/blob/2.6/src/core/util/next-tick.js">原始碼</a>。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10277536">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;我的改變，你看得見！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在開發網頁過程中，我們最常做的事情就是對資料進行修改後運用在 DOM 元素上，像是新增 / 刪除節點、調整樣式、改寫內容或是屬性(attribute)的調整，而這些「修改 DOM」的動</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / RequestIdleCallback</title>
    <link href="https://maxleebk.com/2021/10/01/webApi/webApi-18/"/>
    <id>https://maxleebk.com/2021/10/01/webApi/webApi-18/</id>
    <published>2021-10-01T07:32:00.000Z</published>
    <updated>2023-10-23T03:50:24.560Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>時間管力大師就是要忙裡偷閒</p></blockquote><p>各位應該知道 JavaScript 是單執行緒(單線程)的程式語言，也就是一次只能處理一件事情。這樣的特性會使得事件的執行必定有個先後順序，這時候就會希望重要的事情能夠排序在前面，剩下比較不重要的任務等空閒時再處理即可，這時候就可以靠 RequestIdleCallback 來幫助我們。</p><hr><h2 id="RequestIdleCallback"><a href="#RequestIdleCallback" class="headerlink" title="RequestIdleCallback"></a>RequestIdleCallback</h2><p>RequestIdleCallback 會在瀏覽器「每一幀」中剩下的空閒裡來執行當中的 Callback。</p><br/><p>我們之前在介紹 RequestAnimationFrame 時有提過「幀數(FPS)」的概念，也就是「一秒鐘內能夠更新多少幀」，假如在一秒內能夠更新 60 幀，則 FPS 為 60，每一幀的時間約為 16.7 ms(毫秒)。</p><p>對於瀏覽器來說每一次「重繪(Repaint)」就是「一幀」，而這一幀要花多少時間就要看當下的網路或硬體狀況而定了。在這每一幀中，瀏覽器都有可能正在執行任務，若這個任務完成時，當下那一幀還沒結束時，就會有一個短暫的空閒時間。</p><blockquote><p>以 60FPS 為例，每一幀的空閒時間必定小於等於 16.7 ms。</p></blockquote><br/><p>而只要有這個空閒時間 RequestIdleCallback 就會去執行當中的 Callback，來完成那些我們覺得不重要的任務，換句話說，如果瀏覽器一直處於繁忙狀態的話，那該任務就會一直無法執行。</p><br/><h4 id="Window-requestIdleCallback"><a href="#Window-requestIdleCallback" class="headerlink" title="# Window.requestIdleCallback"></a># Window.requestIdleCallback</h4><p><code>requestIdleCallback</code> 有兩個參數要傳入：</p><ul><li>callback: 需要在空閒時間(Idle)執行的函示。</li><li>timeout: 這是一個可選參數，你可以設定一個時間來強制執行 <code>callback</code>，以避免瀏覽器因為持續繁忙的忽略(單位:毫秒)。</li></ul><blockquote><p>大部分情況不建議使用 <code>timeout</code>，因為會使用 <code>requestIdleCallback</code> 就代表不想影響主線程的任務進行 。</p></blockquote><pre><code class="javascript">const handlerId = requestIdleCallback(function () &#123;  //..做些不住要的事&#125;, 500);cancelIdleCallback(handlerId); // 取消requestIdleCallback</code></pre><p><br/><br/></p><h4 id="IdleDeadline"><a href="#IdleDeadline" class="headerlink" title="# IdleDeadline"></a># IdleDeadline</h4><p>而我們傳入的 Callback Function 會被丟進一個由 <code>requestIdleCallback</code> 提供的參數，該參數通常取名為 <code>deadline</code>，並且有兩個屬性可以使用：</p><ul><li>didTimeout: 這是一個唯讀屬性，以布林值來表示 Callback 是否是因為 <code>timeout</code> 被觸發的。</li><li>timeRemaining: 它是一個 method，執行後會傳傳一個毫秒數，用來表示當下這一幀的剩餘時間。</li></ul><pre><code class="javascript">requestIdleCallback(function (deadline) &#123;  // 如果你在 requestIdleCallback 中沒有傳入 timeout 參數，didTimeout 必定為 false  console.log(deadline.didTimeout);  console.log(deadline.timeRemaining());&#125;, 500);</code></pre><p><br/><br/></p><h4 id="實際測試"><a href="#實際測試" class="headerlink" title="# 實際測試"></a># 實際測試</h4><p>由於 JavaScript 是單執行緒，所以要是我今天進行了一個需要耗費大量時間的任務，那使用者的 UI 操作其實也會受到影響。<br>就像下面這個範例中，在 <code>count</code> 被函式 <code>add</code> 加到 1000000 以前，你不管怎麼敲擊鍵盤，<code>keydown</code> 事件都不會被觸發，因為瀏覽器正在忙著算數：</p><pre><code class="javascript">window.addEventListener(&quot;keydown&quot;, function () &#123;  console.log(&quot;Hey !!!!!!!!!&quot;);&#125;);let count = 0;add();function add() &#123;  if (count &lt; 10000) &#123;    console.log(count++);    add();  &#125;&#125;</code></pre><p>但是我們只要用 <code>requestIdleCallback</code> 來改寫一下，那狀況就不一樣了，因為這時候 <code>add</code> 這項任務的優先度會往後排，所以當我按下鍵盤時，瀏覽器會先處理 <code>keydown</code> 事件，等到閒置下來後才會繼續進行。</p><pre><code class="javascript">window.addEventListener(&quot;keydown&quot;, function () &#123;  console.log(&quot;Hey !!!!!!!!!&quot;);&#125;);let count = 0;requestIdleCallback(add);function add(deadline) &#123;  if (deadline.timeRemaining() &gt; 0) &#123;    if (count &lt; 10000) &#123;      console.log(count++);      requestIdleCallback(add);    &#125;  &#125;&#125;</code></pre><p><br/><br/></p><h4 id="使用情境"><a href="#使用情境" class="headerlink" title="# 使用情境"></a># 使用情境</h4><p>在了解 RequestIdleCallback 的效果後，我第一個想到的實際應用會是 LazyLoad，想像以下，如果我們有個網頁，當中有幾十甚至幾百張的高畫質圖片需要顯示，可想而知瀏覽器的負擔會相當的大，非常有可能會影響頁面的效能與任務執行，但如果們我利用 <code>requestIdleCallback</code> 來處理，就可以在不影響主執行緒的情況下載入圖片。</p><pre><code class="javascript">const images = [  &quot;https://img/001.png&quot;,  &quot;https://img/002.png&quot;,  //.....  &quot;https://img/099.png&quot;,  &quot;https://img/100.png&quot;,];requestIdleCallback(loadImage);function loadImage(deadline) &#123;  if (deadline.timeRemaining() &gt; 0) &#123;    if (images.length) &#123;      const imgSrc = images.shift();      const img = new Image(250, 150);      img.onload = document.body.appendChild(img);      img.src = imgSrc;      requestIdleCallback(loadImage);    &#125;  &#125;&#125;</code></pre><p><br/><br/></p><p>不曉得使用過 React 的朋友有沒有了解過 React Fiber 呢？其實它的原理就和 RequestIdleCallback 一樣，將大量沒那麼優先的工作拆成許多小片段，在瑣碎的時間裡慢慢完成，也因為這樣的機制，使得我們可以去中斷它，將一些突發的重要任務(例如使用者的 UI 事件)插在這些小片段中，宛如有另一條執行緒一般。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10276904">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;時間管力大師就是要忙裡偷閒&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;各位應該知道 JavaScript 是單執行緒(單線程)的程式語言，也就是一次只能處理一件事情。這樣的特性會使得事件的執行必定有個先後順序，這時候就會希望重要的事情能夠排序在前面</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / BroadcastChannel</title>
    <link href="https://maxleebk.com/2021/09/30/webApi/webApi-17/"/>
    <id>https://maxleebk.com/2021/09/30/webApi/webApi-17/</id>
    <published>2021-09-30T14:32:00.000Z</published>
    <updated>2023-10-23T03:50:24.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>里長辦公室廣播：張君雅小妹妹，恁兜欸泡麵已經煮好了！</p></blockquote><p>前兩天已經認識了 PostMessage 和建立專屬頻道的 MessageChannel，它們都是進行點對點的溝通，但如果想要一次跟多個頁面溝通時怎麼辦了，這時 BroadcastChannel 就能派上用場了。</p><hr><h2 id="BroadcastChannel"><a href="#BroadcastChannel" class="headerlink" title="BroadcastChannel"></a>BroadcastChannel</h2><p>BroadcastChannel 就如同一個無線對講機系統，訊息是播放在一個廣播頻道中，任何頁面只要取得頻道的頻率就可以在無線電中發送／接收訊息。</p><br/><h4 id="建立頻道"><a href="#建立頻道" class="headerlink" title="# 建立頻道"></a># 建立頻道</h4><p>和 <code>MessageChannel</code> 一樣，<code>BroadcastChannel</code> 本身也是一個 <code>Class</code>，只要透過關鍵字 <code>new</code> 就能建立一個廣播頻道，不過這次我們要傳入一個字串來當作廣播頻道的名稱，未來其他頁面才能藉由同樣的字串來進入頻道。</p><pre><code class="javascript">const channel = new BroadcastChannel(&quot;max_channel&quot;);</code></pre><p>接著只要透過我們建立的廣播頻道送出訊息即可：</p><pre><code class="javascript">const channel = new BroadcastChannel(&quot;max_channel&quot;);channel.postMessage(&quot;你已成功加入頻道!&quot;, location.origin);</code></pre><p>要收到訊息的話就用 BroadcastChannel 監聽 <code>message</code> 即可：</p><pre><code class="javascript">const channel = new BroadcastChannel(&quot;max_channel&quot;);channel.onmessage = function (event) &#123;  console.log(event.data);&#125;;</code></pre><p><br/><br/></p><h4 id="頻道溝通"><a href="#頻道溝通" class="headerlink" title="# 頻道溝通"></a># 頻道溝通</h4><p>這時候其他頁面只要使用同樣的頻道名稱建立一個 BroadcastChannel，並且一樣透過該頻道來傳送／接收訊息，這樣所有頻道中的頁面就都可以相互溝通了。</p><pre><code class="html">&lt;!-- 這裡是 main.html --&gt;&lt;button onclick=&quot;sendMessage()&quot;&gt;send message&lt;/button&gt;&lt;iframe src=&quot;pageA.html&quot; width=&quot;480&quot; height=&quot;120&quot;&gt;&lt;/iframe&gt;&lt;iframe src=&quot;pageB.html&quot; width=&quot;480&quot; height=&quot;120&quot;&gt;&lt;/iframe&gt;&lt;script&gt;  const channel = new BroadcastChannel(&quot;max_channel&quot;);  channel.onmessage = function (event) &#123;    console.log(event.data);  &#125;;  function sendMessage() &#123;    channel.postMessage(&quot;你已成功加入頻道!&quot;, location.origin);  &#125;&lt;/script&gt;</code></pre><pre><code class="html">&lt;!-- 這裡是 pageA.html --&gt;&lt;button onclick=&quot;sendMessage()&quot;&gt;send message&lt;/button&gt;&lt;div class=&quot;output&quot;&gt;pageA content&lt;/div&gt;&lt;script&gt;  const output = document.querySelector(&quot;.output&quot;);  const channel = new BroadcastChannel(&quot;max_channel&quot;);  channel.onmessage = function (event) &#123;    const output = document.querySelector(&quot;.output&quot;);    output.innerHTML = event.data;  &#125;;  function sendMessage() &#123;    channel.postMessage(&quot;pageA 發送訊息！&quot;, location.origin);  &#125;&lt;/script&gt;</code></pre><pre><code class="html">&lt;!-- 這裡是 pageB.html --&gt;&lt;button onclick=&quot;sendMessage()&quot;&gt;send message&lt;/button&gt;&lt;div class=&quot;output&quot;&gt;pageB content&lt;/div&gt;&lt;script&gt;  const channel = new BroadcastChannel(&quot;max_channel&quot;);  channel.onmessage = function (event) &#123;    const output = document.querySelector(&quot;.output&quot;);    output.innerHTML = event.data;  &#125;;  function sendMessage() &#123;    channel.postMessage(&quot;pageB 發送訊息！&quot;, location.origin);  &#125;&lt;/script&gt;</code></pre><img src="broadcast.gif" style="margin: 24px auto;" /><p><br/><br/></p><h4 id="頻道名稱"><a href="#頻道名稱" class="headerlink" title="# 頻道名稱"></a># 頻道名稱</h4><p>不過上面這樣的範例，會有一個令人詬病的地方，就是「頻道名稱」的同步問題，要是有其中某個頁面打錯頻道名稱，那就會連不上頻道。或是如果想要更換頻道名稱的時候，就必須大家一起改，似乎是又點不太方便。</p><p>所以在主頁面建立頻道後，其實可以先用一般的 <code>postMessage</code> 將頻道名稱傳給需要的頁面：</p><pre><code class="html">&lt;iframe src=&quot;pageA.html&quot; width=&quot;480&quot; height=&quot;120&quot;&gt;&lt;/iframe&gt;&lt;iframe src=&quot;pageB.html&quot; width=&quot;480&quot; height=&quot;120&quot;&gt;&lt;/iframe&gt;&lt;script&gt;  const allIframe = document.querySelectorAll(&quot;iframe&quot;);  const channel = new BroadcastChannel(&quot;max_channel&quot;);  // 發送頻道名稱  allIframe.forEach((iframe) =&gt; &#123;    iframe.addEventListener(&quot;load&quot;, function () &#123;      this.contentWindow.postMessage(channel.name, location.origin);    &#125;);  &#125;);  channel.onmessage = function (event) &#123;    console.log(event.data);  &#125;;&lt;/script&gt;</code></pre><pre><code class="html">&lt;!-- 這裡是 pageA.html --&gt;&lt;div class=&quot;output&quot;&gt;pageA content&lt;/div&gt;&lt;script&gt;  let channel;  window.addEventListener(&quot;message&quot;, function (event) &#123;    if (event.origin !== location.origin) return;    channel = new BroadcastChannel(event.data);    channel.onmessage = function (bc_event) &#123;      const output = document.querySelector(&quot;.output&quot;);      output.innerHTML = event.data;    &#125;;    channel.postMessage(&quot;pageA 加入頻道&quot;, location.origin);  &#125;);&lt;/script&gt;</code></pre><pre><code class="html">&lt;!-- 這裡是 pageB.html --&gt;&lt;div class=&quot;output&quot;&gt;pageB content&lt;/div&gt;&lt;script&gt;  let channel;  window.addEventListener(&quot;message&quot;, function (event) &#123;    if (event.origin !== location.origin) return;    channel = new BroadcastChannel(event.data);    channel.onmessage = function (bc_event) &#123;      const output = document.querySelector(&quot;.output&quot;);      output.innerHTML = event.data;    &#125;;    channel.postMessage(&quot;pageB 加入頻道&quot;, location.origin);  &#125;);&lt;/script&gt;</code></pre><blockquote><p>補充：如果有頁面想要與廣播頻道斷開連結的話，只要拿建立的頻道執行 <code>close()</code> 即可，關閉後頻道還是存在，只是該頁面不再接收頻道的訊息。</p></blockquote><p><br/><br/></p><p>這三天我們已經完全認識了 PostMessage，了解到它不但可以傳送訊息，還可以建立私訊或群組的通訊模式，而這項技術其實時常會用在 <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/Web_Workers_API/Using_web_workers">Web Worker</a> 中，但因為它的範疇有點龐大，所以這次的系列文章不會介紹到，有興趣的朋友可以再自行研究～</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10276437">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;里長辦公室廣播：張君雅小妹妹，恁兜欸泡麵已經煮好了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前兩天已經認識了 PostMessage 和建立專屬頻道的 MessageChannel，它們都是進行點對點的溝通，但如果想要一次跟多個頁面溝通時怎麼辦</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / MessageChannel</title>
    <link href="https://maxleebk.com/2021/09/29/webApi/webApi-16/"/>
    <id>https://maxleebk.com/2021/09/29/webApi/webApi-16/</id>
    <published>2021-09-29T09:15:00.000Z</published>
    <updated>2023-10-23T03:50:24.540Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>熱線你和我，這是一條情感的線路，屬於你和我。</p></blockquote><p>昨天我們認識了 PostMessage，它可以讓我們在兩個頁面之間傳遞訊息，只要有地址(Domain Origin)，就可以送信給對方，而對方只要有收信的機制就能夠獲得訊息，甚至可以回信。但這有個壞處，也就是當我們建立了收信機制後，可能會有來自四面八方的訊息寄過來，那就必須要做一個過濾的動作。但今天的 MessageChannel 卻可以解決這個問題。</p><p><strong>有些 Package 或 Library 有可能會使用 PostMessage 在你的網頁文件中執行訊息傳遞，這些訊息也是需要過濾的。</strong></p><hr><h2 id="MessageChannel"><a href="#MessageChannel" class="headerlink" title="MessageChannel"></a>MessageChannel</h2><p>MessageChannel 就像是在兩個頁面中建立一個熱線系統，這樣就不會再那些不想收到訊息，只有綁定的雙方可以透過 MessageChannel 來進行溝通，就像是一個專屬的頻道。如果以圖像來表示整個頻道建立的過程的話，會像是下圖這樣：</p><img src="channel.png" style="margin: 24px auto;" /><br/><h4 id="建立頻道"><a href="#建立頻道" class="headerlink" title="# 建立頻道"></a># 建立頻道</h4><p>先來看第一步「建立頻道」，<code>MessageChannel</code> 本身是一個 <code>Class</code>，所以我們用關鍵字 <code>new</code> 來創建一個新的 MessageChannel 物件，就這麼簡單明瞭，而且也不需要傳入任何參數。</p><pre><code class="javascript">const msgChannel = new MessageChannel();</code></pre><p>而當 MessageChannel 建立後，它底下就會有兩個唯讀屬性可以取得，分別是 <code>port1</code> 和 <code>port2</code>，也就是圖片中的兩部手機：</p><pre><code class="javascript">console.log(msgChannel.port1);console.log(msgChannel.port2);</code></pre><p><br/><br/></p><h4 id="交付權限"><a href="#交付權限" class="headerlink" title="# 交付權限"></a># 交付權限</h4><p>在建立頻道之後，目前兩部手機(Port)都還是由目前的頁面所掌控，我們需要將其中一部手機(Port)傳遞給我們想建立通訊的另一個頁面中。</p><pre><code class="html">&lt;!-- 這裡是 pageA.html --&gt;&lt;iframe src=&quot;pageB.html&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/iframe&gt;&lt;script&gt;  let messagePort;  const iframe = document.querySelector(&quot;iframe&quot;);  iframe.addEventListener(&quot;load&quot;, function () &#123;    // 建立頻道，並取得 port1、port2    const &#123; port1, port2 &#125; = new MessageChannel();    // 將 port1 存在全域變數中    messagePort = port1;    // 將 port2 送給 pageB    const msg = &quot;這是 pageA 送來的手機&quot;;    iframe.contentWindow.postMessage(msg, location.origin, [port2]);  &#125;);&lt;/script&gt;</code></pre><p>雖然已經建立了 MessageChannel，但「送手機」的這一步還是要靠一般的方式送過去，而手機(Port)的部分必須放在之前介紹 <code>postMessage</code> 時沒說的第三個參數中：</p><ul><li>transfer： 這個參數必須是一個陣列，當中要放的是由 MessageChannel 所產生的 <code>port</code>，藉此產生兩個頁面的訊息通道。</li></ul><br/><p>再來，pageA 還需要先做好準備，才不會漏接了 pageB 傳過來的訊息，也就是要監聽 <code>message</code> 事件，但是這次不再是用 <code>window</code> 監聽了，而是使用 <code>port1.onmessage</code>:</p><pre><code class="html">&lt;!-- 這裡是 pageA.html --&gt;&lt;iframe src=&quot;pageB.html&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/iframe&gt;&lt;script&gt;  let messagePort;  const iframe = document.querySelector(&quot;iframe&quot;);  iframe.addEventListener(&quot;load&quot;, function () &#123;    const &#123; port1, port2 &#125; = new MessageChannel();    messagePort = port1;    // 用 port1 監聽 message 事件    messagePort.onmessage = function (event) &#123;      console.log(event.data);    &#125;;    const msg = &quot;這是 pageA 送來的手機&quot;;    iframe.contentWindow.postMessage(msg, location.origin, [port2]);  &#125;);&lt;/script&gt;</code></pre><br/><p>再來就是要在 pageB 接收這個「寄送手機」的信息，只要在傳送端有在 <code>postMessage</code> 放入 <code>transfer</code> 這個參數，接收端就可以在 Event 物件中的 <code>ports</code> 屬性取得「這部手機」。</p><p>在收到這部手機(Port)後，我們可以先存起來，然後為它建立事件，以便未來在頻道中收到 pageA 時才會對應的操作。除此之外，我們還可以順勢用這部手機馬上打回去，跟 pageA 說我們已經拿到手機(Port)了。</p><pre><code class="html">&lt;!-- 這裡是 pageB.html --&gt;&lt;div class=&quot;output&quot;&gt;default content&lt;/div&gt;&lt;script&gt;  let messagePort;  const output = document.querySelector(&quot;.output&quot;);  window.addEventListener(&quot;message&quot;, function (event) &#123;    if (!event.ports || !event.ports.length) return;    // 將訊息文字顯示在頁面上    output.innerHTML = event.data;    // 將 port2 存在全域變數中    messagePort = event.ports[0];    // 用 port2 監聽 message 事件    messagePort.onmessage = function (port_event) &#123;      output.innerHTML = port_event.data;    &#125;;    // 用 port2 送出訊息    messagePort.postMessage(&quot;收到手機囉！&quot;);  &#125;);&lt;/script&gt;</code></pre><img src="post.gif" style="margin: 24px auto;" /><p><br/><br/></p><h4 id="頻道溝通"><a href="#頻道溝通" class="headerlink" title="# 頻道溝通"></a># 頻道溝通</h4><p>前面我們已經把前置作業全部都完善了，包括建立頻道、傳送埠口(Port)、事件監聽，接下來我們就可以享受信息暢通的專屬熱線了：</p><pre><code class="html">&lt;!-- 這裡是 pageA.html --&gt;&lt;button onclick=&quot;sendMessage()&quot;&gt;send message&lt;/button&gt;&lt;iframe src=&quot;pageB.html&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/iframe&gt;&lt;script&gt;  let messagePort;  // ... 省略其他 code  function sendMessage() &#123;    messagePort.postMessage(&quot;來自 pageA 的訊息&quot;);  &#125;&lt;/script&gt;</code></pre><pre><code class="html">&lt;!-- 這裡是 pageB.html --&gt;&lt;button onclick=&quot;sendMessage()&quot;&gt;send message&lt;/button&gt;&lt;div class=&quot;output&quot;&gt;default content&lt;/div&gt;&lt;script&gt;  let messagePort;  // ... 省略其他 code  function sendMessage() &#123;    messagePort.postMessage(&quot;來自 pageB 的訊息&quot;);  &#125;&lt;/script&gt;</code></pre><img src="post2.gif" style="margin: 24px auto;" /><p><br/><br/></p><p>是不是對 PostMessage 又有新的一層認識呢？但你以為就只有這樣嗎？其實明天還會介紹 BroadcastChannel，除了可以建立專屬熱線之外，還可以建立廣播系統！</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10276002">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;熱線你和我，這是一條情感的線路，屬於你和我。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;昨天我們認識了 PostMessage，它可以讓我們在兩個頁面之間傳遞訊息，只要有地址(Domain Origin)，就可以送信給對方，而對方只要有收信的機制就</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / PostMessage</title>
    <link href="https://maxleebk.com/2021/09/28/webApi/webApi-15/"/>
    <id>https://maxleebk.com/2021/09/28/webApi/webApi-15/</id>
    <published>2021-09-28T09:15:00.000Z</published>
    <updated>2023-10-23T03:50:24.540Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>親像愛情的限時批～</p></blockquote><p>各位有想過該如何跟其他頁面進行溝通嗎？如果在Ａ頁面點擊了一個按鈕，能不能夠讓Ｂ頁面發生變化或執行動作呢？別說不可能，今天要介紹的 PostMessage 便能夠達成這樣的效果。</p><hr><h2 id="PostMessage"><a href="#PostMessage" class="headerlink" title="PostMessage"></a>PostMessage</h2><p>一般來說，不同的頁面要相互溝通的話，它們的 Domain 必須相同，然後通常就會使用 LocalStorage 搭配 <code>storage</code> 事件來進行溝通，但 PostMessage 神奇的地方就在於它可以越過這項限制，讓我們甚至可以跟不同源的網站頁面進行溝通，這樣就能解決前端最討厭的 CORS 問題了。</p><blockquote><p>雖然 PostMessage 可以跨域溝通，不過當然也要對方願意且有撰寫對應的機制程式碼，要不然世界就大亂了 XD</p></blockquote><p><br/><br/></p><h4 id="otherWindow-postMessage"><a href="#otherWindow-postMessage" class="headerlink" title="# otherWindow.postMessage"></a># otherWindow.postMessage</h4><p>PostMessage API 底下就是只有 <code>postMessage</code> 這個 method，非常的單純，卻也無比強大，其中 <code>otherWindow</code> 所指的是「目前分頁以外的 Window」，這個 Window 可以是利用 <code>window.open</code> 執行返回的 Window 物件，或是一個 <code>iframe</code> 元素的 <code>contentWindow</code>，而也就是訊息要送達的目的地。</p><p>另外 <code>postMessage</code> 還必須傳入兩個參數：</p><ul><li>message: 第一個是你要傳送的訊息，任何型別格式都可以接受。</li><li>targetOrigin: 第二個則是設定「能夠接收本次訊息」的網頁 Origin，必須要是在這個 Domain 底下的頁面才能接收到訊息。</li></ul><pre><code class="javascript">const url = &quot;https://maxleebk.com//2021/09/28/webApi/webApi-15/&quot;;const otherPage = window.open(url);otherPage.postMessage(&quot;Hi,Max&quot;, &quot;https://maxleebk.com/&quot;);</code></pre><p>以上面的例子來說，我們先利用 <code>window.open</code> 打開了一個作者本人的部落格分頁，而該分頁的 Window 已經被儲存在 <code>otherPage</code> 中，再來我們就利用 <code>postMessage</code> 傳遞一個字傳，並且利用 <code>targetOrigin</code> 來確保一定要是 <code>https://maxleebk.com/</code> 底下的頁面才能真正接受到訊息。</p><blockquote><p>你該注意：<code>targetOrigin</code> 這個參數建議一定要傳入並填妥，不然訊息有可能會被刻意攔截，導致無法預期的安全性問題。</p></blockquote><p><br/><br/></p><h4 id="Window-message-Event"><a href="#Window-message-Event" class="headerlink" title="# Window:message Event"></a># Window:message Event</h4><p>訊息有傳送的一方，自然也要有接收的一方，而接收方要順利接到訊息的話，只要在 <code>window</code> 上監聽 <code>message</code> 這個事件即可，而訊息的部分則會被放在 Event 物件的 <code>data</code> 屬性裡:</p><pre><code class="javascript">addEventListener(&quot;message&quot;, function (event) &#123;  console.log(event.data);&#125;);</code></pre><p>所以只要你想傳送的網站中，有打開一個這樣的通道，那你就可以透過 PostMessage 來與之溝通，不過接收方也不可能所有的訊息都照單全收，要是我們今天身為接收方，那應該要像下方這樣做一些防禦。</p><p>在 Event 物件中還有一個 <code>origin</code> 屬性，可以用來獲取傳送方的來源，所以我們可以利用它來過濾那些不在信任範圍的網址：</p><pre><code class="javascript">addEventListener(&quot;message&quot;, function (event) &#123;  // 如果訊息不是來自於 IT邦幫忙 那就不執行任何動作  if (event.origin !== &quot;https://ithelp.ithome.com.tw&quot;) return;  console.log(event.data);&#125;);</code></pre><p>當然了，信息往來總不能只有單向，如果接收方要回信的話，只要利用 Event 物件中的 <code>source</code> 屬性就可以進行訊息的傳送：</p><pre><code class="javascript">addEventListener(&quot;message&quot;, function (event) &#123;  if (event.origin !== &quot;https://ithelp.ithome.com.tw&quot;) return;  console.log(event.data);  event.source.postMessage(&quot;hi,IT邦幫忙&quot;, event.origin);&#125;);</code></pre><p>透過 PostMessage 訊息的相互傳遞，我們就可以不受同源政策的限制，向其他網域的網頁請求資料了，或利用訊息的格式判定來執行其他頁面的動作等等…</p><pre><code class="javascript">addEventListener(&quot;message&quot;, function (event) &#123;  axios.get(&quot;/user&quot;, event.data.id).then((res) =&gt; &#123;    event.source.postMessage(res, event.origin);  &#125;);&#125;);addEventListener(&quot;message&quot;, function (event) &#123;  window[event.data.method](); // 執行指定名稱的全域函式&#125;);</code></pre><p><br/><br/></p><p>PostMessage API 是不是非常有趣又神奇呢？或許要遇到頁面溝通的情境並不多，但千萬忽略了它，等到遇到了，它會是非常強大的幫手，而且應用起來也相當簡單，大家如果有興趣，隨手就能寫個簡單的範例。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10275491">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;親像愛情的限時批～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;各位有想過該如何跟其他頁面進行溝通嗎？如果在Ａ頁面點擊了一個按鈕，能不能夠讓Ｂ頁面發生變化或執行動作呢？別說不可能，今天要介紹的 PostMessage 便能夠達成這樣的效果。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / CustomEvent</title>
    <link href="https://maxleebk.com/2021/09/27/webApi/webApi-14/"/>
    <id>https://maxleebk.com/2021/09/27/webApi/webApi-14/</id>
    <published>2021-09-27T13:03:00.000Z</published>
    <updated>2023-10-23T03:50:24.540Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自己的事件自己決定。</p></blockquote><p>網頁最重要的兩件事，資訊顯示與使用者交互，而使用者交互在頁面中所代表的行為就是「監聽事件」與「觸發事件」，相信這是大家在熟悉不過的了，<code>click</code>、<code>input</code>、<code>blur</code>、<code>scroll</code>…等等，幾乎充斥在我們的網站中，但除了這些常見的、預設的事件之外，其實我們也可以自己創造出全新的事件。</p><hr><h4 id="Window-CustomEvent"><a href="#Window-CustomEvent" class="headerlink" title="# Window.CustomEvent"></a># Window.CustomEvent</h4><p>CustomEvent 本身是一個建構函式，也就是我們常講的 <code>class</code>，當我們想要建立自訂事件時，就透過 <code>new</code> 關鍵字來呼叫它即可，並且要記得傳入代表事件名稱的字串，另外還可以傳入第二個參數來設定事件觸發時傳遞的資料。</p><p>要注意的是，用來設定資料的第二個物件必須要是一個物件，且要傳遞的資料必須設定在該物件的 <code>detail</code> 屬性底下。</p><pre><code class="javascript">const customEvent = new CustomEvent(&quot;myEvent&quot;, &#123;  detail: &#123; customData: &quot;maxLee&quot; &#125;,&#125;);</code></pre><p>而當有 DOM 元素需要綁定這個事件時，一樣使用 <code>addEventListener</code> 來處理即可，而其中事件 Callback 會拿到的 Event 物件就會多一個 <code>detail</code> 的屬性，該屬性就會是我們當初設定的事件傳遞資料。</p><pre><code class="javascript">const customEvent = new CustomEvent(&quot;myEvent&quot;, &#123;  detail: &#123; customData: &quot;maxLee&quot; &#125;,&#125;);document.querySelector(&quot;#element&quot;).addEventListener(&quot;myEvent&quot;, function (event) &#123;  console.log(event.detail); // &#123; customData: &quot;maxLee&quot; &#125;&#125;);</code></pre><p><br/><br/></p><h4 id="EventTarget-dispatchEvent"><a href="#EventTarget-dispatchEvent" class="headerlink" title="# EventTarget.dispatchEvent"></a># EventTarget.dispatchEvent</h4><p>與 CustomEvent 最極其相關的 API 就是 DispatchEvent 了，它是一個可以讓我們主動觸發事件的方法，當我們創建並綁定了一個事件後，就必須要倚靠它來幫我們啟動事件了。</p><p>其中 EventTarget 是一個代稱，它所指的是綁定事件的 DOM 對象，例如以下程式碼中，<code>div</code> 就是 EventTarget：</p><pre><code class="javascript">const customEvent = new CustomEvent(&quot;myEvent&quot;, &#123;  detail: &#123; customData: &quot;maxLee&quot; &#125;,&#125;);const div = document.querySelector(&quot;div&quot;);div.addEventListener(&quot;myEvent&quot;, function (e) &#123;  console.log(event.detail);&#125;);</code></pre><p>此時上面的 <code>div</code> 已經被綁上了我們自訂的 <code>myEvent</code> 事件，這時候我們就可以使用 <code>dispatchEvent</code> 來主動觸發事件，只要在呼叫它時傳入 CustomEvent 物件即可：</p><pre><code class="javascript">const customEvent = new CustomEvent(&quot;myEvent&quot;, &#123;  detail: &#123; customData: &quot;maxLee&quot; &#125;,&#125;);const div = document.querySelector(&quot;div&quot;);div.addEventListener(&quot;myEvent&quot;, function (e) &#123;  console.log(event.detail);&#125;);div.dispatchEvent(customEvent);</code></pre><p><br/><br/></p><h4 id="運用場景"><a href="#運用場景" class="headerlink" title="# 運用場景"></a># 運用場景</h4><p>認識了 CustomEvent 後，我們來假設一個需求：<strong><em>「今天有個頁面，在進入時會向後端 request 資料，當資料回來後，我們要更改頁面的標題及一個 list 的內容」</em></strong>，當然了，如果使用前端框架的話，這是一個非常簡單的事情，但我們先假如這次專案不允許使用框架，那一般的寫法可能會是這樣：</p><pre><code class="javascript">function updateTitle(title) &#123;  const title = document.querySelector(&quot;h1&quot;);  title.textContent = title;&#125;function updateList(list) &#123;  const ul = document.querySelector(&quot;ul&quot;);  ul.innerHtml = &quot;&quot;;  list.forEach((item) =&gt; &#123;    const li = document.createElement(&quot;li&quot;);    li.textContent = item;    ul.appendChild(li);  &#125;);&#125;function onDataFetch(res) &#123;  updateTitle(res.data.title);  updateList(res.data.list);&#125;// 如果不認識 axios，可以把它當成一個請求資料的 Promise 即可axios.get(&quot;https://backend/data&quot;).then(onDataFetch);</code></pre><p>以上這樣的寫法其實已經算是盡量避免耦合了，因為還額外包裝了一支 <code>onDataFetch</code> 函式來獨立處理取得資料後的事情，但如果未來還有其他的事情要處理，就必須再加進這個函式中，而且其他人在閱讀時，可能會誤以為裡面執行內容可能有順序性。那接下來我們看看使用 CustomEvent 可以怎麼寫：</p><pre><code class="javascript">let dataFetchEventTarget = [];function addDataFetchEvent(element, callback) &#123;  dataFetchEventTarget.push(element);  element.addEventListener(&quot;dataFetch&quot;, callback);&#125;addDataFetchEvent(document.querySelector(&quot;h1&quot;), function (e) &#123;  this.textContent = e.detail.title;&#125;);addDataFetchEvent(document.querySelector(&quot;ul&quot;), function (e) &#123;  this.innerHtml = &quot;&quot;;  e.detail.list.forEach((item) =&gt; &#123;    const li = document.createElement(&quot;li&quot;);    li.textContent = item;    this.appendChild(li);  &#125;);&#125;);// 用 setTimeout 來模擬請求資料setTimeout(() =&gt; &#123;  const dataFetchEvent = new CustomEvent(&quot;dataFetch&quot;, &#123;    detail: res.data,  &#125;);  dataFetchEventTarget.forEach((target) =&gt; &#123;    target.dispatchEvent(dataFetchEvent);  &#125;);&#125;, 3000);</code></pre><p>首先我們先宣告了一個陣列 <code>dataFetchEventTarget</code>，打算來存放所有有註冊事件的元素，然後寫了一個函式 <code>addDataFetchEvent</code> 來註冊事件，並且同時將元素丟進陣列中，直到我們將資料請求回來後開始建立自訂事件，並且把 <code>dataFetchEventTarget</code> 中的元素一一取出並 <code>dispatchEvent</code> 事件。</p><p>這樣寫法的好處在於，「取得資料」跟「後續行為」完全沒有耦合，「註冊事件」與「觸發事件」完全是獨立的兩件事，所以未來如果有其他地方註冊了這個事件，我們也不需要額外處理任何事，等到事件觸發了，Callback 自然會去執行。</p><p><br/><br/></p><p>一般來說，沒有特別去設計的話，大家都會使用第一種方式吧？但其實使用 CustomEvent 的話，會很接近 Design Patterns 中的觀察者模式(Observer Pattern)，其實是一個非常不錯的撰寫方式，大家可以在未來的開發中嘗試看看。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10274924">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;自己的事件自己決定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;網頁最重要的兩件事，資訊顯示與使用者交互，而使用者交互在頁面中所代表的行為就是「監聽事件」與「觸發事件」，相信這是大家在熟悉不過的了，&lt;code&gt;click&lt;/code&gt;、&lt;code&gt;</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / SessionStorage</title>
    <link href="https://maxleebk.com/2021/09/26/webApi/webApi-13/"/>
    <id>https://maxleebk.com/2021/09/26/webApi/webApi-13/</id>
    <published>2021-09-26T09:33:00.000Z</published>
    <updated>2023-10-23T03:50:24.536Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>狡兔有三窟，儲存用戶端的資料當然也要有三個。</p></blockquote><p>相信大家應該都有遇過需要將資料儲存在用戶端的需求，像是將後端的 SessionID 儲存在 Cookie，或是將一些靜態資料存在 LocalStorage，但今天想要分享的是一個大家比較少選擇的 API - SessionStorage。</p><hr><h2 id="Cookie-amp-LocalStorage"><a href="#Cookie-amp-LocalStorage" class="headerlink" title="Cookie &amp; LocalStorage"></a>Cookie &amp; LocalStorage</h2><p>在介紹 SessionStorage 之前，我們先來複習一下 Cookie 和 LocalStorage 的一些特性，這樣之後如果遇到類似情境就可以依照需求選擇更適合的 API。</p><br/><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="# Cookie"></a># Cookie</h4><ul><li>每筆可儲存的資料大小約為 4KB</li><li>有時效的限制，到期後就會自動刪除</li><li>每次進行 http request 時所有 cookie 會一併送出</li><li>有同源政策，無法讀取其他網站設定的 cookie</li><li>明碼儲存，不適合儲存機敏性資料</li></ul><blockquote><p>根據上面的特性，我們就知道 Cookie 比較適合儲存小量、以時效性的資料，而且也因為每次發送請求時都會送出，所以才會被拿來儲存 SessionID，以供後端進行驗證。</p></blockquote><p><br/><br/></p><h4 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="# LocalStorage"></a># LocalStorage</h4><ul><li>每筆可儲存的資料大小約為 5MB</li><li>沒有時效限制，除非使用者手動刪除，不然會一直存在</li><li>進行 http request 時並不會送出</li><li>有同源政策，無法讀取其他網站設定的 localStorage</li><li>明碼儲存，不適合儲存機敏性資料</li></ul><blockquote><p>跟 Cookie 比較不同，LocalStorage 就可以存一些比較大型、長期性的資料，常常會被拿來當作用戶端的快取，以減少 fetch 資料的次數。</p></blockquote><p><br/><br/></p><h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><p>SessionStorage 則是跟 LocalStorage 幾乎一樣，且存放大小也是 5MB，最大的不同點在於，它會受到分頁的限制，也就是說就算兩個分頁都處在同一個網站中，它們的 SessionStorage 也不會共用，且只要把分頁關掉也同時會把 SessionStorage 給刪除。</p><br/><p>SessionStorage 這樣的特性其實就有一個很實用的情境，那就是表單內容的儲存，在網頁中時常會有表單需要用戶填寫，例如基本資料、訂單資料、意見調查等等，但如果使用者在填寫過程中不慎離開頁面或是重新整理，那可就功虧一簣了。</p><p>這時候 SessionStorage 就可以派上用場，把使用者填到一半的內容給儲存起來，只要使用者不是關掉分頁，離開再回來都可以保留填寫進度。而且就算使用者開了好幾個分頁進行不同訂單的填寫，分頁間的 SessionStorage 資料也不會相互干擾。</p><br/><h4 id="SessionStorage-setItem"><a href="#SessionStorage-setItem" class="headerlink" title="# SessionStorage.setItem"></a># SessionStorage.setItem</h4><p>SessionStorage 就連 methods 也都和 LocalStorage 是一樣的，<code>setItem</code> 可以讓我們下增/修改一筆 SessionStorage：</p><pre><code class="javascript">sessionStorage.setItem(&quot;key&quot;, &quot;value&quot;);// 如果想要儲存物件、陣列等複雜型別，可以先進行字串化sessionStorage.setItem(&quot;object&quot;, JSON.stringify(&#123; key: &quot;value&quot; &#125;));</code></pre><br/><h4 id="SessionStorage-getItem"><a href="#SessionStorage-getItem" class="headerlink" title="# SessionStorage.getItem"></a># SessionStorage.getItem</h4><p><code>getItem</code> 則是可以幫我們讀取 SessionStorage 中的某筆資料：</p><pre><code class="javascript">const data = sessionStorage.getItem(&quot;object&quot;);console.log(JSON.parse(data));</code></pre><br/><h4 id="SessionStorage-removeItem"><a href="#SessionStorage-removeItem" class="headerlink" title="# SessionStorage.removeItem"></a># SessionStorage.removeItem</h4><p><code>removeItem</code> 則是刪除某筆資料：</p><pre><code class="javascript">const data = sessionStorage.removeItem(&quot;object&quot;);</code></pre><br/><h4 id="SessionStorage-clear"><a href="#SessionStorage-clear" class="headerlink" title="# SessionStorage.clear"></a># SessionStorage.clear</h4><p>而 <code>clear</code> 會將 SessionStorage 中的所有資料都清除：</p><pre><code class="javascript">sessionStorage.clear();</code></pre><p><br/><br/></p><p>不曉得今天認識了 SessionStorage 之後，各位有沒有靈光一閃，突然覺得之前某些資料其實可以存在 SessionStorage 就好了呢？之後如果再有這種要在用戶端儲存資料的需求，大家就可以再多思考一下，選出符合情境的 Storage API 囉。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10274151">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;狡兔有三窟，儲存用戶端的資料當然也要有三個。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相信大家應該都有遇過需要將資料儲存在用戶端的需求，像是將後端的 SessionID 儲存在 Cookie，或是將一些靜態資料存在 LocalStorage，但今</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / History</title>
    <link href="https://maxleebk.com/2021/09/25/webApi/webApi-12/"/>
    <id>https://maxleebk.com/2021/09/25/webApi/webApi-12/</id>
    <published>2021-09-25T12:33:00.000Z</published>
    <updated>2023-10-23T03:50:24.536Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>歷史是現在與過去之間永無休止的對話。</p></blockquote><p>我們都知道瀏覽器提供了上一頁、下一頁，甚至可以讓你回到前兩頁、前三頁…，但其實我們也可以借助 History API 的力量，在網頁中自己實踐這樣的功能。</p><hr><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><p>History 是一個瀏覽器提供的歷史紀錄操作介面，你可以透過 <code>window.history</code> 來取得該物件，當中有一些屬性跟方法可以獲取來使用，下面我們就一一來認識一下。</p><br/><h4 id="History-length"><a href="#History-length" class="headerlink" title="# History.length"></a># History.length</h4><p><code>length</code> 是一個唯讀屬性，可以取得目前瀏覽器分頁的歷史紀錄總數，當你開啟一個新分頁時，它會是 <code>1</code>，而每當你瀏覽一個新的網址，它便會不斷增加。</p><pre><code class="javascript">console.log(history.length);</code></pre><p><br/><br/></p><h4 id="History-scrollRestoration"><a href="#History-scrollRestoration" class="headerlink" title="# History.scrollRestoration"></a># History.scrollRestoration</h4><p><code>scrollRestoration</code> 這個屬性是可以修改的，它影響的是瀏覽器對於「使用者在歷史紀錄的頁面中移動時」的捲動行為，可以設定的值有兩個：</p><ul><li><code>&quot;auto&quot;</code>: 當使用者離開某個頁面時，瀏覽器會紀錄離開時的卷動距離，並在使用者到該頁時，自動卷動到記錄的位置。</li><li><code>&quot;manual&quot;</code>: 瀏覽器不會紀錄捲動距離，每次頁面更換時都會回到頂部。</li></ul><pre><code class="javascript">if (history.scrollRestoration === &quot;manual&quot;) &#123;  history.scrollRestoration = &quot;auto&quot;;&#125;</code></pre><blockquote><p>雖然 MDN 上說，<code>scrollRestoration</code> 還是一個實驗中的屬性，但其實除了 IE，其他的瀏覽器都已經實踐這個功能了，且預設會是 <code>auto</code>。</p></blockquote><p><br/><br/></p><h4 id="History-back"><a href="#History-back" class="headerlink" title="# History.back"></a># History.back</h4><p><code>back</code> 是 History 的其中一個 method，它相當於瀏覽器介面上的「上一頁」，所以如果你希望你的頁面中也有按鈕可以讓使用者返回上一頁，就可以適用它：</p><pre><code class="javascript">document.querySelector(&quot;button&quot;).addEventListener(&quot;click&quot;, function () &#123;  history.back();&#125;);</code></pre><p><br/><br/></p><h4 id="History-forward"><a href="#History-forward" class="headerlink" title="# History.forward"></a># History.forward</h4><p>沒錯，有上一頁，自然也有下一頁，對應的 method 就是 <code>forward</code>。</p><pre><code class="javascript">document.querySelector(&quot;button&quot;).addEventListener(&quot;click&quot;, function () &#123;  history.forward();&#125;);</code></pre><p><br/><br/></p><h4 id="History-go"><a href="#History-go" class="headerlink" title="# History.go"></a># History.go</h4><p>比起 <code>back</code> 和 <code>forward</code> 來說，<code>go</code> 就比較靈活了，它可以傳入一個數字來代表要往前或往後至相對於目前頁面的哪個歷史位置，例如傳入 <code>-1</code> 就相當於「上一頁」，傳入 <code>1</code> 則相當於「下一頁」。</p><p>要注意的是，如果傳入的數字超出了歷史紀錄的範圍，那將不會有任何效果。</p><pre><code class="javascript">history.go(-1); // 等於 history.back()history.go(1); // 等於 history.forward()history.go(-3); // 回到三頁之前history.go(0); // 瀏覽器會重新整理目前的頁面</code></pre><p><br/><br/></p><h2 id="pushState-replaceState"><a href="#pushState-replaceState" class="headerlink" title="pushState / replaceState"></a>pushState / replaceState</h2><p>上面介紹的 <code>back</code>、<code>forward</code> 和 <code>go</code>，其實都算是蠻簡單的，而且可能很多人都已經用過了，所以我們今天要重點介紹的其實是 <code>pushState</code> 和 <code>replaceState</code>，它們是 HTML5 中新增加的 API，讓我們可以添加或修改歷史紀錄。</p><br/><h4 id="History-pushState"><a href="#History-pushState" class="headerlink" title="# History.pushState"></a># History.pushState</h4><p><code>pushState</code> 可以讓我們在不移動頁面的情況下，添加一筆歷史紀錄，它一共有三個參數</p><ul><li>state: 這個參數可以接受一個物件，該物件裡可以存放任何資料，至於有什麼實際用途，後面會再介紹。</li><li>title: 這是一個被暫時保留的參數，實際上沒有任何用途，且會被瀏覽器忽略。</li><li>URL: 這個參數是用來設定我們添加的這筆歷史紀錄的網址，可傳可不傳。</li></ul><pre><code class="javascript">history.pushState(&#123; name: &quot;max&quot; &#125;, null, &quot;newPage.html&quot;);</code></pre><p>假設我們原本所在頁面的網址是 <code>https://maxleebk.com/index.html</code>，那當我們執行上面這段程式碼時，網址就會被改成 <code>https://maxleebk.com/newPage.html</code>，並且歷史紀錄會被加上一筆，所以如果點擊上一頁，又會回到 <code>/index.html</code>。</p><p>更有趣的是，當網址被改為 <code>/newPage.html</code> 時，瀏覽器不會真的去讀取 <code>newPage.html</code> 這個文件，而是維持在 <code>index.html</code>，直到使用者進行重新整理。</p><p><br/><br/></p><h4 id="History-replaceState"><a href="#History-replaceState" class="headerlink" title="# History.replaceState"></a># History.replaceState</h4><p><code>replaceState</code> 跟 <code>pushState</code> 的參數和效果都一樣，唯一不同的是 <code>replaceState</code> 並不是「添加」歷史紀錄，而是修改最新一筆的歷史紀錄。</p><pre><code class="javascript">history.replaceState(&#123; name: &quot;max&quot; &#125;, null, &quot;newPage.html&quot;);</code></pre><p>以同樣的例子來說，在 <code>https://maxleebk.com/index.html</code> 執行上面這段程式碼，網址一樣會被改成 <code>/newPage.html</code>，但當你按上一頁時，並不會回到 <code>/index.html</code>，而是回到更往前的一次的頁面，因為 <code>/index.html</code> 其實是被 <code>/newPage.html</code> 取代了。</p><p><br/><br/></p><h4 id="Window-popstate-Event"><a href="#Window-popstate-Event" class="headerlink" title="# Window:popstate Event"></a># Window:popstate Event</h4><p>再來要介紹的這個 WindowEvent 與 <code>pushState</code> 跟 <code>replaceState</code> 息息相關，這個事件會在使用者進行歷史紀錄操作（例如上一頁、下一頁）時觸發。</p><p>還記得前面講到 <code>pushState</code> 和 <code>replaceState</code> 的 <code>state</code> 參數嗎？<code>popstate</code> 事件的回呼函示所拿到的 Event 物件會有一個 <code>state</code> 屬性，它存放的就會是當初設定的 <code>state</code> 參數副本。</p><pre><code class="javascript">window.addEventListener(&quot;popstate&quot;, function (event) &#123;  console.log(event.state);&#125;);history.pushState(&#123; name: &quot;max&quot; &#125;, null); // 不指定URL，所以網址不會變history.pushState(&#123; name: &quot;tom&quot; &#125;, null); // 不指定URL，所以網址不會變//此時按下「上一頁」，console 會印出 &#123; name: &quot;max&quot; &#125;//接著按下「下一頁」，console 會印出 &#123; name: &quot;tom&quot; &#125;</code></pre><p><br/><br/></p><h4 id="復原-重做小應用"><a href="#復原-重做小應用" class="headerlink" title="# 復原 / 重做小應用"></a># 復原 / 重做小應用</h4><p>那學會 <code>pushState</code>、<code>replaceState</code> 和 <code>popstate</code> 能做什麼呢？其實我們可以利用 <code>state</code> 的設定來把使用者的一些操作記錄在 History 中：</p><pre><code class="html">&lt;div id=&quot;editable&quot; contenteditable=&quot;true&quot;&gt;&lt;/div&gt;&lt;script&gt;  window.addEventListener(&quot;popstate&quot;, function (e) &#123;    editable.textContent = &quot;&quot;;    if (e.state &amp;&amp; e.state.text) &#123;      // 每次有歷史紀錄的「移動」時，便將當下紀錄的 state 丟到可編輯元素中      editable.textContent = e.state.text;    &#125;  &#125;);  const editableDiv = document.querySelector(&quot;#editable&quot;);  editableDiv.addEventListener(&quot;input&quot;, function () &#123;    // 每次輸入時新增一筆歷史紀錄，且會利用 state 儲存當下的輸入內容    window.history.pushState(&#123; text: editable.textContent &#125;, null);  &#125;);&lt;/script&gt;</code></pre><p>我們一樣拿 <code>contenteditable</code> 的可編輯元素來示範，每當使用者輸入文字時我們就 <code>pushState</code> 一次，並把元素當中的文字內容紀錄在 <code>state</code> 中。而因為我們有監聽了 <code>popstate</code> 事件，使得使用者每次在進行「上一頁」或「下一頁」時，便能取得每一次輸入的內容。</p><p>這樣的好處就是，使用者可以透過瀏覽器的上一頁或下一頁來模擬「復原」和「重做」功能。</p><p><strong>如果想要玩玩看的話，這邊是我已經寫好的 <a href="https://codepen.io/max-lee/pen/KKqrbBO">CodePen</a></strong></p><p><br/><br/></p><p>其實大家如果有使用過 VueRouter 的話，它底層就是透過 <code>pushState</code>、<code>replaceState</code>，來實踐 SPA 的網址變換的，所以才說其實很多 Web API 都是非常好用，甚至很多有名的套件都會採用，只是我們通常會忽視這些 Web API 的強大功能。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10273613">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;歷史是現在與過去之間永無休止的對話。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我們都知道瀏覽器提供了上一頁、下一頁，甚至可以讓你回到前兩頁、前三頁…，但其實我們也可以借助 History API 的力量，在網頁中自己實踐這樣的功能。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / 簡易文字編輯器</title>
    <link href="https://maxleebk.com/2021/09/24/webApi/webApi-11/"/>
    <id>https://maxleebk.com/2021/09/24/webApi/webApi-11/</id>
    <published>2021-09-24T08:48:00.000Z</published>
    <updated>2023-10-23T03:50:24.536Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>學習之後，刻意進行練習能夠加深印象。</p></blockquote><p>前面三天我們已經習得 DesignMode、Selection API、Clipboard API，今天我們就將這三個 Web API 一同使用，動手寫一個簡易的文字編輯器吧!</p><hr><h2 id="簡易文字編輯器"><a href="#簡易文字編輯器" class="headerlink" title="簡易文字編輯器"></a>簡易文字編輯器</h2><p>我們今天要做的文字編輯器沒有特別的功能，只會模擬「全選」、「複製」、「剪下」、「貼上」四大功能，純粹就是為了讓大家更熟悉前面認識的 Web API 而已，未來各位想要新增其他的 feature，可以再自行發揮。</p><br/><h4 id="HTML"><a href="#HTML" class="headerlink" title="# HTML"></a># HTML</h4><p>首先我們先準備一下今天的網頁版面：</p><pre><code class="html">&lt;div&gt;  &lt;button id=&quot;all&quot;&gt;全選&lt;/button&gt;  &lt;button id=&quot;copy&quot;&gt;複製&lt;/button&gt;  &lt;button id=&quot;cut&quot;&gt;剪下&lt;/button&gt;  &lt;button id=&quot;paste&quot;&gt;貼上&lt;/button&gt;&lt;/div&gt;&lt;div id=&quot;editable&quot; contenteditable=&quot;true&quot;&gt;&lt;/div&gt;</code></pre><img src="rich.png" style="margin: 24px auto;" /><p>那上面就是我們這次的編輯器，上面是工具列的部分，下面則是文字編輯的區域，樣式的話各位可以自由發揮，CSS 的部分就不額外放上來了。而為了方便，這次的可編輯範圍我們使用 <code>contenteditable</code> 屬性，各位也可以改用 iframe 搭配 DesignMode。</p><p><br/><br/></p><h4 id="Utilities"><a href="#Utilities" class="headerlink" title="# Utilities"></a># Utilities</h4><p>再來，我們先準備一些共用的變數和函式：</p><pre><code class="javascript">const editableDiv = document.querySelector(&quot;#editable&quot;);function addClickListener(selector, callback) &#123;  const el = document.querySelector(selector);  el.addEventListener(&quot;mousedown&quot;, function (e) &#123;    e.preventDefault(); // 關閉 mousedown 原生事件  &#125;);  el.addEventListener(&quot;click&quot;, function (e) &#123;    callback(e);  &#125;);&#125;</code></pre><p>由於我們這次有四個按鈕需要綁定事件，所以為了避免重複撰寫，我們把事件監聽的程式碼拉出來作為共用函式，<strong>要注意的是</strong>，因為我們在點擊按鈕時會使得「可編輯區域」（#editable）的 focus 造成失焦，所以要特別把 <code>mousedown</code> 的原生事件關閉。</p><p><br/><br/></p><h4 id="全選按鈕"><a href="#全選按鈕" class="headerlink" title="# 全選按鈕"></a># 全選按鈕</h4><p>首先第一個按鈕是「全選」，我們希望使用者在點擊按鈕後可以把編輯區域中的文字全部反白：</p><pre><code class="javascript">addClickListener(&quot;#all&quot;, function (e) &#123;  const selection = window.getSelection();  selection.collapse(editableDiv, 0);  if (!editableDiv.childNodes.length) return; // 避免在沒有任何文字節點時進行 extend  selection.extend(editableDiv.childNodes[0], editableDiv.textContent.length);&#125;);</code></pre><p>利用前面的共用函式 <code>addClickListener</code>，來設定按鈕，而在 Callback 中我們的步驟是先將 Selection 坍縮（collapse）在編輯區的最前頭，然後透過 <code>extend</code> 來將 focus 移動到最後面，這樣編輯區自然就會被全部反白了。</p><p>不過要注意，當編輯區沒有任何文字節點時進行 <code>extend</code> 是會報錯的，所以我們在中間有加一行防禦性的判斷式。</p><p><br/><br/></p><h4 id="複製按鈕"><a href="#複製按鈕" class="headerlink" title="# 複製按鈕"></a># 複製按鈕</h4><p>再來複製按鈕要讓使用者可以將目前反白的文字放進系統剪貼簿中，這樣之後才能將其「貼上」。</p><pre><code class="javascript">addClickListener(&quot;#copy&quot;, function (e) &#123;  const selection = window.getSelection();  navigator.clipboard.writeText(selection.toString());&#125;);</code></pre><p>複製功能就相對簡單很多了，只要使用之前介紹 Selection 和 Clipboard 的基本 method 就可以實現。</p><p><br/><br/></p><h4 id="剪下按鈕"><a href="#剪下按鈕" class="headerlink" title="# 剪下按鈕"></a># 剪下按鈕</h4><p>剪下按鈕要做的事情其實和「複製」沒差多少，不過除了要將文字加進剪貼簿外，原本的文本內容需要將其移除，所以最後我們使用 Selection 的 <code>deleteFromDocument</code> 來處理。</p><pre><code class="javascript">addClickListener(&quot;#cut&quot;, function (e) &#123;  const selection = window.getSelection();  navigator.clipboard.writeText(selection.toString());  selection.deleteFromDocument();&#125;);</code></pre><p><br/><br/></p><h4 id="貼上按鈕"><a href="#貼上按鈕" class="headerlink" title="# 貼上按鈕"></a># 貼上按鈕</h4><p>最後就剩貼上按鈕了，也是本次練習中最複雜的功能，因為「貼上」這個動作在將剪貼簿的內容放入編輯區時，可能會有兩種情境需要必一併考慮：</p><ol><li>使用者要輸入游標插入編輯區的某個位置，想要並將剪貼簿內容貼上</li><li>使用者先反白了文字，想要將剪貼簿內容貼上，並取代反白的文字</li></ol><br/><p><strong>根據以上兩個情境，我們可以大致盤點出需要做的事情：</strong></p><ol><li>如果有反白文字，必須要將反白文字刪除</li><li>如果有反白文字，反白文字以前和以後的文字要保留</li><li>如果沒有反白文字，游標插入位置之前和之後的文字要保留</li><li>最後編輯區要顯示的內容應該是，前半部保留的文字 + 剪貼簿的文字 + 後半部保留的文字</li></ol><pre><code class="javascript">addClickListener(&quot;#paste&quot;, async function (e) &#123;  const selection = window.getSelection();  selection.deleteFromDocument();  const offset = selection.anchorOffset;  const prefix = editableDiv.textContent.substr(0, offset);  const suffix = editableDiv.textContent.substr(offset);  const clipboardText = await navigator.clipboard.readText();  const textNode = document.createTextNode(prefix + clipboardText + suffix);  editableDiv.innerHTML = &quot;&quot;;  editableDiv.appendChild(textNode);  selection.collapse(textNode, (prefix + clipboardText).length);&#125;);</code></pre><p>在整理出事項後，上面就是我們最後撰寫出來的程式碼了，首先執行 <code>deleteFromDocument</code>，只要有反白的文字就會被刪除，而且與此同時，Selection 會被自動坍縮在一個點上，這樣只要取得 <code>anchorOffset</code> 就可以知道游標目前插入在第幾個字。</p><p>然後就可以使用 <code>substr</code> 把需要保留的文字分割出來，最後只要加上剪貼簿的內容再放回去就行囉，最後一行則是將游標放回原本的位置。</p><p><strong>如果想要玩玩看的話，這邊是這次練習的 <a href="https://codepen.io/max-lee/pen/wveYwKK">CodePen</a></strong></p><p><br/><br/></p><p>不曉得大家對於這次的練習還滿意嗎？雖然今天做出來的功能並不是很實用，但主要還是希望和大家一起在複習前面幾天學習的內容，而且其實各位時間心力的話，可以再為這個範例不斷添加新功能，完成自己的作品。</p><p>另外這種文字編輯器，其實有很多 js 套件都有實現了，例如 <a href="https://www.slatejs.org/examples/richtext">Slate.js</a> 就是一套很完整的工具，它使用的技術和我們今天使用的差不了多少，有興趣的人可以再去看看。</p><blockquote><p>通常這種所見即所得的編輯器會稱作「富文字編輯器」（Rich Text）</p></blockquote><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10272325">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;學習之後，刻意進行練習能夠加深印象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面三天我們已經習得 DesignMode、Selection API、Clipboard API，今天我們就將這三個 Web API 一同使用，動手寫一個簡易的文字編</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / Clipboard</title>
    <link href="https://maxleebk.com/2021/09/23/webApi/webApi-10/"/>
    <id>https://maxleebk.com/2021/09/23/webApi/webApi-10/</id>
    <published>2021-09-23T12:38:00.000Z</published>
    <updated>2023-10-23T03:50:24.536Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CTRL + C &amp; CTRL + V，兩個指令就能讓你成為工程師。</p></blockquote><p>Selection API 掌管著網頁中的「反白」，Clipboard API 則是掌管著網頁中的「複製」，不管是做報告、分享文章或是寫 code，都時常會參考、借鑑網頁中的內容，這時候我們就會執行「複製」，將文本內容暫時放在電腦裡的記憶體中，而這項動作只要是發生在我們網頁中，我們就可以利用 Clipboard API 來動一些手腳。</p><hr><h2 id="Clipboard"><a href="#Clipboard" class="headerlink" title="Clipboard"></a>Clipboard</h2><p>Clipboard 指的是瀏覽器中的系統剪貼簿，我們可以透過一些指令來訪問它，進而執行讀寫的動作，不過由於使用者可能會將一些機敏性的資料存放在剪貼簿中，所以為了避免個資外洩，除非使用者允許授權，不然瀏覽器都會限制網頁讀取使用者的剪貼簿，不過寫入的部分就沒有限制了。</p><img src="clipboard.png" style="margin: 24px auto;" /><blockquote><p>如果使用者拒絕了授權，只能透過使用者主動調整授權才能夠開啟功能，所以記得透過 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Permissions_API/Using_the_Permissions_API">Permissions.query()</a> 來確認授權狀態，並提醒使用者。</p></blockquote><br/><h4 id="Navigator-clipboard"><a href="#Navigator-clipboard" class="headerlink" title="# Navigator.clipboard"></a># Navigator.clipboard</h4><p>要取得瀏覽器的 Clipboard 物件，只要訪問 <code>navigator</code> 底下的 <code>clipboard</code> 屬性即可：</p><pre><code class="javascript">const board = navigator.clipboard;console.log(board); // Clipboard 物件</code></pre><p><br/><br/></p><h4 id="Clipboard-readText"><a href="#Clipboard-readText" class="headerlink" title="# Clipboard.readText"></a># Clipboard.readText</h4><p>取得 Clipboard 物件後，我們就可以使用它自身的 method 來讀寫剪貼簿了，而 <code>readText</code> 就是讓我們可以讀取剪貼板目前儲存的文本內容，呼叫它後會回傳一個 Promise，需要用 <code>then</code> 來串接並取得文本：</p><pre><code class="html">&lt;button&gt;Get Clipboard&lt;/button&gt;&lt;script&gt;  const button = document.querySelector(&quot;button&quot;);  button.addEventListener(&quot;click&quot;, function () &#123;    navigator.clipboard.readText().then((text) =&gt; &#123;      console.log(text); // 剪貼簿中的文本內容    &#125;);  &#125;);&lt;/script&gt;</code></pre><blockquote><p>你該注意：</p><ol><li>有些瀏覽器可能會阻止「直接命令」剪貼簿，最好是透過使用者點擊按鈕或監聽事件來處理。</li><li><code>navigator.clipboard</code> 取得的是當下視窗的系統剪貼簿，所以如果你是透過 Console 面板執行的話有可能會報錯，因為它是在「開發者工具」視窗下執行的。</li></ol></blockquote><p><br/><br/></p><h4 id="Clipboard-writeText"><a href="#Clipboard-writeText" class="headerlink" title="# Clipboard.writeText"></a># Clipboard.writeText</h4><p>知道怎麼「讀」之後，就要來看看怎麼「寫」了，<code>writeText</code> 可以讓我們修改目前使用者儲存在剪貼簿的內容，只要將指定內容當作參數傳入即可，另外在執行後依然會回傳 Promise，當修改成功後便可以執行 <code>then</code> 中的 Callback，或是在失敗後進行 Error Handle。</p><p><button id="get" style="padding: 5px">Set Clipboard</button> &lt;&lt; 你可以試試看</p><script>  const button = document.querySelector('#get');  button.addEventListener('click', function() {    const text = "你複製的東西被我變成這段文字了";    navigator.clipboard.writeText(text)      .then(() => alert("success"))      .catch(() => alert("fail"))  });</script><pre><code class="html">&lt;button&gt;Set Clipboard&lt;/button&gt;&lt;script&gt;  const button = document.querySelector(&quot;button&quot;);  button.addEventListener(&quot;click&quot;, function () &#123;    const text = &quot;你複製的東西被我變成這段文字了&quot;;    navigator.clipboard      .writeText(text)      .then(() =&gt; alert(&quot;success&quot;))      .catch(() =&gt; alert(&quot;fail&quot;));  &#125;);&lt;/script&gt;</code></pre><p><br/><br/></p><h2 id="ClipboardEvent"><a href="#ClipboardEvent" class="headerlink" title="ClipboardEvent"></a>ClipboardEvent</h2><p>除了可以主動操作 Clipboard 物件以外，瀏覽器還提供了一些剪貼簿的相關事件讓我們監聽，當使用者執行 <code>cut</code>、<code>copy</code> 和 <code>paste</code> 的操作時，便能透過事件 Callback 執行指定動作，且 Callback 所獲得的 Event 物件當中還會多一個 <code>clipboardData</code> 屬性，該屬性也會有自身的 method 可以使用。</p><br/><h4 id="Event-clipboardData-getData"><a href="#Event-clipboardData-getData" class="headerlink" title="# Event.clipboardData.getData"></a># Event.clipboardData.getData</h4><p><code>getData</code> 可以讓我們取得剪貼簿中的資料，它有一個必傳的參數是資料格式，一般來說都是使用 <code>&quot;text/plain&quot;</code> 來指定「純文字資料」。</p><blockquote><p>它和前面提到的 <code>Clipboard.readText</code> 功能基本一樣，但要注意這兩者所屬的物件是不同的。</p></blockquote><pre><code class="javascript">// 讓整個網頁可以進行編輯，這樣才能觸發貼上事件document.designMode = &quot;on&quot;;// getData 通常搭配 paste 事件，在 cut、copy 事件中使用會拿不到東西document.addEventListener(&quot;paste&quot;, function (e) &#123;  const clipboardText = e.clipboardData.getData(&quot;text/plain&quot;);  console.log(&quot;使用者貼上了文字：&quot; + clipboardText);&#125;);</code></pre><p><br/><br/></p><h4 id="Event-clipboardData-setData"><a href="#Event-clipboardData-setData" class="headerlink" title="# Event.clipboardData.setData"></a># Event.clipboardData.setData</h4><p>不曉得各位有沒有在他人部落格中複製程式碼後，發現貼上後的內容多了幾行作者的著作申明？其實這樣的功能就是透過 <code>setData</code> 做到的，它可以讓我們修改使用者剪貼簿內容。</p><blockquote><p>它和前面提到的 <code>Clipboard.writeText</code> 功能基本一樣，但要注意這兩者所屬的物件是不同的。</p></blockquote><pre><code class="javascript">// setData 通常搭配 cut、copy 事件，在 paste 事件中使用會沒有效果document.addEventListener(&quot;copy&quot;, function (e) &#123;  // 利用昨天認識的 Selection API 取得使用者反白的文字  const selectionText = window.getSelection().toString();  const extraText = &quot;\n注意：你複製的這段文字屬於 Max&quot;;  e.preventDefault(); // 阻止使用者本來要執行的「複製」動作  e.clipboardData.setData(&quot;text/plain&quot;, selectionText + extraText);&#125;);</code></pre><br/><blockquote><p>其實在 Clipboard API 被廣泛的被瀏覽器採用前，要處理剪貼簿都是透過 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand">document.execCommand</a>，但因為它有不少缺點，所以逐漸被取代，如果各位有興趣知道的話，可以再去搜尋了解。</p></blockquote><p><br/><br/></p><p>其實你有注意的話，今天的示範程式碼中有出現 DesignMode 和 Selection 的身影，這三者其實常常一起使用，這也就是為什麼我會在前面的章節一直提到要等三個 Web API 一起介紹完後，再來實際做一個文章編輯器的應用。到了今天我們終於把它們通通習得了，就準備明天動手寫吧！</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10271977">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;CTRL + C &amp;amp; CTRL + V，兩個指令就能讓你成為工程師。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Selection API 掌管著網頁中的「反白」，Clipboard API 則是掌管著網頁中的「複製」，不管是做報告、分享文</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / Selection</title>
    <link href="https://maxleebk.com/2021/09/22/webApi/webApi-9/"/>
    <id>https://maxleebk.com/2021/09/22/webApi/webApi-9/</id>
    <published>2021-09-22T14:38:00.000Z</published>
    <updated>2023-10-23T03:50:24.772Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>選你所愛，愛你所選。</p></blockquote><p>在瀏覽網站時，反白(或稱反藍)其實是一個非常常見的動作，不管是要強調目前的閱讀區域或是想要複製某個段落，使用者都會透過游標進行反白，而 Selection API 就是針對反白的選取區塊進行操作。</p><hr><h2 id="Selection"><a href="#Selection" class="headerlink" title="Selection"></a>Selection</h2><p>Selection 本身是一個物件，它代表的是目前使用者所選的文本範圍，或是「輸入游標」插入的位置，這文本範圍可能會涵蓋到多個元素，也可能會坍縮在一個點(也就是沒有選取到任何文本)，而這整個選取範圍又包含了幾個專有術語：</p><img src="selection.png" style="margin: 24px auto;" /><blockquote><p>你該知道：</p><ol><li>anchor 有可能在 focus 前面也有可能在 focus 後面，這取決於你拖曳游標的方向。</li><li>range 可能會橫跨多個節點，但 anchor 和 focus 只會存在在最初與最後的節點當中。</li></ol></blockquote><br/><h4 id="Window-getSelection"><a href="#Window-getSelection" class="headerlink" title="# Window.getSelection"></a># Window.getSelection</h4><p>如果想要取得目前選取範圍的 Selection 物件，那只要呼叫這個 method 就可以了：</p><pre><code class="javascript">let selectionObj = window.getSelection();console.log(selectionObj); // Selection 物件</code></pre><p><br/><br/></p><h4 id="Selection-anchorNode"><a href="#Selection-anchorNode" class="headerlink" title="# Selection.anchorNode"></a># Selection.anchorNode</h4><p>取得了 Selection 物件後我們就可以讀取它本身的一些屬性了，而 <code>anchorNode</code> 就是其中之一，它會給我們當初反白時 anchor 位置所在的節點。</p><pre><code class="javascript">let selectionObj = window.getSelection();console.log(selectionObj.anchorNode); // 一個文字節點</code></pre><img src="anchor.gif" style="margin: 24px auto;" /><p><br/><br/></p><h4 id="Selection-anchorOffset"><a href="#Selection-anchorOffset" class="headerlink" title="# Selection.anchorOffset"></a># Selection.anchorOffset</h4><p>知道 anchor 所在節點後，還可以透過 <code>anchorOffset</code> 來知道 anchor 點下的位置距離節點開頭相差了幾個字：</p><pre><code class="javascript">let selectionObj = window.getSelection();console.log(selectionObj.anchorOffset); // 一個 number，代表與節點開頭相差了幾個字</code></pre><p><br/><br/></p><h4 id="Selection-focusNode"><a href="#Selection-focusNode" class="headerlink" title="# Selection.focusNode"></a># Selection.focusNode</h4><p>當然了，可以知道 anchor 的位置，自然也能知道 focus 的位置。</p><pre><code class="javascript">let selectionObj = window.getSelection();console.log(selectionObj.focusNode); // 一個文字節點</code></pre><p><br/><br/></p><h4 id="Selection-focusOffset"><a href="#Selection-focusOffset" class="headerlink" title="# Selection.focusOffset"></a># Selection.focusOffset</h4><p>以此類推，有 <code>focusNode</code> 就也會有 <code>focusOffset</code>：</p><pre><code class="javascript">let selectionObj = window.getSelection();console.log(selectionObj.focusOffset); // 一個 number，代表與節點開頭相差了幾個字</code></pre><p><br/><br/></p><h4 id="Selection-toString"><a href="#Selection-toString" class="headerlink" title="# Selection.toString"></a># Selection.toString</h4><p>那除了一些唯讀屬性之外呢，Selection 物件有有一些自身的 methods 可以使用，其中最簡單也最重要的自然就是取得所選範圍的文本內容，這時候只要呼叫 <code>toString</code> 就可以了：</p><pre><code class="javascript">let selectionObj = window.getSelection();console.log(selectionObj.toString()); // 所選範圍的文本內容</code></pre><p><br/><br/></p><h4 id="Selection-collapse"><a href="#Selection-collapse" class="headerlink" title="# Selection.collapse"></a># Selection.collapse</h4><p><code>collapse</code> 是個比較特別的 method，它會讓 Selection 坍縮到只剩下一個點，也就是從一個反白區塊變成只剩下一個閃爍的輸入游標在畫面上。</p><p>而 <code>collapse</code> 有兩個參數可以傳入，第一個是你想坍縮 Selection 到哪一個節點上，第二個參數則是你要坍縮在該節點上的第幾個位置。</p><pre><code class="html">&lt;div contenteditable=&quot;true&quot;&gt;這裡的文字可以編輯&lt;/div&gt;&lt;button&gt;collapse&lt;/button&gt;&lt;script&gt;  const button = document.querySelector(&quot;button&quot;);  button.addEventListener(&quot;mousedown&quot;, function (e) &#123;    e.preventDefault();  &#125;);  button.addEventListener(&quot;click&quot;, function () &#123;    const selection = window.getSelection();    // 將選取範圍坍縮在 anchor 所在節點的第十個字    selection.collapse(selection.anchorNode, 10);  &#125;);&lt;/script&gt;</code></pre><blockquote><p>要注意，儘管你看不到閃爍的游標，但其實游標還是被放到了你 focus 或 collapse 的位置。而如果你將元素改為 <code>contenteditable</code>，你就可以清楚看到游標了。</p></blockquote><p><br/><br/></p><h4 id="Selection-extend"><a href="#Selection-extend" class="headerlink" title="# Selection.extend"></a># Selection.extend</h4><p>另一個和 <code>collapse</code> 很像的是 <code>extend</code>，它會讓 anchor 保持不變並移動 focus，也就是說你可以改變反白的區域。它的參數也和 <code>collapse</code> 一樣，第一個是你要將 focus 移動到哪個節點，第二個則是要移動到該節點的第幾個字。</p><pre><code class="html">&lt;div contenteditable=&quot;true&quot;&gt;這裡的文字可以編輯&lt;/div&gt;&lt;button&gt;extend&lt;/button&gt;&lt;script&gt;  const button = document.querySelector(&quot;button&quot;);  button.addEventListener(&quot;mousedown&quot;, function (e) &#123;    e.preventDefault();  &#125;);  button.addEventListener(&quot;click&quot;, function () &#123;    const selection = window.getSelection();    // 將 focus 移動到跟 anchor 一樣的位置，此時 Selection 會是坍縮的    selection.extend(selection.anchorNode, selection.anchorOffset);  &#125;);&lt;/script&gt;</code></pre><p><br/><br/></p><h4 id="Selection-selectAllChildren"><a href="#Selection-selectAllChildren" class="headerlink" title="# Selection.selectAllChildren"></a># Selection.selectAllChildren</h4><p>這個 method 算是非常好用的，它可以夠傳入一個元素節點來指定目前的選取範圍。如果你傳的是整個 <code>document.body</code> 那就相當於是全選整個網頁。</p><pre><code class="html">&lt;div&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit.&lt;/div&gt;&lt;script&gt;  const div = document.querySelector(&quot;div&quot;);  const selection = window.getSelection();  selection.selectAllChildren(div); // div 中的內容將整個被反白起來&lt;/script&gt;</code></pre><p><br/><br/></p><h4 id="Selection-deleteFromDocument"><a href="#Selection-deleteFromDocument" class="headerlink" title="# Selection.deleteFromDocument"></a># Selection.deleteFromDocument</h4><p><code>deleteFromDocument</code> 可以幫我們將目前選取的區塊從整個文件中刪除，當然，他指的是目前瀏覽的頁面，並不會連同你的程式碼一併刪除。</p><pre><code class="html">&lt;div&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit.&lt;/div&gt;&lt;script&gt;  const div = document.querySelector(&quot;div&quot;);  const selection = window.getSelection();  // 我們將 div 中的內容整個反白起來後刪除了  selection.selectAllChildren(div);  selection.deleteFromDocument();&lt;/script&gt;</code></pre><p><br/><br/></p><h4 id="Document-selectionchange-Event"><a href="#Document-selectionchange-Event" class="headerlink" title="# Document:selectionchange Event"></a># Document:selectionchange Event</h4><p>最後，除了主動針對 Selection 物件進行操作外，Document 本來還可以監聽 <code>selectionchange</code> 的事件，當今天文件中的選取範圍有了更動，該事件就會觸發，並執行我們指定的 Callback。</p><pre><code class="javascript">document.addEventListener(&quot;selectionchange&quot;, () =&gt; &#123;  // 講選取起來的文本內容設定到指定的容器中  document.querySelector(&quot;#text&quot;).textContent = window.getSelection().toString();&#125;);</code></pre><p><br/><br/></p><p>相信看完今天的內容，你可能會覺得 Selection API 功能似乎蠻齊全的，但好像也不知道要拿來做什麼應用，但其實只要搭配昨天的 DesignMode，我們就可以製作一個簡易的文章編輯器了，不過等到明天的 Clipboard 一併介紹完後，我們再來實際動手做，屆時各位就會知道 Selection API 其實是蠻好玩的。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10271519">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;選你所愛，愛你所選。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在瀏覽網站時，反白(或稱反藍)其實是一個非常常見的動作，不管是要強調目前的閱讀區域或是想要複製某個段落，使用者都會透過游標進行反白，而 Selection API 就是針對反白的選取區</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / DesignMode</title>
    <link href="https://maxleebk.com/2021/09/21/webApi/webApi-8/"/>
    <id>https://maxleebk.com/2021/09/21/webApi/webApi-8/</id>
    <published>2021-09-21T13:38:00.000Z</published>
    <updated>2023-10-23T03:50:24.768Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>DesignMode 讓整個網站都是你的 textarea。</p></blockquote><p>今天要介紹的 API 非常簡單明瞭，簡單到有點偷懶的嫌疑了，但其實等我們連同後面兩天的內容介紹完後，今天的 DesignMode 才可以發揮它的真正實力，今天我們就先簡單暸解一下它的效果就好。</p><hr><h2 id="DesignMode"><a href="#DesignMode" class="headerlink" title="DesignMode"></a>DesignMode</h2><p>DesignMode 翻譯成中文就是設計模式，但要設計什麼呢？設計整個網頁。你沒聽錯，DesignMode 的設定可以讓整個網頁變成一個網頁編輯器，使用者便可以隨心所欲的修改網站中的文字。</p><br/><h4 id="Document-designMode"><a href="#Document-designMode" class="headerlink" title="# Document.designMode"></a># Document.designMode</h4><p>今天最主要的 API 就這麼一個，也沒有什麼技巧可言，就是這麼一行簡單的 code：</p><pre><code class="javascript">document.designMode = &quot;on&quot;; // 關閉則設定成 &quot;off&quot;</code></pre><p>你可以試著打開 devTool 的 Console 面板並執行上面這段指令，你就會發現你能夠自由編輯目前畫面中的所有東西，剪下、貼上、刪除、新增等等都不是問題。但你可能會想：「這到底可以幹嘛？」。</p><p>其實 DesignMode 有一個最直覺的作用，那就是讓你在開發時可以進行更即時性的文案測試，你可以直接在網頁上進行文字編輯，而不是在開發環境中修改後再到頁面上確認。或許身為前端工程師的你會覺得這項功能有點雞肋，但如果你要跟設計師溝通，或設計師想要進行調整測試時，直接打開 DesignMode 就會非常方便。</p><p><br/><br/></p><h4 id="iframe-amp-designMode"><a href="#iframe-amp-designMode" class="headerlink" title="# iframe &amp; designMode"></a># iframe &amp; designMode</h4><p>另外，DesignMode 也不是只能運用在目前的頁面，你也可以針對頁面中的 iframe 來設定：</p><p><strong>◾ iframe.html</strong></p><pre><code class="html">&lt;h1&gt;I am Max.&lt;/h1&gt;&lt;p&gt;DesignMode is very fun.&lt;/p&gt;</code></pre><br/><p><strong>◾ index.html</strong></p><pre><code class="html">&lt;iframe src=&quot;./iframe.html&quot;&gt;&lt;/iframe&gt;&lt;button onClick=&quot;getHtml()&quot;&gt;Get HTML&lt;/button&gt;&lt;script&gt;  window.onload = function () &#123;    const iframeDocument = document.querySelector(&quot;iframe&quot;).contentDocument;    iframeDocument.designMode = &quot;on&quot;;  &#125;;  function getHtml() &#123;    const iframeDocument = document.querySelector(&quot;iframe&quot;).contentDocument;    console.log(iframeDocument.body.innerHTML);  &#125;&lt;/script&gt;</code></pre><img src="design-mode.gif" style="margin: 24px auto;" /><p>當然了，你可能還是會問說這樣的效果可以做些什麼？但其實許多部落格或筆記網站能夠讓你在網頁中進行文字編輯，靠的就是 DesignMode，只不過它們通常都會搭配一些編輯工具，讓你可以將文字放大縮小、粗體斜體或設定顏色等等。</p><p><br/><br/></p><h2 id="Contenteditable"><a href="#Contenteditable" class="headerlink" title="Contenteditable"></a>Contenteditable</h2><p>既然剛剛講到了部落格和筆記網站，那我們就必須再額外介紹 Contenteditable，它擁有與 DesignMode 非常相像的功能，且比起 DesignMode，剛剛提到的網站可能更常用的是 Contenteditable，像是目前最火紅的 Notion 就是使用 Contenteditable。</p><p>不過 Contenteditable 其實並不是 Web API，它是 HTML5 中的一個全域屬性，只要在任何元素標籤中加上這個屬性，該元素中的內文就會變成可編輯的狀態。</p><pre><code class="html">&lt;div contenteditable=&quot;true&quot;&gt;這裡的文字可以編輯&lt;/div&gt;</code></pre><br/><blockquote><p>textarea 本身就是一個可編輯文本的區域沒錯，但如果你想做到像部落格一樣有文字美編功能的話，textarea 是沒辦法達成的。</p></blockquote><p><br/><br/></p><p>其實我們已經在文章中點出了 DesignMode 的真實實力該如何發揮了，那就是透過一些手法，讓我們可以對編輯中的文字進行一些樣式的設定，如此以來 DesignMode 就會是名副其實的設計模式了。而這樣的工具，我們會在認識 Selection 與 Clipboard 之後，再來動手寫寫看。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10270710">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;DesignMode 讓整個網站都是你的 textarea。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天要介紹的 API 非常簡單明瞭，簡單到有點偷懶的嫌疑了，但其實等我們連同後面兩天的內容介紹完後，今天的 DesignMode 才可以發揮它的</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / ImageCapture</title>
    <link href="https://maxleebk.com/2021/09/20/webApi/webApi-7/"/>
    <id>https://maxleebk.com/2021/09/20/webApi/webApi-7/</id>
    <published>2021-09-20T03:38:00.000Z</published>
    <updated>2023-10-23T03:50:24.768Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>疫情時代，視訊串流當頭，用視訊鏡頭來做個線上攝影吧！</p></blockquote><p>自從疫情爆發後，各行各業也開始進行居家辦公，使得視訊軟體及相關技術開始受重視，身為前端，我們也可以拿視訊鏡頭來做些好玩有趣的東西，而 ImageCapture 就是其中一個可以運用在這裡的 API。</p><hr><h2 id="MediaStream"><a href="#MediaStream" class="headerlink" title="MediaStream"></a>MediaStream</h2><p>在認識 ImageCapture 之前我們必須要先了解 MediaStream，瀏覽器將獲取的影音資訊稱之為「流」(Stream)，其中流又包含了「軌」(Track)，如影像軌、音訊軌，而我們可以透過向使用者獲取授權並透過裝置來取得這些影音資訊，進而達到我們想要的操作目的。</p><br/><h4 id="Navigator-mediaDevices-getUserMedia"><a href="#Navigator-mediaDevices-getUserMedia" class="headerlink" title="# Navigator.mediaDevices.getUserMedia"></a># Navigator.mediaDevices.getUserMedia</h4><p>而我們要取得 MediaStream 的手段就是要先向使用者獲取設備的授權，這時候就要使用 <code>getUserMedia</code>：</p><pre><code class="javascript">navigator.mediaDevices  .getUserMedia(&#123; video: true &#125;)  .then((mediaStream) =&gt; &#123;    /* use the stream */  &#125;)  .catch((err) =&gt; &#123;    /* handle the error */  &#125;);</code></pre><p>當我們呼叫 <code>getUserMedia</code> 時，必須傳入一個稱為 <code>constraints</code> 的參數，該參數為一個物件，當中需要表示你想取得的 Track，例如上面我們就是傳入 <code>&#123; video: true &#125;</code>，來取得視訊軌。</p><p>而 <code>getUserMedia</code> 會回傳 Promise 給我們，當使用者同意授權後就可以在 <code>then</code> 的 Callback 中取得 MediaStream。</p><p><br/><br/></p><h4 id="MediaStream-getVideoTracks"><a href="#MediaStream-getVideoTracks" class="headerlink" title="# MediaStream.getVideoTracks"></a># MediaStream.getVideoTracks</h4><p>當我們取得 MediaStream 後，我們還需要再取得當中的 Track，之後才可以透過 ImageCapture 來操作，這時候就需要使用 MediaStream 自身的 method <code>getVideoTracks</code>。</p><pre><code class="javascript">navigator.mediaDevices  .getUserMedia(&#123; video: true &#125;)  .then((mediaStream) =&gt; &#123;    const videoTrack = mediaStream.getVideoTracks()[0];  &#125;)  .catch((err) =&gt; &#123;    console.log(err);  &#125;);</code></pre><p>要注意的是，由於一個 MediaStream 中未必只有一個 VideoTrack，所以 <code>getVideoTracks</code> 回傳的會是陣列，記得要透過 <code>index</code> 索引出來。</p><p><br/><br/></p><h2 id="ImageCapture"><a href="#ImageCapture" class="headerlink" title="ImageCapture"></a>ImageCapture</h2><p>知道如何取得 MediaStreamTrack 後，就可以來認識 ImageCapture 了，它可以讓我們建立一個圖像擷取器，只要提供一個有效的 VideoTrack 給 ImageCapture 就可以進行圖像的擷取：</p><pre><code class="javascript">const imageCapture = new ImageCapture(videoTrack);</code></pre><br/><h4 id="ImageCapture-takePhoto"><a href="#ImageCapture-takePhoto" class="headerlink" title="# ImageCapture.takePhoto"></a># ImageCapture.takePhoto</h4><p>當我們為一個 ImageCapture 綁定了 VideoTrack 後，我們就可以透過 ImageCapture 底下的 methods 來進行圖像擷取了：</p><pre><code class="javascript">let imageCapture;navigator.mediaDevices  .getUserMedia(&#123; video: true &#125;)  .then((mediaStream) =&gt; &#123;    const videoTrack = mediaStream.getVideoTracks()[0];    imageCapture = new ImageCapture(videoTrack);  &#125;)  .catch((err) =&gt; &#123;    console.log(err);  &#125;);document.querySelector(&quot;button&quot;).addEventListener(&quot;click&quot;, function () &#123;  imageCapture.takePhoto().then((blob) =&gt; &#123;    console.log(blob);  &#125;);&#125;);</code></pre><p>呼叫 <code>takePhoto</code> 後，它會回傳 Promise，並且我們能在 <code>then</code> 的 Callback 中取得截圖的 Blob 物件。</p><p><br/><br/></p><h4 id="ImageCapture-grabFrame"><a href="#ImageCapture-grabFrame" class="headerlink" title="# ImageCapture.grabFrame"></a># ImageCapture.grabFrame</h4><p>再來要介紹的則是 <code>grabFrame</code>，它和 <code>takePhoto</code> 一樣是擷取 videoTrack 的影像，差別在於它回傳的是 ImageBitmap 物件，而這種物件的好處是可以直接拿來畫在 Canvas 上。</p><pre><code class="javascript">imageCapture.takePhoto().then((blob) =&gt; &#123;  console.log(blob);&#125;);imageCapture.grabFrame().then((imageBitmap) =&gt; &#123;  console.log(imageBitmap);&#125;);</code></pre><blockquote><p>Blob 物件可以夠過 <code>createImageBitmap(blob)</code> 來轉換成 ImageBitmap 物件</p></blockquote><p><br/><br/></p><h2 id="實際運用"><a href="#實際運用" class="headerlink" title="實際運用"></a>實際運用</h2><p>那最後我們就透過今天認識的 API 來實際做個視訊截圖攝影吧，首先先準備幾個按鈕以及 <code>video</code> 和 <code>canvas</code>。</p><pre><code class="html">&lt;div&gt;  &lt;button onclick=&quot;openCamera()&quot;&gt;開啟鏡頭&lt;/button&gt;  &lt;button onclick=&quot;capture()&quot;&gt;擷取畫面&lt;/button&gt;&lt;/div&gt;&lt;video&gt;&lt;/video&gt;&lt;canvas&gt;&lt;/canvas&gt;</code></pre><p>再來是在 <code>openCamera</code> 的時候使用 <code>getUserMedia</code> 及 <code>getVideoTracks</code> 來取得 MediaStreamTrack 並建立 ImageCapture。處此之外，我們還設定了 <code>video.srcObject</code>，如此一來我們就可以夠過 <code>&lt;video&gt;</code> 標籤來預覽視訊畫面。</p><pre><code class="javascript">var video = document.querySelector(&quot;video&quot;);var canvas = document.querySelector(&quot;canvas&quot;);var context = canvas.getContext(&quot;2d&quot;);var videoTrack;var imageCapture;// 開啟鏡頭function openCamera() &#123;  navigator.mediaDevices    .getUserMedia(&#123; video: true &#125;)    .then((stream) =&gt; &#123;      // 取得視訊軌並建立 imageCapture      videoTrack = stream.getVideoTracks()[0];      imageCapture = new ImageCapture(videoTrack);      // 將媒體流設定到 &lt;video&gt; 中顯示播放      video.srcObject = stream;      video.play();    &#125;)    .catch((err) =&gt; &#123;      console.log(err);    &#125;);&#125;//擷取畫面function capture() &#123;  imageCapture    .takePhoto()    .then((blob) =&gt; &#123;      // 將 Blob 轉成 ImageBitmap      return createImageBitmap(blob);    &#125;)    .then((imageBitmap) =&gt; &#123;      // 繪製在 canvas 上      const &#123; width, height &#125; = imageBitmap;      const ratio = video.videoWidth / width;      canvas.setAttribute(&quot;width&quot;, width * ratio);      canvas.setAttribute(&quot;height&quot;, height * ratio);      context.drawImage(imageBitmap, 0, 0, width * ratio, height * ratio);    &#125;);&#125;</code></pre><p>最後只要在 <code>capture</code> 的時候透過 <code>takePhoto</code> 進行截圖，並將 Blob 轉成 ImageBitmap 後丟到 <code>&lt;canvas&gt;</code> 裡，就大功告成囉。</p><p>完整的 code 我就放在 <strong><a href="https://codepen.io/max-lee/pen/RwgJmJp">這裡</a></strong>，大家可以看看實際效果。</p><p><br/><br/></p><p>其實視訊的操作沒有大家想像的那麼困難，簡單幾個 API 就可以做到，今天做的鏡頭截圖其實就可以做在會員的大頭照設定，讓使用者可以直接利用視訊鏡頭拍攝大頭照，相當便利。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10270021">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;疫情時代，視訊串流當頭，用視訊鏡頭來做個線上攝影吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自從疫情爆發後，各行各業也開始進行居家辦公，使得視訊軟體及相關技術開始受重視，身為前端，我們也可以拿視訊鏡頭來做些好玩有趣的東西，而 ImageCapt</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / Battery</title>
    <link href="https://maxleebk.com/2021/09/19/webApi/webApi-6/"/>
    <id>https://maxleebk.com/2021/09/19/webApi/webApi-6/</id>
    <published>2021-09-19T06:38:00.000Z</published>
    <updated>2023-10-23T03:50:24.768Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>低電量～低～低～電量～ 呂士軒-低電量</p></blockquote><p>今天要分享的也是一個使用情境偏少的 API，但如果你有想要做移動端的應用的話，或許可以嘗試使用看看。</p><hr><h2 id="Battery"><a href="#Battery" class="headerlink" title="Battery"></a>Battery</h2><p>Battery API 是一個與使用者的裝置電池相關的 API，我們可以透過它來得知電池的相關資訊，也可以監聽電量的變化，以此來做到一些提示或警告的功能效果。</p><br/><h4 id="Navigator-getBattery"><a href="#Navigator-getBattery" class="headerlink" title="# Navigator.getBattery"></a># Navigator.getBattery</h4><p>裝置電池的資訊會被包裹在一個叫做 BatteryManager 的物件中，要取得該物件的話，我們必須要透過呼叫 <code>navigator.getBattery</code> 來取得：</p><pre><code class="javascript">navigator.getBattery().then((battery) =&gt; &#123;  console.log(battery); // BatteryManager&#125;);</code></pre><p>可以看到，互叫後 <code>getBattery</code> 回傳的是 Promise，其被 <code>resolve</code> 後才會傳遞 BatteryManager 給我們，所以我們要用 <code>then</code> 去串接取得。</p><p><br/><br/></p><h4 id="BatteryManager"><a href="#BatteryManager" class="headerlink" title="# BatteryManager"></a># BatteryManager</h4><p>取得 BatteryManager 後，我們就可以看到裡面會有四個比較重要的屬性：</p><pre><code class="javascript">&#123;  charging: true,             // 是否正在充電  chargingTime: 2940,         // 多少時間會滿電（單位：秒）  dischargingTime: Infinity,  // 多少時間會沒電（單位：秒）  level: 0.86                 // 目前的電量 （乘上100，即為百分比）&#125;</code></pre><p>其中比較特別的是 <code>chargingTime</code> 和 <code>dischargingTime</code>，若是目前裝置正在充電，那 <code>dischargingTime</code> 必為 <code>Infinity</code>，反之為充電時 <code>chargingTime</code> 必為 <code>Infinity</code>。</p><p>而除了上面這四個屬性之外呢，你還會看到四個事件屬性，讓你可以監聽不同的電量事件：</p><pre><code class="javascript">&#123;  onchargingchange: null,         // 監聽充電狀態  onchargingtimechange: null,     // 監聽滿電時間  ondischargingtimechange: null,  // 監聽沒電時間  onlevelchange: null             // 監聽電量&#125;</code></pre><p>只要像下面這樣撰寫的話就可以在電池狀態有變更的時候觸發 Callback:</p><pre><code class="javascript">navigator.getBattery().then(battery =&gt;  &#123;  battery.onchargingchange = function() &#123;    console.log(this.level)  &#125;  // 或是這樣寫也可以  battery.addEventListener(&quot;chargingchange&quot;, function &#123;    console.log(this.level)  &#125;)&#125;);</code></pre><br/><p>接下來我們只要透過以上這些屬性就可以做到這樣的一個小應用：</p><pre><code class="html">&lt;div class=&quot;battery-level&quot;&gt;&lt;/div&gt;&lt;div class=&quot;battery-wrap&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="javascript">const batteryLevel = document.querySelector(&quot;.battery-level&quot;);const batteryWrap = document.querySelector(&quot;.battery-wrap&quot;);navigator.getBattery().then((battery) =&gt; &#123;  const count = Math.floor(battery.level / 0.2);  const callback = function () &#123;    batteryLevel.textContent = battery.level * 100 + &quot;%&quot;;    batteryWrap.innerHTML = &quot;&quot;;    for (let i = 0; i &lt; count; i++) &#123;      const batteryLevel = document.createElement(&quot;div&quot;);      batteryLevel.setAttribute(&quot;class&quot;, &quot;battery&quot;);      batteryWrap.appendChild(batteryLevel);    &#125;  &#125;;  battery.onlevelchange = callback;  callback();&#125;);</code></pre><img src="battery.png" style="margin: 24px auto;" /><p><br/><br/></p><p>雖然 Battery API 並不是非常重要的功能，但其實瀏覽器能夠實作出來讓我們使用也是蠻方便的，畢竟要如何應用就要看大家的創意發揮，總比我們有想法卻沒有工具實踐來得好。習得 Battery API 後，你有什麼應用它的 idea 嗎？</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10269328">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;低電量～低～低～電量～ 呂士軒-低電量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天要分享的也是一個使用情境偏少的 API，但如果你有想要做移動端的應用的話，或許可以嘗試使用看看。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Battery&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / FullScreen</title>
    <link href="https://maxleebk.com/2021/09/18/webApi/webApi-5/"/>
    <id>https://maxleebk.com/2021/09/18/webApi/webApi-5/</id>
    <published>2021-09-18T06:38:00.000Z</published>
    <updated>2023-10-23T03:50:24.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一起來延伸視野，迎接更大的畫面吧！</p></blockquote><p>今天要介紹的 FullScreen API 會被忽略的原因可能是因會需要使用到它的情境比較少，但如果你撰寫網站的經驗有累積到一定程度的話，應該或多或少還是有需要它的可能性。雖然使用度沒有那麼高，不過我們還是把它整理到我們的系列文章中一起分享給大家吧。</p><hr><h2 id="FullScreen"><a href="#FullScreen" class="headerlink" title="FullScreen"></a>FullScreen</h2><br/><p>FullScreen API 主要是幫我們處理全螢幕顯示的功能，大部分都會運用在影片的呈現，像是內嵌的 Youtube 影片都會內建這個功能讓使用者切換，不過如果今天影片並沒有上傳 Youtube 的打算，或是你今天想要全螢幕顯示的是其他元素時，你就可以運用這個 API。</p><br/><h4 id="Document-fullscreenEnabled"><a href="#Document-fullscreenEnabled" class="headerlink" title="# Document.fullscreenEnabled"></a># Document.fullscreenEnabled</h4><p>這是一個唯讀屬性，用來確認目前的頁面是否允許我們開啟全螢幕顯示，所以在你操作之前，可以先確認該屬性是否為 <code>true</code>。</p><blockquote><p>絕大多數的大型企業，如 Facebook、Google 都會有自己嵌入 iframe 的政策，它們通常就會禁止你使用全螢幕來顯示。</p></blockquote><pre><code class="javascript">const enabled = document.fullscreenEnabled;</code></pre><p><br/><br/></p><h4 id="Document-fullscreen"><a href="#Document-fullscreen" class="headerlink" title="# Document.fullscreen"></a># Document.fullscreen</h4><p>這也是一個唯讀屬性，用來確認目前的頁面是否正處於全螢幕模式。</p><pre><code class="javascript">console.log(document.fullscreen);</code></pre><p><br/><br/></p><h4 id="Element-requestFullscreen"><a href="#Element-requestFullscreen" class="headerlink" title="# Element.requestFullscreen"></a># Element.requestFullscreen</h4><p>這個的話就是主要用來開啟全螢幕的 API 了，這裡的 Element 代表的是 DOM 元素，所以看到這裡可以發現 FullScreen API 並沒有提供一個全域物件，FullScreen API 反而是多個不同 methods 的總稱。</p><p>要使用的話就是先選定要全螢幕的元素，然後呼叫：</p><pre><code class="javascript">const images = document.querySelectorAll(&quot;img&quot;);images.forEach((img) =&gt; &#123;  img.addEventListener(&quot;click&quot;, function () &#123;    this.requestFullscreen();  &#125;);&#125;);</code></pre><p>這邊要注意的是 <code>requestFullscreen</code> 不能直接在頁面載入時呼叫，如果你這麼做會接到瀏覽器的錯誤警告，<code>API can only be initiated by a user gesture</code>，跟你說該 API 只能被使用者的手勢觸發，也就是說我們必須要透過事件的方式處理。</p><p>另外 <code>requestFullscreen</code> 其實會回傳 Promise，當全螢幕顯示完畢後就會被 <code>resolve</code>，所以你可以做到這樣的效果：</p><pre><code class="javascript">const images = document.querySelectorAll(&quot;img&quot;);images.forEach((img) =&gt; &#123;  img.addEventListener(&quot;click&quot;, function () &#123;    this.requestFullscreen().then(() =&gt; &#123;      this.src = &quot;ugly.jpg&quot;;    &#125;);  &#125;);&#125;);</code></pre><img src="fullscreen.gif" style="margin: 24px auto;" /><p><br/><br/></p><h4 id="Document-exitFullscreen"><a href="#Document-exitFullscreen" class="headerlink" title="# Document.exitFullscreen"></a># Document.exitFullscreen</h4><p>有開啟全螢幕，自然就會有關閉的部分，基本上使用者可以自己按 ESC 鍵離開全螢幕模式，不過你也可以透過 <code>exitFullscreen</code> 來觸發這件事，例如讓 Enter 鍵也可以關閉：</p><pre><code class="javascript">document.addEventListener(&quot;keydown&quot;, function (e) &#123;  if (e.keyCode == 13)    document.exitFullscreen().then(() =&gt; &#123;      alert(document.fullscreen);    &#125;);&#125;);</code></pre><p>當然了，<code>exitFullscreen</code> 也是會回傳 Promise 的，可以使用 <code>then</code> 來串接。不過要注意 <code>exitFullscreen</code> 這個 method 是在 Document 底下喔！</p><p><br/><br/></p><h4 id="Document-fullscreenElement"><a href="#Document-fullscreenElement" class="headerlink" title="# Document.fullscreenElement"></a># Document.fullscreenElement</h4><p><code>fullscreenElement</code> 是一個唯讀的屬性，它會指向目前正在全螢幕模式的元素。</p><pre><code class="javascript">const images = document.querySelector(&quot;img&quot;);images.addEventListener(&quot;click&quot;, function () &#123;  this.requestFullscreen().then(() =&gt; &#123;    console.log(this === document.fullscreenElement); // true  &#125;);&#125;);</code></pre><p><br/><br/></p><h4 id="瀏覽器支援度"><a href="#瀏覽器支援度" class="headerlink" title="# 瀏覽器支援度"></a># 瀏覽器支援度</h4><p>看完今天的介紹後，你可能覺得全螢幕是一個非常基本的功能，但其實 FullScreen API 在瀏覽器中的支援度還不是非常完整，所以當我們想要使用的時候可能要做一些額外的處理：</p><pre><code class="javascript">document.fullscreenEnabled =  document.fullscreenEnabled || document.mozFullScreenEnabled || document.documentElement.webkitRequestFullScreen;function requestFullscreen(element) &#123;  if (element.requestFullscreen) &#123;    element.requestFullscreen();  &#125; else if (element.mozRequestFullScreen) &#123;    element.mozRequestFullScreen();  &#125; else if (element.webkitRequestFullScreen) &#123;    element.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT);  &#125;&#125;if (document.fullscreenEnabled) &#123;  requestFullscreen(document.documentElement);&#125;</code></pre><p>目前是 IE11 和 Safari 還需要加上前綴詞，且另外 iphone 是完全不支援的，也希望之後 FullScreen API 的支援度可以越來越完善，我們前端工程師才不用寫這些冗長的 code。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10268620">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一起來延伸視野，迎接更大的畫面吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天要介紹的 FullScreen API 會被忽略的原因可能是因會需要使用到它的情境比較少，但如果你撰寫網站的經驗有累積到一定程度的話，應該或多或少還是有需要它的可能性</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / RequestAnimationFrame</title>
    <link href="https://maxleebk.com/2021/09/17/webApi/webApi-4/"/>
    <id>https://maxleebk.com/2021/09/17/webApi/webApi-4/</id>
    <published>2021-09-17T13:38:00.000Z</published>
    <updated>2023-10-23T03:50:24.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>別再用 <code>setTimeOut</code>、<code>setInterval</code> 寫動畫啦！</p></blockquote><p>如果你有用 js 寫過動畫，那通常你第一個想到的絕對會是 <code>setTimeOut</code> 或 <code>setInterval</code>，讓畫面元素可以在固定的時間間隔進行一點一點的變化，如此就可以形成動畫的效果。但其實這兩個計時器其實都有一些不為人知的小缺點，而今天要介紹的 RequestAnimationFrame 可以讓你不需要擔心這些。</p><hr><h2 id="RequestAnimationFrame"><a href="#RequestAnimationFrame" class="headerlink" title="RequestAnimationFrame"></a>RequestAnimationFrame</h2><br/><p>在正式介紹 RequestAnimationFrame 之前我們要先來了解一些相關概念以及 <code>setTimeOut</code> 和 <code>setInterval</code> 到底有什麼缺點。</p><br/><h4 id="螢幕更新頻率"><a href="#螢幕更新頻率" class="headerlink" title="# 螢幕更新頻率"></a># 螢幕更新頻率</h4><p>大家應該知道，其實動畫就是一連串的靜態畫面以一定的頻率連續顯示，讓人的眼睛及大腦可以腦部成一個動態過程，而這個「一定的頻率」到底是多少呢？以現在這個影音世代來說，每秒六十張影格是一個可以讓動畫看起來最順暢的。</p><p>只也就是為什麼現代螢幕的畫面更新率至少都有 60Hz (每秒 60 幀)，當然了，不同的設備、網路環境等因素的影響，螢幕更新率不會都是 60Hz。</p><p><br/><br/></p><h4 id="setTimeOut"><a href="#setTimeOut" class="headerlink" title="# setTimeOut"></a># setTimeOut</h4><p>如果依照每秒 60 幀的需求來使用 <code>setTimeOut</code> 來撰寫動畫的話，大致上都會是這樣寫的：</p><pre><code class="javascript">let timerID;const figure = document.querySelector(&quot;#figure&quot;);function moveFigure() &#123;  figure.style.left = figure.offsetLeft + 5 + &quot;px&quot;;  timerID = setTimeout(moveFigure, 1000 / 60);&#125;moveFigure(); // 動畫開始clearTimeout(timerID); // 動畫停止</code></pre><p>我們透過遞迴的方式不斷的呼叫 <code>setTimeout</code> 來幫我們移動元素，而 <code>1000 / 60</code> 就是用來模擬 60Hz 的頻率的。不過使用這樣的方法會有以下缺點。</p><p><strong>1. Callback 執行通常會晚一點</strong><br>由於 <code>setTimeout</code> 中的 callback 要等到計時完成後才會被放到佇列（queue）中等待執行，這時候如果堆疊中（stack）還有其他工作項目的話，就必須要等待一些額外的時間才會執行。如果想知道更多細節的話，可以去了解 Event Loop。</p><p><strong>2. 與螢幕更新頻率對應不上</strong><br>前面說過，很多因素都會影響螢幕更新率，所以他是一個浮動的頻率，但 <code>setTimeout</code> 只能設定固定頻率，這時候如果跟更新率對應不上，可能動畫就會掉幀的可能。</p><p><br/><br/></p><h4 id="setInterval"><a href="#setInterval" class="headerlink" title="# setInterval"></a># setInterval</h4><p>相比 <code>setTimeOut</code> ，可能更多人會用 <code>setInterval</code>，因為它自己就可以不斷重複執行 callback，不用搞什麼遞迴：</p><pre><code class="javascript">const figure = document.querySelector(&quot;#figure&quot;);function moveFigure() &#123;  figure.style.left = figure.offsetLeft + 5 + &quot;px&quot;;&#125;let timerID = setInterval(moveFigure, 1000 / 60);moveFigure(); // 動畫開始clearInterval(timerID); // 動畫停止</code></pre><p>其實除了第一次執行時也會延遲之外，與 <code>setTimeOut</code> 效果沒什麼太大差別，所以想當然的 <code>setTimeOut</code> 有的缺點它也都有，而且還額外多了幾個：</p><p><strong>1. 忽略錯誤</strong><br>非常可怕的缺點，儘管你的 Callback 已經發生壞掉了，<code>setInterval</code> 也會義無反顧地執行下去。</p><p><strong>2. Callback 有可能被取消</strong><br>前面有說過當計時完成後 callback 會被放進佇列中，當堆疊空閒時就會被抓出來執行，但要堆疊特別繁忙時，也是有可能連第一次的 callback 都還沒被執行，第二次的 callback 就又被放進佇列了，這時候等堆疊空閒時，兩次 callback 就會幾乎同時執行。</p><pre><code class="javascript">// 堆疊再在處理其他函式stack = [&quot;其他工作項目&quot;];queue = [];// 第一次的 setInterval 觸發stack = [&quot;其他工作項目&quot;];queue = [&quot;第一次 callback&quot;];// 第二次的 setInterval 觸發stack = [&quot;其他工作項目&quot;];queue = [&quot;第一次 callback&quot;, &quot;第二次 callback&quot;];// 堆疊空閒了，這時候第一次 callback 會被執行，第二次則緊跟在後。stack = [&quot;第一次 callback&quot;];queue = [&quot;第二次 callback&quot;];</code></pre><p>為了防止這樣的情發生，其實 JS 引擎會在佇列已經有該 SetInterval 的 Callback 的時候，把後面這一次的 Callback 給取消掉。</p><p><br/><br/></p><h4 id="RequestAnimationFrame-1"><a href="#RequestAnimationFrame-1" class="headerlink" title="# RequestAnimationFrame"></a># RequestAnimationFrame</h4><p>但如果使用今天的主角 RequestAnimationFrame 來製作動畫，那上述缺點就通通沒有了，因為它會自動與螢幕的更新頻率同步，以此來避免掉幀的問題。</p><pre><code class="javascript">let requestID;const figure = document.querySelector(&quot;#figure&quot;);function moveFigure() &#123;  figure.style.left = figure.offsetLeft + 5 + &quot;px&quot;;  requestID = requestAnimationFrame(moveFigure, 1000 / 60);&#125;moveFigure(); // 動畫開始cancelAnimationFrame(requestID); // 動畫停止</code></pre><p><br/><br/></p><p>如果大家有興趣的話，可以把我們今天的三段 code 拿去試試看，我個人是可以感受到非常明顯的滑順感落差，RequestAnimationFrame 所製作出來的動畫在視覺上會比較舒服。如果你也有同感的話，你可以開始考慮使用它了！</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10267420">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;別再用 &lt;code&gt;setTimeOut&lt;/code&gt;、&lt;code&gt;setInterval&lt;/code&gt; 寫動畫啦！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你有用 js 寫過動畫，那通常你第一個想到的絕對會是 &lt;code&gt;setTimeOu</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / CreateDocumentFragment</title>
    <link href="https://maxleebk.com/2021/09/16/webApi/webApi-3/"/>
    <id>https://maxleebk.com/2021/09/16/webApi/webApi-3/</id>
    <published>2021-09-16T06:38:00.000Z</published>
    <updated>2023-10-23T03:50:24.668Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>除了功能完善，有時候效能也該一併考慮。</p></blockquote><p>今天要介紹的是 CreateDocumentFragment，它隸屬於 <code>document</code> 物件底下，而 Document 所指的就是整個網頁文件，也是節點樹（DOM tree）的一個進入點。簡單的說，Document 提供了一些 methods 讓我們去操作整個網頁文件，像是 <code>document.querySelector</code> 就是我們經常使用，拿來遍歷整個 DOM tree 並找到我們指定的元素。</p><hr><h2 id="CreateDocumentFragment"><a href="#CreateDocumentFragment" class="headerlink" title="CreateDocumentFragment"></a>CreateDocumentFragment</h2><br/><p>先直接說明 CreateDocumentFragment 的功能好了，它可以幫我們創建一個 DocumentFragment，而 DocumentFragment 就如同一個虛擬的文件片段，就算對其進行節點操作時並不會造成瀏覽器回流（reflow），也就是不會耗費資源來進行畫面更新，這也就是它最大的優點。</p><p>如果你還沒接觸過前端框架的話，那相信你在遇到需要新增動態元素至畫面上時你通常會有下面這幾個方法：</p><br/><h4 id="innerHTML"><a href="#innerHTML" class="headerlink" title="# innerHTML"></a># innerHTML</h4><p>首先是比較基礎的方式是用，也就是用字串的方式來設定某個元素的 HTML 內容，使用起來非常間單，不過如果想要塞入的內容結構上比較複雜的話那就會非常麻煩了（字串裡可是沒有編輯器提示的啊～）。</p><pre><code class="javascript">let list = [&quot;egg&quot;, &quot;milk&quot;, &quot;sugar&quot;, &quot;flour&quot;];let htmlContent = &quot;&quot;;for (let i = 0; i &lt; list.length; i++) &#123;  htmlContent += `&lt;li&gt;$&#123;list[i]&#125;&lt;/li&gt;`;&#125;const ul = document.querySelector(&quot;ul&quot;);ul.innerHTML += htmlContent;</code></pre><p>還有一點比較麻煩的是，在父元素已經有部分子元素情況下使用 <code>innerHTML</code>，會很難從中插入新的元素，會需要其他額外的處理，反而會造成程式碼很冗長，所以它大部分都不會是我們的最佳解決方案。</p><pre><code class="html">&lt;ul&gt;  &lt;li&gt;我是本來就在的元素&lt;/li&gt;  &lt;li&gt;我是本來就在的元素&lt;/li&gt;  &lt;!--   如果你的新元素要放在這裡就會很麻煩 --&gt;  &lt;li&gt;我是本來就在的元素&lt;/li&gt;  &lt;li&gt;我是本來就在的元素&lt;/li&gt;&lt;/ul&gt;</code></pre><p><br/><br/></p><h4 id="appendChild"><a href="#appendChild" class="headerlink" title="# appendChild"></a># appendChild</h4><p>相比 <code>innerHTML</code>，<code>appendChild</code> 應該才是更常使用的方法：</p><pre><code class="javascript">let list = [&quot;egg&quot;, &quot;milk&quot;, &quot;sugar&quot;, &quot;flour&quot;];const ul = document.querySelector(&quot;ul&quot;);for (let i = 0; i &lt; list.length; i++) &#123;  const li = document.createElement(&quot;li&quot;);  li.textContent = list[i];  ul.appendChild(li);&#125;</code></pre><p>這種方式就算想要創建比較複雜的 HTML 結構也可以寫得比較有系統性，程式碼也有比較好的易讀性及維護性，而且其實除了 <code>appendChild</code>，你也可以用 <code>insertBefore</code> 選擇新元素要注入的位置。</p><pre><code class="html">&lt;ul&gt;  &lt;li&gt;我是本來就在的元素&lt;/li&gt;  &lt;!--  新元素將會放在這邊 --&gt;  &lt;li&gt;我是本來就在的元素&lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code class="javascript">let list = [&quot;egg&quot;, &quot;milk&quot;, &quot;sugar&quot;, &quot;flour&quot;];const ul = document.querySelector(&quot;ul&quot;);const last_li = ul.querySelector(&quot;li:last-child&quot;);for (let i = 0; i &lt; list.length; i++) &#123;  const new_li = document.createElement(&quot;li&quot;);  new_li.textContent = list[i];  ul.insertBefore(new_li, last_li);&#125;</code></pre><p>不過這樣的方式有個致命的缺點，每次迴圈在執行時都會直接在目前的 DOM tree 中塞入新元素時，此時會促使網頁更新畫面，這樣其實或多或少會引響效能。</p><p><br/><br/></p><h4 id="createDocumentFragment"><a href="#createDocumentFragment" class="headerlink" title="# createDocumentFragment"></a># createDocumentFragment</h4><p>但如果使用 <code>createDocumentFragment</code> 可就不一樣了，我們是在一個虛擬的文件片段中加入新元素，這樣就完全不會造成畫面的更新，因為它根本就沒渲染在畫面上。</p><pre><code class="javascript">let list = [&quot;egg&quot;, &quot;milk&quot;, &quot;sugar&quot;, &quot;flour&quot;];const ul = document.querySelector(&quot;ul&quot;);const fragment = document.createDocumentFragment();for (let i = 0; i &lt; list.length; i++) &#123;  const li = document.createElement(&quot;li&quot;);  li.textContent = list[i];  fragment.appendChild(li);&#125;ul.appendChild(fragment);</code></pre><p>當我們將全部想要新增的元素都加進 DocumentFragment 後，再一次性的塞進我們真正想要放的位置就可以了，整體的感覺會很像 <code>innerHTML</code>，但 <code>innerHTML</code> 在設定後其實還多了一個字串轉換成節點的過程，所以 createDocumentFragment 在效能層面來說真的是比較友善。</p><blockquote><p>不過現在的瀏覽器似乎對於短時間內的連續 DOM 操作都有做一些最佳化，不至於讓效能差到太多，但使用 CreateDocumentFragment 其實也可以讓 「不斷插入」 變成 「一次插入」，在程式碼的目的表達上也會更清楚。</p></blockquote><p><br/><br/></p><p>今天介紹的 CreateDocumentFragment 雖然不是什麼功能華麗的 API，但是非常建議大家可以使用看看，儘管能提升的效能或許不多，但這一點點很有可能就是你跟其他人的差異喔～</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10266640">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;除了功能完善，有時候效能也該一併考慮。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天要介紹的是 CreateDocumentFragment，它隸屬於 &lt;code&gt;document&lt;/code&gt; 物件底下，而 Document 所指的就是整個網頁</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / Console</title>
    <link href="https://maxleebk.com/2021/09/15/webApi/webApi-2/"/>
    <id>https://maxleebk.com/2021/09/15/webApi/webApi-2/</id>
    <published>2021-09-15T01:38:00.000Z</published>
    <updated>2023-10-23T03:50:24.560Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>雖然一招 <code>console.log</code> 就能打遍天下無敵手，但你其實有更好的選擇。</p></blockquote><p>我知道我知道，這次的主題是「被忽略」的 Web API，Console 顯然不會是那個被大家忽略的，它可是各位 debug 的好夥伴，但你知道 Console 底下其實可不是只有 <code>console.log</code> 而已，還有很多更方便的 API 可以使用。</p><hr><h2 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h2><br/><p>Console 這個物件提供了我們操作瀏覽器中除錯控制台（debugging console）的使用權，當按下 F12 後開啟瀏覽器的 Developers Tools，就可以看到 Console 面板，那就是除錯控制台啦。</p><p>而大家熟知的 <code>console.log</code> 就是在這個面板中打印出一筆紀錄訊息（log），但每當 Console 面板中的訊息五花八門越來越多時，就會常常眼花撩亂，反而阻礙我們進行除錯或開發，所以下面就介紹一些其實很好用但被使用度卻偏低的幾個 API。</p><br/><h4 id="console-count"><a href="#console-count" class="headerlink" title="# console.count"></a># console.count</h4><p>顧名思義，<code>count</code> 當然是拿來計數的，每當我們呼叫一次 <code>console.count</code> 就會進行一次計數。</p><pre><code class="javascript">console.count(); // default: 1console.count(); // default: 2console.count(); // default: 3</code></pre><p>這樣的功能我偶爾會在開發 Vue 專案的時候，用在元件的 update 的生命週期裡，可以觀察看看元件在實際操作前是否有過多的異常更新。</p><p>另外可以發現上面印出的內容除了數字不斷增加之外，還多了一個 <code>default</code> 的字串，這是因為 <code>console.count</code> 可以傳入一個參數來區隔不同的計數器，而這個參數預設值為 <code>default</code>。</p><pre><code class="javascript">console.count(); // default: 1console.count(&quot;foo&quot;); // foo: 1console.count(); // default: 2console.count(&quot;bar&quot;); // bar: 1console.count(&quot;foo&quot;); // foo: 2</code></pre><p>需要的話你還可以這麼做…</p><pre><code class="javascript">let zoo = [&quot;lion&quot;, &quot;tiger&quot;, &quot;zebra&quot;, &quot;lion&quot;, &quot;zebra&quot;];for (let i = 0; i &lt; zoo.length; i++) &#123;  console.count(zoo[i]);&#125;// lion: 1// tiger: 1// zebra: 1// lion: 2// zebra: 2</code></pre><p><br/><br/></p><h4 id="console-time-console-timeEnd"><a href="#console-time-console-timeEnd" class="headerlink" title="# console.time / console.timeEnd"></a># console.time / console.timeEnd</h4><p>這一組 API 主要可以讓你得知一段程式片段執行的時間，當你呼叫 <code>console.time</code> 時，瀏覽器會開始幫我們計時，直到你呼叫 <code>console.timeEnd</code>，Console 面板便會打印出這兩個 API 被呼叫的的期間所花費的毫秒數。</p><pre><code class="javascript">console.time();setTimeout(() =&gt; &#123;  console.timeEnd();&#125;, 500);// default: 505.10107421875 ms</code></pre><p>其實透過上面這段程式碼就可以發現，<code>setTimeout</code> 其實並不是非常精準，只不過這樣的誤差可以省略不計，除此之外，<code>default</code> 字串又再次出現了，可想而知 <code>console.time</code> 是可以透過傳參來區隔計時器的。</p><pre><code class="javascript">console.time(&quot;bar&quot;);console.time(&quot;foo&quot;);setTimeout(() =&gt; &#123;  console.timeEnd(&quot;bar&quot;);&#125;, 500);setTimeout(() =&gt; &#123;  console.timeEnd(&quot;foo&quot;);&#125;, 1000);// bar: 501.56689453125 ms// foo: 1004.574951171875 ms</code></pre><p>偶爾你可能會遇到同個問題有不同作法，也許你可以考慮看看用 <code>console.time</code> 和 <code>console.timeEnd</code> 來測試哪一種解決方案比較省時。</p><p><br/><br/></p><h4 id="console-group-console-groupEnd"><a href="#console-group-console-groupEnd" class="headerlink" title="# console.group / console.groupEnd"></a># console.group / console.groupEnd</h4><p>偶爾我們 <code>log</code> 出的訊息或資訊非常的多，一不小心就會迷失在 Console 面板中，尤其是在 <code>function</code> 層級很複雜的時候，一時半刻的也分辨不出哪些訊息是哪邊印出來的，那這組 API 就可以派上用場了。</p><pre><code class="javascript">console.group(&quot;level_1&quot;); // 開啟 group level_1console.log(&quot;1-1&quot;); // 在 level_1 中打印  1-1console.group(&quot;level_2&quot;); // 在 level_1 中開啟 group level_2console.log(&quot;2-1&quot;); // 在 level_2 中打印  2-1console.group(&quot;level_3&quot;); // 在 level_2 中開啟 group level_3console.log(&quot;3-1&quot;); // 在 level_3 中打印  3-1console.groupEnd(); // 關閉 level_3console.log(&quot;2-2&quot;); // 在 level_2 中打印  2-2console.groupEnd(); // 關閉 level_2console.log(&quot;1-2&quot;); // 在 level_1 中打印  1-2</code></pre><img src="console-group.png" style="margin: 24px auto;" /><p>透過上面的程式碼打印出的結果就會像是這樣，當你開啟了一個 <code>group</code> 後，之後的打印內容都會歸類在該 <code>group</code> 底下，並且你可以進行收合，讓 Console 面板的訊息可以更乾淨更有系統。例如下面這段程式碼，相比直接印出來，在前後進行 <code>group</code> 的操作，應該是更能看出程式順序。</p><pre><code class="javascript">for (let i = 1; i &lt;= 5; i++) &#123;  for (let j = 1; j &lt;= 3; j++) &#123;    console.log(j);  &#125;&#125;// this is betterfor (let i = 1; i &lt;= 3; i++) &#123;  console.group(&quot;level&quot; + i);  for (let j = 1; j &lt;= 3; j++) &#123;    console.log(j);  &#125;  console.groupEnd();&#125;</code></pre><img src="console-group2.png" style="margin: 24px auto;" /><p><br/><br/></p><h4 id="console-table"><a href="#console-table" class="headerlink" title="# console.table"></a># console.table</h4><p><code>table</code> 這個 API 好不好用可能要看情境或因人而異，它主要的功能是可以將陣列或物件打印成一個表格，讓你在觀看時可以更一目了然。</p><pre><code class="javascript">let badminton_scoring = &#123;  taiwan: 21,  china: 12,&#125;;console.table(badminton_scoring);</code></pre><img src="console-table.png" style="margin: 24px auto;" /><pre><code class="javascript">let olympics = [  [&quot;gold&quot;, 2],  [&quot;silver&quot;, 4],  [&quot;copper&quot;, 6],];console.table(olympics);</code></pre><img src="console-table2.png" style="margin: 24px auto;" /><p>可以看到，利用 <code>console.table</code> 把陣列或物件打印就會是上面這樣的效果，另外要提的是，如果你打印的不是陣列或物件，那 <code>console.table</code> 就跟 <code>console.log</code> 沒有什麼不同。</p><p>我個人認為，這個 API 比較適合剛接觸程式語言的朋友，如果你對陣列或物件還不太了解，利用 <code>console.table</code> 把他們印出來，說不定能讓你更好理解。</p><p><br/><br/></p><p>不曉得各位是否有使用過這些 API 的經驗呢？如果還沒有，或許之後當你想要 <code>console.log</code> 的時候，可以再多想幾秒鐘，上面這些 API 說不定是你更好的選擇。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10265898">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;雖然一招 &lt;code&gt;console.log&lt;/code&gt; 就能打遍天下無敵手，但你其實有更好的選擇。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我知道我知道，這次的主題是「被忽略」的 Web API，Console 顯然不會是那個被大家忽略的，它</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / 前言</title>
    <link href="https://maxleebk.com/2021/09/14/webApi/webApi-1/"/>
    <id>https://maxleebk.com/2021/09/14/webApi/webApi-1/</id>
    <published>2021-09-14T01:29:00.000Z</published>
    <updated>2023-10-23T03:50:24.536Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Web API – Application Programming Interface for The Web，翻譯成中文就是「給網頁使用的應用程序介面」</p></blockquote><p>相信對於開發網頁的前端工程師來說，Web API 是在熟悉不過，就算你沒聽過或不曉得 Web API 是什麼，你也絕對使用過它。</p><p>舉幾個例子：<code>console.log</code>、<code>setTimeOut</code>、<code>setInterval</code>，這些其實都是所謂的 Web API，它們並非是 JavaScript 的原生 method。</p><hr><h2 id="Web-API-到底是什麼？"><a href="#Web-API-到底是什麼？" class="headerlink" title="Web API 到底是什麼？"></a>Web API 到底是什麼？</h2><br/><p>剛剛上面提到的常用 method，它們其實來自於 <code>window</code> 這個全域物件，實際上你使用的是 <code>window.console.log</code>，只不過 <code>window</code> 是被允許省略的。而這個神奇的 <code>window</code> 其實是由瀏覽器提供給我們的，連平常我們常常使用的 <code>document</code> 物件也是所屬於 <code>window</code> 底下，如果你有寫過 Node.js 的話，就可以確認我說的是真的，因為在 Node.js 的環境下是找不到 <code>window</code>，取而代之的是 <code>global</code> 物件。</p><p>而這次的系列文章就是想要介紹那些深埋在 <code>window</code> 裡，你不曾發覺或是常常遺忘的 API，或許在你開發網頁的過程中有遇過一些特殊需求，當下雖然用了一些管用手法解決，但看完這次的系列文章，你可能會有新的靈感或發現。</p><img src="web-api.png" style="max-width: 500px; margin: 24px auto;" /><h4 id="尷尬的痛點"><a href="#尷尬的痛點" class="headerlink" title="# 尷尬的痛點"></a># 尷尬的痛點</h4><p>由於 <code>window</code> 是瀏覽器提供給我們的，所以當中的內容完全取決於使用者所使用的瀏覽器。不幸的是，Web API 其實必沒有被統一標準化，有些甚至還在實踐階段，或是有一些還有裝置的限制，也因為如此，並非所有瀏覽器都會把全部的 Web API 實踐出來，所以在我們使用之前可以先去看看 <strong><a href="https://caniuse.com/">瀏覽器的支援度</a></strong> 。</p><hr><h2 id="系列內容"><a href="#系列內容" class="headerlink" title="系列內容"></a>系列內容</h2><br/><p>如果要細數的話 Web API 其實以上千個，不過我們常用的卻不多，因為其實有一大部分的 API 並沒有什麼實際功能性，不過呢，這次想跟各位分享的是一些非常實用但使用度缺相對較低的 Web API。</p><p>另外想要聲明的事，有些 Web API 比較龐大複雜，大到可以單獨寫成一個新的系列文章了，像是 Canvas、WebSocket..等等，而這些就不會是我們系列文章的範疇，這次會分享的是一些比較間單，大家可以快速上手使用的內容。</p><br/><ol><li>Console</li><li>CreateDocumentFragment</li><li>RequestAnimationFrame</li><li>FullScreen</li><li>Battery</li><li>ImageCapture</li><li>DesignMode</li><li>Selection</li><li>Clipboard</li><li>History</li><li>SessionStorage</li><li>CustomEvent</li><li>PostMessage</li><li>MessageChannel</li><li>BroadcastChannel</li><li>RequestIdleCallback</li><li>MutationObserver</li><li>ResizeObserver</li><li>GetBoundingClientRect</li><li>IntersectionObserver</li><li>ScrollIntoView</li><li>Drag &amp; Drop</li><li>Share</li><li>Notification</li><li>Geolocation</li></ol><br/><p>以上這些 Web API 就會在我們這次的系列文章中介紹到，部分 API 也還會再額外拉一個篇章來示範一些實際應用，讓大家可以更了解到它們的實際作用與功能。那接下來的三十天就期待與大家一起挖掘 「那些被忽略但很好用的 Web API」囉～</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10265151">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Web API – Application Programming Interface for The Web，翻譯成中文就是「給網頁使用的應用程序介面」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相信對於開發網頁的前端工程師來說，Web API </summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
    <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 尾聲</title>
    <link href="https://maxleebk.com/2020/10/14/highchart/highcharts-30/"/>
    <id>https://maxleebk.com/2020/10/14/highchart/highcharts-30/</id>
    <published>2020-10-14T05:20:00.000Z</published>
    <updated>2023-10-23T03:50:24.500Z</updated>
    
    <content type="html"><![CDATA[<p>終於，花了一個月的時間，我們從零開始認識 Highcharts 到現在已經能夠配合 Vue.js 一同運用，希望這次的系列文章能幫助到各位，如果內容與實際使用上有出入也歡迎大家幫忙指正，那今天的章節就讓我花點時間說說自己的參賽感言吧。</p><hr><h2 id="選題動機"><a href="#選題動機" class="headerlink" title="選題動機"></a>選題動機</h2><br/><p>其實我自己也是個很 ju 的前端 junior，以往也從未使用過任何相關的 library，會接觸到 Highcharts 純粹是因為工作上剛好接到了個報表呈現的專案，而且技術選用也是由前輩決定的，所以完全是「被學習」 Highcharts。</p><p>不過好在 Highcharts 真的蠻容易上手的，花了不到半天的時間就可以畫出一個完整性很高的圖表，但為了讓產品的功能更豐富，在將近半年的開發時間中，PM 總是有許多天馬行空的想法，有些功能總感覺可以做到，卻因為屬性太多不知從何下手，Google 後大部分也都是英文討論串，大大增加了我這個英文苦手的開發時間。</p><p>所以也是因為自己經歷了這些學習過程，才希望可以透過參加鐵人賽的機會來試著記錄我這半年來累積的經驗，或多或少可以幫助想要接觸 Highcharts 的朋友。</p><br/><img src="learning.png" style="max-width: 400px; margin: 16px auto 0;" /><hr><h2 id="參賽心得"><a href="#參賽心得" class="headerlink" title="參賽心得"></a>參賽心得</h2><br/><p>這次是第一次參加鐵人賽，也因為自己的心態是寧可不參加也不要未完賽，所以剛開始很是猶豫要不要參賽，對於要連續寫三十篇文章實在沒什麼信心，一路猶豫到了九月初才下定決心，堅持每天至少寫一篇文章，不知不覺就在開賽前夕累積了十篇左右。</p><p>而後來也才發現，其實最困難的是「下定決心」的那一刻，後面反而是習慣成自然，下班到家就是會自動打開電腦完成文章。</p><p>另外收穫最大的是，自己為了讓文章內容更豐富，所以花了很多時間在研究每個屬性的特性並且撰寫範例，過程中其實也領悟了很多先前沒有察覺的做法或技巧，所以自己在這次參賽中也算是有所成長吧。</p><img src="write.png" style="max-width: 400px; margin: 16px auto 0;" /><hr><h2 id="未來期許"><a href="#未來期許" class="headerlink" title="未來期許"></a>未來期許</h2><br/><p>其實 Highcharts 不只有這次系列文章中介紹的基本圖表，還有很多特殊種類、3D 圖表等等，甚至還有股票專用的 Highcharts Stock、繪製甘特圖的 Highcharts Gantt 以及繪製地圖的 Highcharts Maps，這些延伸模組目前也都在學習摸索中，也希望自己可以在熟悉了之後二次參賽並向大家介紹。</p><p><img src="map.png" alt=""></p><br/><p>那最後也要非常感謝各位願意花時間閱讀我的文章，希望對大家有所幫助，未來有機會的話也期待再次於鐵人賽中和大家相見。</p><blockquote><p>所有系列文章也同步發表於個人部落格：<a href="https://maxleebk.com/">https://maxleebk.com/</a></p></blockquote><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10253136">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;終於，花了一個月的時間，我們從零開始認識 Highcharts 到現在已經能夠配合 Vue.js 一同運用，希望這次的系列文章能幫助到各位，如果內容與實際使用上有出入也歡迎大家幫忙指正，那今天的章節就讓我花點時間說說自己的參賽感言吧。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;選題</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / Vue 做個記帳本 (下)</title>
    <link href="https://maxleebk.com/2020/10/13/highchart/highcharts-29/"/>
    <id>https://maxleebk.com/2020/10/13/highchart/highcharts-29/</id>
    <published>2020-10-13T01:35:00.000Z</published>
    <updated>2023-10-23T03:50:24.496Z</updated>
    
    <content type="html"><![CDATA[<p>昨天已經將記帳本打造出一個基本雛形了，但似乎功能並不是很多，純粹就只是看到消費的金額和走向而已，所以我們今天來利用圖表的「事件屬性」搭配 Vue 的 <code>emit</code> 來為記帳本新增一個查看明細的功能吧。</p><hr><h2 id="記帳本實作"><a href="#記帳本實作" class="headerlink" title="記帳本實作"></a>記帳本實作</h2><p>就像下圖所示，這次要做到的功能是希望能點擊「數據列」時，在下方顯示當天的消費明細以及總金額，讓我們的記帳本有更完整的功能。</p><p>而開發的邏輯是透過點擊拿到數據點的日期時間戳，然後利用父子層的溝通來將這個時間戳傳遞到一個新的「清單元件」中，清單元件會拿這個時間戳去打 Json-Server 的 API，取得該日期的帳目定顯示於畫面上。那就馬上動手開發吧！</p><img src="emit.gif" style="max-width: 800px; margin: 16px auto 0;" /><br/><h4 id="1-設定事件屬性"><a href="#1-設定事件屬性" class="headerlink" title="1.設定事件屬性"></a>1.設定事件屬性</h4><p>我們在圖表元件 <code>LedgerChart.vue</code> 中新增一個 Method，並將它作為圖表 <code>click</code> 事件的回呼函式，而由於回呼函式可以接到 Highcharts 的 <code>event</code> 物件，我們就可以拿到時間戳，並利用 <code>$emit</code> 來傳至 <code>App.vue</code>。</p><pre><code class="javascript">methods: &#123;  selectDate() &#123;    this.$emit(&quot;selectDate&quot;, event.point.category)  &#125;&#125;</code></pre><pre><code class="javascript">// computedoptions() &#123;  let options = Object.assign(this.chartOptions, &#123;&#125;);  options.series = this.seriesData;  options.xAxis.categories = this.xAxisCategories;  options.plotOptions.series.events = &#123;    click: this.selectDate  &#125;;  return options;&#125;</code></pre><p><br/><br/></p><h4 id="2-父層監聽自定義事件"><a href="#2-父層監聽自定義事件" class="headerlink" title="2.父層監聽自定義事件"></a>2.父層監聽自定義事件</h4><p>剛剛在 <code>LedgerChart.vue</code> 有 <code>emit</code> 了自定義事件，現在要在父層來監聽接收這事件，這樣每次點擊數據列就都會更新 <code>date</code> 了。</p><pre><code class="vue">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;LedgerForm /&gt;    &lt;LedgerChart @selectDate=&quot;selectDate&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import LedgerForm from &quot;./components/LedgerForm&quot;import LedgerChart from &quot;./components/LedgerChart&quot;export default &#123;  name: &quot;App&quot;,  components: &#123;    LedgerForm,    LedgerChart  &#125;,  data() &#123;    return &#123;      date: 0    &#125;  &#125;,  methods: &#123;    selectDate(val) &#123;      this.date = val;    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><p><br/><br/></p><h4 id="3-清單元件-LedgerList-vue"><a href="#3-清單元件-LedgerList-vue" class="headerlink" title="3.清單元件 - LedgerList.vue"></a>3.清單元件 - LedgerList.vue</h4><p>再來就是下方要顯示的明細清單了，檔案內容如下，主要是透過接收一個 <code>date</code> 的 Prop，每當它更新時就會觸發 <code>watch</code>，然後利用 Json-Server 的 Filter 功能來抓出「當天」的資料，如此就能將消費明細顯示在畫面上了。</p><blockquote><p>明細上方的日期和總金額透過 <code>computed</code> 計算即可得到，因為不是重點，這邊就將程式碼省略了。</p></blockquote><pre><code class="vue">&lt;template&gt;  &lt;div v-if=&quot;date&quot;&gt;    &lt;div class=&quot;ledger-item&quot; v-for=&quot;item in fetchData&quot; :key=&quot;item.id&quot;&gt;      &lt;div&gt;&#123;&#123; item.category &#125;&#125;&lt;/div&gt;      &lt;div&gt;&#123;&#123; item.description &#125;&#125;&lt;/div&gt;      &lt;div&gt;NT$ &#123;&#123; item.amount &#125;&#125;&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    props: &#123;      date: &#123;        type: Number,        default: 0      &#125;    &#125;,    data() &#123;      return &#123;        fetchData: []      &#125;    &#125;,    watch: &#123;      date(val) &#123;        this.axios.get(`http://localhost:3000/accounts?date=$&#123;val&#125;`)          .then((response) =&gt; &#123;            this.fetchData = response.data;          &#125;);      &#125;    &#125;  &#125;&lt;/script&gt;</code></pre><p><br/><br/></p><h4 id="4-掛載元件並傳入-Prop"><a href="#4-掛載元件並傳入-Prop" class="headerlink" title="4.掛載元件並傳入 Prop"></a>4.掛載元件並傳入 Prop</h4><p>清單元件完成後就將他掛到 <code>App.vue</code> 上了，並且記得要把剛剛的 <code>date</code> 傳進清單元件中。如此一來我們就成功增加了查看明細的新功能囉！</p><pre><code class="html">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;LedgerForm /&gt;    &lt;LedgerChart @selectDate=&quot;selectDate&quot; /&gt;    &lt;LedgerList :date=&quot;date&quot; /&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p><br/><br/></p><p>花了四天的時間我們從熟悉 Highcharts-Vue 的使用到最後開發出一個小作品，相信大家應該有感受到 Highcharts 與前端框架的配合是多麼的方便好用。不過隨著記帳本的完成，這個系列文章也即將告一段落了，明天最後一篇文章則會做個系列的總結，並講講我的參賽心得。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10252727">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天已經將記帳本打造出一個基本雛形了，但似乎功能並不是很多，純粹就只是看到消費的金額和走向而已，所以我們今天來利用圖表的「事件屬性」搭配 Vue 的 &lt;code&gt;emit&lt;/code&gt; 來為記帳本新增一個查看明細的功能吧。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;記帳本實作&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / Vue 做個記帳本 (上)</title>
    <link href="https://maxleebk.com/2020/10/12/highchart/highcharts-28/"/>
    <id>https://maxleebk.com/2020/10/12/highchart/highcharts-28/</id>
    <published>2020-10-12T01:45:00.000Z</published>
    <updated>2023-10-23T03:50:24.492Z</updated>
    
    <content type="html"><![CDATA[<p>既然已經掌握了 Highcharts-Vue 的基本使用技巧，那今明兩天打算帶大家來實作一個「記帳本」，用一個比較完整的應用來完結這個系列，也算是一個學習成果的回顧。</p><hr><h2 id="記帳本實作"><a href="#記帳本實作" class="headerlink" title="記帳本實作"></a>記帳本實作</h2><p>如下圖所示，第一天打算先把我們記帳本的介面、圖表及資料串接完成，畫面大致如上，上方為新增帳目的表單元件，下方則是顯示每日消費金額的柱狀圖，樣式的話大家可以自由發揮，文章中將只會說明程式邏輯的部分。</p><img src="case.png" style="max-width: 800px; margin: 16px auto 0;" /><br/><h4 id="1-安裝-Json-Server"><a href="#1-安裝-Json-Server" class="headerlink" title="1.安裝 Json-Server"></a>1.安裝 Json-Server</h4><p>為了可以讓記帳本真的可以記帳，我們會需要資料庫來紀錄帳目，而我選擇使用的是 Json-Server，它讓我們可以用一個 Json 檔來作為簡易的資料庫，而且內建基本的 REST API 可以使用，這樣我們就不用真的架一個後端伺服器了，在終端機輸入下方指令就可以全域安裝了。</p><pre><code class="shell">npm install -g json-server</code></pre><p>安裝完成後新增一個 <code>db.json</code>，然後可以先手動新增一筆帳目，檔案內容如下：</p><pre><code class="json">&#123;  &quot;accounts&quot;: [    &#123;      &quot;id&quot;: 1,      &quot;category&quot;: &quot;伙食&quot;,      &quot;amount&quot;: &quot;50&quot;,      &quot;date&quot;: 1602028800000,      &quot;description&quot;: &quot;早餐&quot;    &#125;  ]&#125;</code></pre><p>檔案備妥後，在終端機輸入以下指令就可以啟動 <code>json-server</code>，這時候到 <code>http://localhost:3000/accounts</code>，就可以看到剛剛建立的資料了，未來只要是開啟伺服器的狀態就可以使用 API 來讀寫 <code>db.json</code> 的資料了。</p><pre><code class="shell">json-server db.json</code></pre><p><br/><br/></p><h4 id="2-安裝-axios"><a href="#2-安裝-axios" class="headerlink" title="2.安裝 axios"></a>2.安裝 axios</h4><p>資料庫有了之後，接下來在專案資料夾底下輸入終端機指令來安裝 <code>axios</code>，它可以讓我們更便捷的處理 XMLHttpRequest。</p><pre><code class="shell">npm install axios</code></pre><p>安裝好後到 <code>main.js</code> 添加以下程式碼來引用它，這樣我們就可以在元件裡使用 <code>this.axios.get()</code> 來呼叫 API 了。</p><pre><code class="javascript">import Vue from &quot;vue&quot;;import axios from &quot;axios&quot;;Vue.prototype.axios = axios;</code></pre><p><br/><br/></p><h4 id="3-Highcharts-全域設定"><a href="#3-Highcharts-全域設定" class="headerlink" title="3.Highcharts 全域設定"></a>3.Highcharts 全域設定</h4><p>由於這次的應用會使用到日期座標，所以我們可以來調整一下「語言設定」，設定方法是在 <code>main.js</code> 引入原生 Highcharts，然後一樣是呼叫 <code>setOptions()</code>。</p><pre><code class="javascript">import Vue from &quot;vue&quot;;import Highcharts from &quot;highcharts&quot;;Highcharts.setOptions(&#123;  lang: &#123;    shortMonths: [&quot;1月&quot;, &quot;2月&quot;, ..., &quot;12月&quot;],    weekdays: [&quot;星期日&quot;, &quot;星期一&quot;, ..., &quot;星期六&quot;],  &#125;,  // 也可增加其他你像要的全域設定  credits: &#123; enabled: false &#125;,  colors: [...]&#125;);</code></pre><p><br/><br/></p><h4 id="4-表單元件-LedgerForm-vue"><a href="#4-表單元件-LedgerForm-vue" class="headerlink" title="4.表單元件 - LedgerForm.vue"></a>4.表單元件 - LedgerForm.vue</h4><p>前置作業完成後就可以來開發元件了，首先是上方用來新增帳目的表單元件。新增一個檔案內容如下的元件，其中四個表單欄位剛好對應資料庫的內容，而點擊按鈕觸發的 <code>addItem</code> 就是用 <code>axios</code> 送出 <code>post</code> 請求，便會在資料庫添加一筆新的帳目。</p><br/><p><strong>對了，為了把重點放在圖表的應用上，有許多部分是被我省略的：</strong></p><ol><li>為了省去畫面處理的邏輯，我故意使用 Form 表單，讓資料送出時會自動刷新頁面，這部分的使用體驗可以再改善。</li><li>表單驗證的部分也被我省略了，為了防止錯誤的資料格式存進資料庫，再請各位自行撰寫。</li></ol><pre><code class="vue">&lt;template&gt;  &lt;form&gt;    &lt;fieldset&gt;      &lt;legend&gt;新增帳目&lt;/legend&gt;      &lt;div class=&quot;input-group&quot;&gt;        &lt;label&gt;日期&lt;/label&gt;        &lt;input type=&quot;date&quot; v-model=&quot;date&quot;&gt;        &lt;label&gt;分類&lt;/label&gt;        &lt;select v-model=&quot;category&quot;&gt;          &lt;option value=&quot;伙食&quot;&gt;伙食&lt;/option&gt;          &lt;option value=&quot;交通&quot;&gt;交通&lt;/option&gt;          &lt;option value=&quot;生活&quot;&gt;生活&lt;/option&gt;          &lt;option value=&quot;帳單&quot;&gt;帳單&lt;/option&gt;          &lt;option value=&quot;娛樂&quot;&gt;娛樂&lt;/option&gt;        &lt;/select&gt;        &lt;label&gt;金額&lt;/label&gt;        &lt;input type=&quot;number&quot; v-model.number=&quot;amount&quot;&gt;      &lt;/div&gt;      &lt;div class=&quot;input-group&quot;&gt;        &lt;label&gt;說明&lt;/label&gt;        &lt;input type=&quot;text&quot; v-model=&quot;description&quot;&gt;      &lt;/div&gt;      &lt;button @click=&quot;addItem&quot;&gt;+&lt;/button&gt;    &lt;/fieldset&gt;  &lt;/form&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        date: &quot;&quot;,        category: &quot;伙食&quot;,        amount: 0,        description: &quot;&quot;      &#125;    &#125;,    methods: &#123;      addItem() &#123;        this.axios.post(&quot;http://localhost:3000/accounts&quot;, &#123;          date: new Date(this.date).getTime(),          category: this.category,          amount: this.amount,          description: this.description        &#125;)      &#125;    &#125;  &#125;&lt;/script&gt;</code></pre><p><br/><br/></p><h4 id="5-圖表元件-LedgerChart-vue"><a href="#5-圖表元件-LedgerChart-vue" class="headerlink" title="5.圖表元件 - LedgerChart.vue"></a>5.圖表元件 - LedgerChart.vue</h4><p><strong>可以紀錄帳目後，就要讓消費記錄透過圖表呈現出來了，而需求規格有以下幾點：</strong></p><ol><li>每一個支出類別都是一組數據列，例如伙食、娛樂、交通..等。</li><li>圖表為柱狀圖，不同數據列需要疊加，以便觀察每日總消費的起伏。</li><li>Ｘ軸為日期座標軸，並且顯示只顯示從今天算起的前七天。</li></ol><blockquote><p>避免模糊焦點，這次圖表只做到近七天的資料顯示，有興趣的話你也可以根據自己你想法改善這個範例。</p></blockquote><p>根據需求，我們先準備好需要的資料，包括儲存今日時間戳的 <code>todayTimeStamp</code>，儲存 API 資料的 <code>fetchData</code>，以及圖表設定 <code>chartOptions</code>。</p><pre><code class="javascript">data() &#123;  return &#123;    todayTimeStamp: 0,    fetchData: [],    chartOptions: &#123;      chart: &#123; type: &quot;column&quot; &#125;,      title: &#123; text: &quot;每日消費&quot; &#125;,      tooltip: &#123;        shared: true,        headerFormat: &quot;&#123;point.key:%Y/%m/%d %A&#125;&lt;br/&gt;&quot;,        valuePrefix: &quot;NT$&quot;      &#125;,      xAxis: &#123;        type: &quot;datetime&quot;,        categories: [],        labels: &#123; format: &quot;&#123;value:%b%d&#125;日&quot; &#125;,      &#125;,      yAxis: &#123;        title: undefined,        labels: &#123; format: &quot;NT$ &#123;value&#125;&quot; &#125;,      &#125;,      plotOptions: &#123;        series: &#123; stacking: &quot;normal&quot; &#125;      &#125;,      series: [],    &#125;  &#125;;&#125;</code></pre><p>而API資料我們需要再 <code>created</code> 時先去取得，順便把今天的時間戳儲存起來，方便我們之後計算近七天的時間。</p><pre><code class="javascript">created() &#123;  // 取得當日的時間戳  let now = new Date().getTime();  this.todayTimeStamp = now - now  % 86400000;  // call json-server api  this.axios.get(&quot;http://localhost:3000/accounts&quot;).then((response) =&gt; &#123;    this.fetchData = response.data;  &#125;);&#125;,</code></pre><p>有了這些資料後，就可以透過 <code>computed</code> 來將資料處理成我們所需的格式了。</p><pre><code class="javascript">computed: &#123;  // 利用當日時間戳來計算Ｘ軸所需的 categories 陣列  xAxisCategories() &#123;    return Array(7).fill(0).map((date ,index) =&gt; &#123;      return this.todayTimeStamp - 86400000 * index    &#125;).reverse()  &#125;,  // 抓出所有不重複的支出類別  expendType() &#123;    let allType = this.fetchData.map(item =&gt; item.category);    return Array.from(new Set(allType));  &#125;,  // 把 API 資料 map 成我們需要的格式  seriesData() &#123;    return this.expendType.map(cate =&gt; &#123;      let itemByCate = this.fetchData.filter(item =&gt; item.category === cate);      let points = this.xAxisCategories.map(date =&gt; &#123;        return itemByCate.reduce((acc, item) =&gt; &#123;          return item.date === date ? acc + Number(item.amount) : acc        &#125;, 0)      &#125;)      return &#123; name: cate, data: points &#125;;    &#125;);  &#125;,  // 將圖表設定和處理完的資料合併  options() &#123;    let options = Object.assign(this.chartOptions, &#123;&#125;);    options.series = this.seriesData;    options.xAxis.categories = this.xAxisCategories;    return options;  &#125;&#125;</code></pre><p>最後把 <code>options</code> 傳入圖表，並且記得把今天新增的兩個元件掛載到 <code>App.vue</code> 上，就可以看到消費紀錄呈現在圖表上囉。</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;chart-container&quot;&gt;    &lt;div v-if=&quot;!fetchData.length&quot; class=&quot;noData&quot;&gt;無任何消費記錄&lt;/div&gt;    &lt;highcharts v-else :options=&quot;options&quot;&gt;&lt;/highcharts&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><img src="ledger.gif" style="max-width: 800px; margin: 16px auto 0;" /><p><br/><br/></p><p>辛苦各位了，今天的篇幅比較長，不過跟著今天一步步的流程下來，終於完成了一個比較完整的 Highcharts-Vue 應用，而明天我們將利用「事件屬性」來為這個應用再添加一個小功能。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10252336">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;既然已經掌握了 Highcharts-Vue 的基本使用技巧，那今明兩天打算帶大家來實作一個「記帳本」，用一個比較完整的應用來完結這個系列，也算是一個學習成果的回顧。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;記帳本實作&quot;&gt;&lt;a href=&quot;#記帳本實作&quot; class=&quot;heade</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / Vue 資料綁定</title>
    <link href="https://maxleebk.com/2020/10/11/highchart/highcharts-27/"/>
    <id>https://maxleebk.com/2020/10/11/highchart/highcharts-27/</id>
    <published>2020-10-11T13:22:00.000Z</published>
    <updated>2023-10-23T03:50:24.488Z</updated>
    
    <content type="html"><![CDATA[<p>昨天我們成功安裝 Highcharts-Vue 並繪製出一個基本的圖表，不過既然都已經使用 Vue 了，我們應該要好好運用「資料綁定」的概念，也就是當資料變動時，我們不需要再額外操作圖表，圖表就會自己動態的更新變化。</p><hr><h2 id="Data-Binding"><a href="#Data-Binding" class="headerlink" title="Data Binding"></a>Data Binding</h2><br/><p>我們在「資料更新 Method」有說過，在網頁中資料不會總是靜態的，所以當資料變動時，我們需要透過一些 Method 的呼叫來更新圖表，不過當我們使用前端框架後，圖表應該要可以自己響應資料的變動進而更新畫面，那下面我們就來把昨天的 <code>Chart.vue</code> 改寫一下。</p><br/><h4 id="1-資料形式調整"><a href="#1-資料形式調整" class="headerlink" title="1.資料形式調整"></a>1.資料形式調整</h4><p>首先要把資料改寫一下，照理說原始資料應該比較難像昨天那樣是已經處理過的模樣，所以我們另外用 <code>data</code> 物件來模擬從後端拿到的資料，然後將 <code>chartOptions</code> 裡面的 <code>xAxis.categories</code> 和 <code>series.data</code> 給清空，因為這兩個屬性的值應該是原始資料處理過後才拿得到的。</p><pre><code class="javascript">data() &#123;  return &#123;    data: &#123;      &quot;18-24歲&quot;: 12,      &quot;25-29歲&quot;: 18,      &quot;30-34歲&quot;: 22,      &quot;35-39歲&quot;: 25,      &quot;40-44歲&quot;: 32,      &quot;45-49歲&quot;: 35,      &quot;50-54歲&quot;: 26,      &quot;55歲+&quot;: 18    &#125;,    chartOptions: &#123;      chart: &#123; type: &quot;column&quot; &#125;,      title: &#123; text: &quot;公司員工年齡分佈&quot; &#125;,      xAxis: &#123; categories: [] &#125;,      yAxis: &#123;         title: &#123; text: &quot;人數&quot; &#125;      &#125;,      series: [&#123;         name: &quot;XX公司員工&quot;,        data: []      &#125;]    &#125;  &#125;;&#125;</code></pre><br/><br/><h4 id="2-撰寫-computed"><a href="#2-撰寫-computed" class="headerlink" title="2.撰寫 computed"></a>2.撰寫 computed</h4><p>那因為現在原始資料的格式並不是我們要的，而且未來資料還有可能會變動，所以可以選擇用 Vue 的 <code>computed</code> 來幫我們處理資料，而且它也會在資料變動時自動更新。</p><p>那其中 <code>xAxisCate</code> 和 <code>seriesData</code> 就是用來處理資料的，而 <code>options</code> 則是將資料與圖表設定進行結合，最後導出一個完整的 <code>options</code> 物件。</p><pre><code class="javascript">computed: &#123;  xAxisCate() &#123;    return Object.keys(this.data);  &#125;,  seriesData() &#123;    return Object.values(this.data);  &#125;,  options() &#123;    let options = Object.assign(this.chartOptions, &#123;&#125;);    options.xAxis.categories = this.xAxisCate;    options.series[0].data = this.seriesData;    return options;  &#125;&#125;</code></pre><br/><br/><h4 id="3-資料綁定"><a href="#3-資料綁定" class="headerlink" title="3.資料綁定"></a>3.資料綁定</h4><p>有了 <code>options</code> 物件後，就可以把它作為 <code>prop</code> 傳入 <code>&lt;highcharts&gt;</code>，然後就可以看到跟昨天一樣的結果了。</p><pre><code class="html">&lt;template&gt;  &lt;highcharts :options=&quot;options&quot;&gt;&lt;/highcharts&gt;&lt;/template&gt;</code></pre><img src="vue-chart.png" style="max-width: 800px; margin: 16px auto 0;" /><br/><br/><h4 id="4-資料變動"><a href="#4-資料變動" class="headerlink" title="4.資料變動"></a>4.資料變動</h4><p>經過前面幾個步驟後，我們已經將資料與圖表做了綁定，接下來就要看看在資料改變時，圖表是否會更新畫面了。我們可以在畫面上新增以幾個按鈕，並綁定事件。</p><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;highcharts :options=&quot;chartOptions&quot;&gt;&lt;/highcharts&gt;    &lt;button @click=&quot;changeData&quot;&gt;改變資料&lt;/button&gt;    &lt;button @click=&quot;changeType(&#39;line&#39;)&quot;&gt;改為折線圖&lt;/button&gt;    &lt;button @click=&quot;changeType(&#39;column&#39;)&quot;&gt;改為柱狀圖&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>我們分別為按鈕綁定改變原始資料和圖表設定的 <code>methods</code>，看看圖表能不能在點擊按鈕後成功更新。</p><pre><code class="javascript">methods: &#123;  changeData() &#123;    this.xAxisCate.forEach((key) =&gt; &#123;      this.data[key] = Math.floor(Math.random() * 20);    &#125;);  &#125;,  changeType(type) &#123;    this.options.chart.type = type;  &#125;&#125;</code></pre><p>實際測試後，發現圖表確實的在資料發生變動的時候自動響應了新的圖表設定，並且根據設定進行了畫面上的更新。</p><img src="vue-binding.gif" style="max-width: 800px; margin: 16px auto 0;" /><p><br/><br/></p><p>今天算是真正使用上了 Vue 的特性來繪製 Highcharts 的圖表，透過資料綁定的方式讓圖表可以響應資料的改變，讓我們可以專注在資料的處理，而不用一再的操作圖表或呼叫 Method。</p><p>不過我今天的範例算是相當粗略，目的只在於向大家展示「資料綁定」的概念，假如你有 Vue 的開發經驗，肯定可以大幅改善這個元件的彈性、重用性。而明後兩天我也會透過比較完整的應用來展示更多 Highcharts-Vue 的使用方式。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10252156">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天我們成功安裝 Highcharts-Vue 並繪製出一個基本的圖表，不過既然都已經使用 Vue 了，我們應該要好好運用「資料綁定」的概念，也就是當資料變動時，我們不需要再額外操作圖表，圖表就會自己動態的更新變化。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Data-Bindin</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / Vue 建立圖表</title>
    <link href="https://maxleebk.com/2020/10/10/highchart/highcharts-26/"/>
    <id>https://maxleebk.com/2020/10/10/highchart/highcharts-26/</id>
    <published>2020-10-10T06:20:00.000Z</published>
    <updated>2023-10-23T03:50:24.488Z</updated>
    
    <content type="html"><![CDATA[<p>經過連續五天的實作練習，相信大家應該對於製作 Highcharts 圖表暸若指掌了，不過現在使用前端框架已是網頁開發的主流，Highcharts 是否有因應的方案呢？答案是有的，無論是 Angular、React 還是 Vue，都有對應的套件可以使用，不過本系列會以 Vue 的版本來介紹，若是其他框架的使用者，可以到 <strong><a href="https://github.com/highcharts">官方Github</a></strong> 去找找對應的套件。</p><hr><h2 id="VisUalizE"><a href="#VisUalizE" class="headerlink" title="VisUalizE"></a>VisUalizE</h2><br/><p>其實在 Vue 裡使用 Highcharts 是件非常容易的事，下面我們就一步步從零開始，使用 Vue CLI 工具來達成資料視覺化。</p><br/><h4 id="1-安裝-Vue-CLI"><a href="#1-安裝-Vue-CLI" class="headerlink" title="1.安裝 Vue CLI"></a>1.安裝 Vue CLI</h4><p>如果你還未安裝 Vue CLI，那請先打開終端機／命令提示字元並輸入以下指令，將 Vue CLI 工具安裝在全域環境中。</p><blockquote><p>請先安裝 Node.js 才能使用 <code>npm</code> 指令。</p></blockquote><pre><code class="shell">npm install -g @vue-cli</code></pre><br/><br/><h4 id="2-建立專案"><a href="#2-建立專案" class="headerlink" title="2.建立專案"></a>2.建立專案</h4><p>全域安裝 Vue CLI 後就可以在終端機／命令提示字元中使用 <code>vue</code> 指令了，先用以下指令來創建一個新的專案。指令輸入完後，系統會詢問你要使用何種設定，這次系列文章使用 <code>default</code> 即可，若是有使用過的話也可以按你自己的習慣設定。</p><pre><code class="shell">vue create vue-highchart</code></pre><br/><br/><h4 id="3-安裝套件"><a href="#3-安裝套件" class="headerlink" title="3.安裝套件"></a>3.安裝套件</h4><p>專案建立完成後，先移動到專案資料夾，並依序安裝 Highcharts 和 Highcharts-Vue，分別是主程式以及 Vue 的擴充。</p><pre><code class="shell">cd vue-highchartsnpm install highchartsnpm install highcharts-vue</code></pre><p>等待安裝完畢後，我們要打開 <code>src</code> 資料夾下的 <code>main.js</code>，增加下面這幾行程式碼來啟動套件。</p><pre><code class="javascript">import Vue from &#39;vue&#39;;import HighchartsVue from &#39;highcharts-vue&#39;;Vue.use(HighchartsVue);</code></pre><br/><br/><h4 id="4-新增元件"><a href="#4-新增元件" class="headerlink" title="4.新增元件"></a>4.新增元件</h4><p>那此時前置作業都完成了，接者就可以在 <code>src/components</code> 底下新增 <code>Chart.vue</code> 元件，名稱你可以自行調整，檔案內容如下：</p><pre><code class="vue">&lt;template&gt;  &lt;highcharts :options=&quot;chartOptions&quot;&gt;&lt;/highcharts&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      chartOptions: &#123;        chart: &#123; type: &quot;column&quot; &#125;,        title: &#123; text: &quot;公司員工年齡分佈&quot; &#125;,        xAxis: &#123;          categories: [            &quot;18-24歲&quot;,            &quot;25-29歲&quot;,            &quot;30-34歲&quot;,            &quot;35-39歲&quot;,            &quot;40-44歲&quot;,            &quot;45-49歲&quot;,            &quot;50-54歲&quot;,            &quot;55歲+&quot;          ]        &#125;,        yAxis: &#123;          title: &#123; text: &quot;人數&quot; &#125;        &#125;,        series: [&#123;          name: &quot;XX公司員工&quot;,          data: [12, 18, 22, 25, 32, 35, 26, 18]        &#125;]      &#125;    &#125;;  &#125;&#125;;&lt;/script&gt;</code></pre><p>其中 <code>&lt;highcharts&gt;</code> 就是 Highcharts-Vue 註冊的全域元件，而 <code>:options</code> 這個 Prop 要傳入的就是 <code>options</code> 物件，所以你會看到 <code>chartOptions</code> 其實就是我們已經寫了二十幾天的圖表設定。</p><br/><br/><h4 id="5-掛載元件"><a href="#5-掛載元件" class="headerlink" title="5.掛載元件"></a>5.掛載元件</h4><p>元件完成後就，我們打開 <code>App.vue</code>，然後將內容改成下面這樣，將剛剛寫好的元件掛載進來，取代原本的 <code>HelloWorld.vue</code>。</p><pre><code class="vue">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;chart /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import chart from &quot;./components/Chart.vue&quot;export default &#123;  name: &#39;App&#39;,  components: &#123;    chart  &#125;&#125;&lt;/script&gt;</code></pre><br/><br/><h4 id="6-執行APP"><a href="#6-執行APP" class="headerlink" title="6.執行APP"></a>6.執行APP</h4><p>最後只要在專案資料夾底下執行指令就可以看到圖表囉！</p><pre><code class="shell">npm run serve</code></pre><img src="vue-chart.png" style="max-width: 800px; margin: 16px auto 0;" /><p><br/><br/></p><p>今天我們成功使用 Vue CLI 配合 Highcharts 的套件來完成圖表的繪製，不過目前還沒有真正發揮 Vue 的優勢，所以明天還要繼續了解如何透過 Vue 的資料雙向綁定來動態更新圖表資料或設定。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10251641">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;經過連續五天的實作練習，相信大家應該對於製作 Highcharts 圖表暸若指掌了，不過現在使用前端框架已是網頁開發的主流，Highcharts 是否有因應的方案呢？答案是有的，無論是 Angular、React 還是 Vue，都有對應的套件可以使用，不過本系列會以 Vu</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 金字塔圖表</title>
    <link href="https://maxleebk.com/2020/10/09/highchart/highcharts-25/"/>
    <id>https://maxleebk.com/2020/10/09/highchart/highcharts-25/</id>
    <published>2020-10-09T02:30:00.000Z</published>
    <updated>2023-10-23T03:50:24.488Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/wvGVGyR">https://codepen.io/max-lee/pen/wvGVGyR</a></strong></p></blockquote><p>相信大家在學生時期都有在課本中看過人口金字塔，而今天我們就是要用臺灣的人口統計資料來實作「金字塔圖表」。</p><hr><h2 id="實作目標"><a href="#實作目標" class="headerlink" title="實作目標"></a>實作目標</h2><img src="pyramid.png" style="max-width: 900px; margin: 16px auto 0;" /><br/><p>那上圖就是我們今天要製作圖表，其實分析一下可以發現金字塔圖表只是一個「雙Ｘ軸長條圖」，倒是它的Ｙ軸座標比較特別，最小刻度竟然在中間，越往兩側值越高。下面就來看看這是如何做到的吧！</p><blockquote><p><strong>提醒：</strong>長條圖中垂直的座標軸為Ｘ軸，水平為Ｙ軸，剛好跟其他圖表類型相反。</p></blockquote><p>這次的原始資料如下:</p><pre><code class="javascript">const colors = [&quot;#66BAB7&quot;, &quot;#EB7A77&quot;];const age = [&quot;0-9&quot;,&quot;10-19&quot;,&quot;20-29&quot;,&quot;30-39&quot;,&quot;40-49&quot;,&quot;50-59&quot;,&quot;60-69&quot;,&quot;70-79&quot;,&quot;80+&quot;];const male = [1046336, 1248418, 1653942, 1848095, 1818996, 1789423, 1376599, 594861, 339574];const female = [970889, 1142606, 1533181, 1851812, 1875771, 1849072, 1489570, 712084, 438873];</code></pre><hr><h2 id="動手開發"><a href="#動手開發" class="headerlink" title="動手開發"></a>動手開發</h2><br/><h4 id="1-容器準備"><a href="#1-容器準備" class="headerlink" title="1. 容器準備"></a>1. 容器準備</h4><p>無論如何，第一步永遠都是把要放圖表的容器先準備好。</p><pre><code class="html">&lt;div id=&quot;barChart&quot;&gt;&lt;/div&gt;</code></pre><br/><br/><h4 id="2-資料準備"><a href="#2-資料準備" class="headerlink" title="2. 資料準備"></a>2. 資料準備</h4><p>其實今天的原始資料都已經可以直接拿來使用了，但再來就是Ｙ軸的秘密了，男性的資料我們要稍微動一下手腳。透過 <code>map</code> 把男性資料乘以 <code>-1</code>，這樣數據列剛好一組正數一組負數，自然就會往兩邊延伸了。</p><pre><code class="javascript">const maleSeries = male.map(val =&gt; val * -1);</code></pre><br/><br/><h4 id="3-創建圖表與區塊設定"><a href="#3-創建圖表與區塊設定" class="headerlink" title="3. 創建圖表與區塊設定"></a>3. 創建圖表與區塊設定</h4><p><strong>資料備妥後，剩下就是圖表的設定跟創建了，不過要做出金字塔圖表有幾個重點要注意：</strong></p><ol><li>初始的Ｘ軸刻度會是上低下高，所以記得要把 <code>reversed</code> 屬性關掉翻轉回來。</li><li>因為男性這側的Ｙ軸刻度會是負數，所以記得要用 <code>formatter</code> 來取絕對值，才不會出現負號。</li><li>提示框內容裡也會出現負數，一樣要透過格式化屬性處理。</li><li>數據列的 <code>stacking</code> 屬性要記得設定，才會有堆疊效果。</li></ol><br/><p>只要有做到以上幾點，金字塔圖表就能輕輕鬆鬆做出來了，大家也試著做做看吧！</p><pre><code class="javascript">let myChart = Highcharts.chart(&quot;container&quot;, &#123;  chart: &#123; type: &quot;bar&quot; &#125;,  credits: &#123; text: &quot;數據來源: 內政部戶政司&quot; &#125;,  colors: colors,  title: &#123; text: &quot;2018 臺灣人口金字塔&quot; &#125;,  tooltip: &#123;    headerFormat: &quot;&lt;b&gt;&#123;point.key&#125;歲&lt;/b&gt;&lt;br/&gt;&quot;,    pointFormatter() &#123;      let value = Math.abs(this.y);      let formatValue = Highcharts.numberFormat(value, 0, &quot;&quot;, &quot;,&quot;);      return `$&#123;formatValue&#125;人`;    &#125;  &#125;,  xAxis: [    &#123;       categories: age,      reversed: false,      labels: &#123; format: &quot;&#123;value&#125;歲&quot; &#125;    &#125;,    &#123;       categories: age,      opposite: true,      reversed: false,      labels: &#123; format: &quot;&#123;value&#125;歲&quot; &#125;    &#125;  ],  yAxis: &#123;    title: &#123; text: undefined &#125;,    labels: &#123;       formatter() &#123;        return `$&#123;Math.abs(this.value / 10000)&#125;萬人`       &#125;    &#125;  &#125;,  plotOptions: &#123;    series: &#123;      groupPadding: 0,      pointPadding: 0,      stacking: &quot;normal&quot;    &#125;  &#125;,  series: [    &#123; name: &quot;男性&quot;, data: maleSeries &#125;,    &#123; name: &quot;女性&quot;, data: female, xAxis: 1 &#125;  ]&#125;);</code></pre><blockquote><p><code>groupPadding</code> 和 <code>pointPadding</code> 都設為 <code>0</code>，才能移除長條圖之間的間距，也才會有這種階梯狀的圖形效果。</p></blockquote><p><br/><br/></p><p>那今天就正式完成了最後一個實作範例了，不過 Highcharts 的圖表應用當然還有百百種，可以到 <a href="https://www.highcharts.com/demo">官方DEMO</a> 去挖挖寶，也希望大家可以發揮創意，組合自己獨特的圖表內容與功能。</p><p>那麼明天就要進入本系列的最後一個階段了，就是在前端框架-Vue 底下使用 Highcharts，透過 Vue 的元件和資料綁定的機制來協助我們開發。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10251181">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/wvGVGyR&quot;&gt;https://codepen.io/max-lee/pen/wvGVGyR&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blo</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 雙Ｙ軸複合圖表</title>
    <link href="https://maxleebk.com/2020/10/08/highchart/highcharts-24/"/>
    <id>https://maxleebk.com/2020/10/08/highchart/highcharts-24/</id>
    <published>2020-10-08T04:58:00.000Z</published>
    <updated>2023-10-23T03:50:24.488Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/mdPZaRr">https://codepen.io/max-lee/pen/mdPZaRr</a></strong></p></blockquote><p>複合圖表和複數座標軸在前面的章節其實都有介紹過，不過今天我們要結合一下時事，用台灣疫情的資料來實際做一個「雙Ｙ軸複合圖表」。</p><hr><h2 id="實作目標"><a href="#實作目標" class="headerlink" title="實作目標"></a>實作目標</h2><img src="doubleY.png" style="max-width: 800px; margin: 16px auto 0;" /><br/><p>如上圖所示，這次要做的是柱狀圖和折線圖的複合圖表，並且累計確診是使用左邊的人數Ｙ軸，而致死率則是右邊的百分比Ｙ軸。不過複合式圖表應該算是蠻簡單的，之前的 <strong><a href="https://codepen.io/max-lee/pen/mdPxGyq">範例</a></strong> 也已經有展示過了，所以這次的重點會放在雙Ｙ軸上面。那今天為大家準備的原始資料如下：</p><pre><code class="javascript">const colors = [&quot;#8E354A&quot;, &quot;#1C1C1C&quot;];const epidemic = [  &#123; &quot;月份&quot;: 2, &quot;累計確診&quot;: 39, &quot;累計死亡&quot;: 1 &#125;,  &#123; &quot;月份&quot;: 3, &quot;累計確診&quot;: 322, &quot;累計死亡&quot;: 5 &#125;,  &#123; &quot;月份&quot;: 4, &quot;累計確診&quot;: 429, &quot;累計死亡&quot;: 6 &#125;,  &#123; &quot;月份&quot;: 5, &quot;累計確診&quot;: 442, &quot;累計死亡&quot;: 7 &#125;,  &#123; &quot;月份&quot;: 6, &quot;累計確診&quot;: 447, &quot;累計死亡&quot;: 7 &#125;,  &#123; &quot;月份&quot;: 7, &quot;累計確診&quot;: 467, &quot;累計死亡&quot;: 7 &#125;,  &#123; &quot;月份&quot;: 8, &quot;累計確診&quot;: 488, &quot;累計死亡&quot;: 7 &#125;,  &#123; &quot;月份&quot;: 9, &quot;累計確診&quot;: 514, &quot;累計死亡&quot;: 7 &#125;,];</code></pre><hr><h2 id="動手開發"><a href="#動手開發" class="headerlink" title="動手開發"></a>動手開發</h2><br/><h4 id="1-容器準備"><a href="#1-容器準備" class="headerlink" title="1. 容器準備"></a>1. 容器準備</h4><p>第一步還是一樣，要先準備好放圖表的容器，另外今天偷偷跟大家說一個小撇步，如果容器有設定 HTML <code>id</code> 屬性的話，其實 ID 名稱可以直接作為 <code>chart()</code> 的 <code>element</code> 參數。但先前怕大家覺得怎麼突然沒來由的傳了一個字串，所以就還是用了比較保守的寫法。</p><pre><code class="html">&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="javascript">// const container = document.querySelector(&#39;#container&#39;);// 可以省略上面這行，直接將id名稱作為參數let myChart = Highcharts.chart(&quot;container&quot;, &#123;...&#125;);</code></pre><br/><br/><h4 id="2-資料準備"><a href="#2-資料準備" class="headerlink" title="2. 資料準備"></a>2. 資料準備</h4><p>再來就是把需要的資料透過原始資料 Mapping 出來，這裡我有把月份給 <code>map</code> 出來，因為這樣可以直接作為Ｘ軸的 <code>categories</code> 使用，就不用設定一堆屬性來做「日期座標軸」了。</p><pre><code class="javascript">const month = epidemic.map(data =&gt; `$&#123;data[&quot;月份&quot;]&#125;月`);const confirmedNum = epidemic.map(data =&gt; data[&quot;累計確診&quot;]);const deathRate = epidemic.map(data =&gt; &#123;  return Math.floor(data[&quot;累計死亡&quot;] / data[&quot;累計確診&quot;] * 10000) / 100;&#125;);</code></pre><br/><br/><h4 id="3-創建圖表與區塊設定"><a href="#3-創建圖表與區塊設定" class="headerlink" title="3. 創建圖表與區塊設定"></a>3. 創建圖表與區塊設定</h4><p><strong>資料準備好後就可以建立圖表了，不過大家要注意一下我們的圖表設定，有下面幾個重點：</strong></p><ol><li>因為要做的是複數座標軸，所以Ｙ軸設定傳入的是 <strong>陣列</strong>，裡面的兩組物件代表的就是兩組Ｙ軸。</li><li>第二組的百分比Ｙ軸要加上 <code>opposite</code> 屬性，才會顯示在右邊。</li><li>數據列必須要設定 <code>yAxis</code> 屬性，用來指定要使用陣列中哪一組座標軸。</li></ol><br/><p>其中最容易忘記的就是第三點，要是沒有設定 <code>xAxis</code> 或 <code>yAxis</code> 屬性，那所有數據列都會採用第一組座標軸，最後圖表的結果就會很不一樣了。</p><pre><code class="javascript">let myChart = Highcharts.chart(&quot;container&quot;, &#123;  chart: &#123; height: 500 &#125;,  colors: colors,  credits: &#123; text: &quot;數據來源: 衛福部疾管署&quot; &#125;,  title: &#123; text: &quot;2020 臺灣疫情報告&quot; &#125;,  tooltip: &#123;    headerFormat: &quot;&lt;b&gt;&#123;point.key&#125;&lt;/b&gt;&lt;br/&gt;&quot;,    pointFormat: &quot;&#123;series.name&#125;: &#123;point.y&#125; &#123;series.userOptions.custom&#125;&quot;,  &#125;,  xAxis: &#123; categories: month &#125;,  yAxis: [    &#123;      title: &#123; text: &quot;人數&quot; &#125;,      labels: &#123; format: &quot;&#123;value&#125;人&quot; &#125;    &#125;,    &#123;      title: &#123; text: &quot;百分比&quot; &#125;,      labels: &#123; format: &quot;&#123;value&#125;％&quot; &#125;,      opposite: true    &#125;  ],  series: [    &#123;      name: &quot;累計確診人數&quot;,      type: &quot;column&quot;,      data: confirmedNum,      custom: &quot;人&quot;    &#125;,    &#123;      name: &quot;致死率&quot;,      data: deathRate,      yAxis: 1, // 指定第二組座標軸，1 為索引值      custom: &quot;%&quot;    &#125;  ]&#125;);</code></pre><p><br/><br/></p><p>今天實作了「雙Ｙ軸複合圖表」，算是一個很常見的圖表類型，能夠運用的情境應該蠻多的，建議大家可以練習看看。接著明天，我們要再換一個題目來做做看「金字塔圖表」，也即將會是最後一個實作範例。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10250764">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/mdPZaRr&quot;&gt;https://codepen.io/max-lee/pen/mdPZaRr&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blo</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 下鑽圖表</title>
    <link href="https://maxleebk.com/2020/10/07/highchart/highcharts-23/"/>
    <id>https://maxleebk.com/2020/10/07/highchart/highcharts-23/</id>
    <published>2020-10-07T02:35:00.000Z</published>
    <updated>2023-10-23T03:50:24.480Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/oNxrMRr">https://codepen.io/max-lee/pen/oNxrMRr</a></strong></p></blockquote><p>今天要來實作的是「下鑽圖表」，原文是 DrillDown Charts，它的概念其實就是把數據列分為上下層，可以透過點擊上層來鑽到下層，從而觀看更細節的資料，光用說的可能很難想像，我們直接看看範例吧。</p><hr><h2 id="實作目標"><a href="#實作目標" class="headerlink" title="實作目標"></a>實作目標</h2><img src="drilldown.gif" style="max-width: 800px; margin: 16px auto 0;" /><br/><p>下鑽圖表就如上圖所示，點擊數據點就可以看到更細節的資料，右上角還有個返回按鈕，是不是覺得和「圖表連動」的範例有點像呢？</p><p>其實還真的有點類似，但其實差異還是不小的：</p><ul><li><strong>下鑽圖表:</strong> 只能運用在「單個圖表」，而且是透過點擊上層「數據點」，來看下層「數據列」。</li><li><strong>圖表連動:</strong> 可以讓「多個圖表」進行交互，無論數據列或數據點都可以設定事件或更新資料。</li></ul><p>那接下來就來實作看看吧，事前資料也和前兩天一樣：</p><pre><code class="javascript">const categories = [&quot;18-24&quot;, &quot;25-29&quot;, &quot;30-34&quot;, &quot;35-39&quot;, &quot;40-44&quot;, &quot;45-49&quot;, &quot;50-54&quot;, &quot;55+&quot;];const colors = [ &quot;rgb(119, 146, 174)&quot;, &quot;rgb(83, 119, 122)&quot;, &quot;rgb(99, 99, 104)&quot;];const data = &#123;  &quot;工程部&quot;: [24, 37, 30, 24, 18, 11, 3, 2],  &quot;銷售部&quot;: [23, 30, 35, 28, 10, 8, 2, 1],  &quot;企劃部&quot;: [22, 32, 27, 25, 16, 6, 4, 3]&#125;;</code></pre><hr><h2 id="動手開發"><a href="#動手開發" class="headerlink" title="動手開發"></a>動手開發</h2><br/><h4 id="1-掛載下鑽模組"><a href="#1-掛載下鑽模組" class="headerlink" title="1. 掛載下鑽模組"></a>1. 掛載下鑽模組</h4><p>下鑽功能的支援必須要額外掛載模組，所以除了原本基礎的 Highcharts 之外，我們還要在加入一支 <code>script</code>。</p><pre><code class="html">&lt;script src=&quot;http://cdn.highcharts.com.cn/highcharts/highcharts.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://code.highcharts.com/modules/drilldown.js&quot;&gt;&lt;/script&gt;</code></pre><br/><br/><h4 id="2-容器準備"><a href="#2-容器準備" class="headerlink" title="2. 容器準備"></a>2. 容器準備</h4><p>下鑽圖表一單個圖表的操作互動，所以只需要一個容器即可。</p><pre><code class="html">&lt;div id=&quot;pie&quot;&gt;&lt;/div&gt;</code></pre><br/><br/><h4 id="3-學習下鑽屬性"><a href="#3-學習下鑽屬性" class="headerlink" title="3. 學習下鑽屬性"></a>3. 學習下鑽屬性</h4><p>那想要圖表有下鑽功能就必須要設定 <code>drilldown</code> 屬性，但既然是一個新的屬性，就先來看看如何使用吧！</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  series: [&#123;    data: [      &#123; name: &quot;數據點1&quot;, drilldown: &quot;id1&quot;, y: 10 &#125;,      &#123; name: &quot;數據點2&quot;, drilldown: &quot;id2&quot;, y: 20 &#125;    ]   &#125;],  drilldown: &#123;    series: [      &#123; name: &quot;下層數據列1&quot;, id: &quot;id1&quot;, data: [5, 5] &#125;,      &#123; name: &quot;下層數據列2&quot;, id: &quot;id2&quot;, data: [10, 10] &#125;,    ]  &#125;&#125;);</code></pre><p>其實重點就在於為上層數據列中的「數據點」添加 <code>drilldown</code> 名稱，並在 <code>drilldown</code> 設定區塊中加上對應的「數據列」，而數據列必須有著和上層數據點相同名稱的 <code>id</code> 屬性，這樣兩者就可以聯繫起來，而後產生我們要的效果。</p><br/><br/><h4 id="4-資料準備"><a href="#4-資料準備" class="headerlink" title="4. 資料準備"></a>4. 資料準備</h4><p>知道下鑽屬性的設定方法後，就把原生資料 Mapping 出符合需求的格式吧。<code>piePoints</code> 為上層的 <strong>三個數據點</strong>，要加上 <code>drilldown</code> 屬性，<code>drilldownSeries</code> 為下層的 <strong>三組數據列</strong>，要加上 <code>id</code>。</p><pre><code class="javascript">const dataKeys = Object.keys(data);const piePoints = dataKeys.map((department, index) =&gt; (&#123;  name: department,  drilldown: department,  color: colors[index],  y: data[department].reduce((arr, val) =&gt; arr + val)&#125;));const drilldownSeries = dataKeys.map((department, sIndex) =&gt; (&#123;  name: department,  id: department,  data: data[department].map((value, pIndex) =&gt; (&#123;    name: categories[pIndex],    color: rgbToRgba(colors[sIndex], 1 - pIndex * 0.05),    y: value,  &#125;))&#125;))</code></pre><p>下鑽資料的漸層依然是透過 <code>rgbToRgba</code> 這個函式來幫忙轉換。</p><pre><code class="javascript">function rgbToRgba(rgb, alpha) &#123;  return rgb.replace(&quot;rgb&quot;, &quot;rgba&quot;).replace(&quot;)&quot;, `,$&#123;alpha&#125;)`)&#125;;</code></pre><br/><br/><h4 id="5-創建圖表與區塊設定"><a href="#5-創建圖表與區塊設定" class="headerlink" title="5. 創建圖表與區塊設定"></a>5. 創建圖表與區塊設定</h4><p>再來就是把圖表創建出來，把區塊設定調整一下，最後帶入資料就完成了，是不是很簡單呢？</p><pre><code class="javascript">const pie = document.querySelector(&#39;#pie&#39;);let pieChart = Highcharts.chart(pie, &#123;  chart: &#123; height: 500, type: &quot;pie&quot; &#125;,  credits: &#123; enabled: false &#125;,  title: &#123; text: &quot;公司部門年齡人數佔比&quot; &#125;,  tooltip: &#123;    headerFormat: &quot;&lt;b&gt;&#123;point.key&#125;&lt;/b&gt;&lt;br/&gt;&quot;,    pointFormat: &quot;&#123;point.percentage:.1f&#125; %／&#123;point.y&#125;人&quot;,  &#125;,  plotOptions: &#123;    series: &#123;      states: &#123;        inactive: &#123; enabled: false &#125;      &#125;    &#125;  &#125;,  series: [&#123; data: piePoints &#125;],  drilldown: &#123; series: drilldownSeries &#125;&#125;);</code></pre><p><br/><br/></p><p>這幾天的實作大家是否有發現，其實最難的部分都是在「資料準備」的環節，不過實際開發就是會如此，我們從後端或外部 API 獲得的資料未必會符合 Highcharts 所需的格式，所以就必須靠前端來把原始資料重新組裝轉換一下，才能套用在圖表裡。</p><p>那今天透過實作又認識了「下鑽圖表」這個新的圖表型態，明天的話我們換個題目來實作看看「雙Ｙ軸複合圖表」吧！</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10250229">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/oNxrMRr&quot;&gt;https://codepen.io/max-lee/pen/oNxrMRr&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blo</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 雙層圓餅圖</title>
    <link href="https://maxleebk.com/2020/10/06/highchart/highcharts-22/"/>
    <id>https://maxleebk.com/2020/10/06/highchart/highcharts-22/</id>
    <published>2020-10-06T06:15:00.000Z</published>
    <updated>2023-10-23T03:50:24.476Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/vYGqGJj">https://codepen.io/max-lee/pen/vYGqGJj</a></strong></p></blockquote><p>今天要延續昨天「公司部門年齡分佈與人數佔比」的主題，把昨天需要點擊柱狀圖才能看到的「年齡佔比圓餅圖」和「部門人數佔比圓餅圖」合併在同一張圖表裡。</p><hr><h2 id="實作目標"><a href="#實作目標" class="headerlink" title="實作目標"></a>實作目標</h2><img src="case.png" style="max-width: 800px; margin: 16px auto 0;" /><br/><p>就如文章開頭所說，我們今天要將兩個圓餅圖合併起來，而最後的成果就出現像上圖分為內外層的雙層圓餅圖，而「雙層圓餅圖」的設定其實沒有想像的那麼複雜，下面我們就來一步步完成它吧。而事前的資料也和昨天一樣：</p><pre><code class="javascript">const categories = [&quot;18-24&quot;, &quot;25-29&quot;, &quot;30-34&quot;, &quot;35-39&quot;, &quot;40-44&quot;, &quot;45-49&quot;, &quot;50-54&quot;, &quot;55+&quot;];const colors = [ &quot;rgb(119, 146, 174)&quot;, &quot;rgb(83, 119, 122)&quot;, &quot;rgb(99, 99, 104)&quot;];const data = &#123;  &quot;工程部&quot;: [24, 37, 30, 24, 18, 11, 3, 2],  &quot;銷售部&quot;: [23, 30, 35, 28, 10, 8, 2, 1],  &quot;企劃部&quot;: [22, 32, 27, 25, 16, 6, 4, 3]&#125;;</code></pre><hr><h2 id="動手開發"><a href="#動手開發" class="headerlink" title="動手開發"></a>動手開發</h2><br/><h4 id="1-容器準備"><a href="#1-容器準備" class="headerlink" title="1. 容器準備"></a>1. 容器準備</h4><p>既然是把兩個圓餅圖合併，那容器當然只需要一個，先把它準備好。</p><pre><code class="html">&lt;div id=&quot;pie&quot;&gt;&lt;/div&gt;</code></pre><br/><br/><h4 id="2-資料準備"><a href="#2-資料準備" class="headerlink" title="2. 資料準備"></a>2. 資料準備</h4><p>再來也是要先把圖表資料給準備好，利用原始資料來 Mapping 出我們想要的資料格式，內層的資料會是部門的人數加總，外層則是將各部門的八個年齡層分散開來，也就是總共會有二十四個數據點。</p><pre><code class="javascript">const dataKeys = Object.keys(data);const innerPiePoints = dataKeys.map((department, index) =&gt; (&#123;  name: department,  color: colors[index],  y: data[department].reduce((arr, val) =&gt; arr + val)&#125;));const outerPiePoints = dataKeys.map((department, sIndex) =&gt; &#123;  return data[department].map((value, pIndex) =&gt; (&#123;    name: categories[pIndex],    color: rgbToRgba(colors[sIndex], 1 - pIndex * 0.05)    y: value,  &#125;))&#125;).flat();</code></pre><p>另外為了讓外層的扇形有漸層顏色，一樣要用到昨天的顏色轉換函式，就偷偷把它拿過來使用吧。</p><pre><code class="javascript">function rgbToRgba(rgb, alpha) &#123;  return rgb.replace(&quot;rgb&quot;, &quot;rgba&quot;).replace(&quot;)&quot;, `,$&#123;alpha&#125;)`)&#125;;</code></pre><br/><br/><h4 id="3-創建圖表與區塊設定"><a href="#3-創建圖表與區塊設定" class="headerlink" title="3. 創建圖表與區塊設定"></a>3. 創建圖表與區塊設定</h4><p>最後就是創建圓餅圖了，這次的設定重點在於我們設定了內外兩組數據列，並且利用 <code>innerSize</code> 屬性將外層變為「甜甜圈圖」，而內層則利用 <code>size</code> 屬性來設定成可以剛好放入甜甜圈缺口中的尺寸，如此就可以製作出「雙層圓餅圖」的效果，所以可以發現 <code>size</code> 和 <code>innerSize</code> 的值是一樣的。</p><pre><code class="javascript">const pie = document.querySelector(&#39;#pie&#39;);let pieChart = Highcharts.chart(pie, &#123;  chart: &#123; height: 500, type: &quot;pie&quot; &#125;,  credits: &#123; enabled: false &#125;,  title: &#123; text: &quot;公司部門年齡人數佔比&quot; &#125;,  tooltip: &#123;    headerFormat: &quot;&lt;b&gt;&#123;point.key&#125;&lt;/b&gt;&lt;br/&gt;&quot;,    pointFormat: &quot;&#123;point.percentage:.1f&#125; %／&#123;point.y&#125;人&quot;,  &#125;,  series: [    &#123;       size: &quot;220px&quot;,      data: innerPiePoints,      states: &#123; inactive: &#123; enabled: false &#125; &#125;,      dataLabels: &#123;        distance: -50,        style: &#123; fontSize: &quot;14px&quot; &#125;      &#125;,    &#125;,    &#123;      innerSize: &quot;220px&quot;,      data: outerPiePoints,      dataLabels: &#123;        format: &quot;&#123;key&#125;歲&quot;,        style: &#123; color: &quot;#7e7e7e&quot; &#125;      &#125;    &#125;,  ]&#125;);</code></pre><img src="inner.png" style="max-width: 900px; margin: 16px auto 0;" /><blockquote><p><strong>注意:</strong> 內層數據列的「數據標籤」要將 <code>distance</code> 設為負數，不然會蓋在外層數據列上方，可能比較不美觀，也不方便觀看。</p></blockquote><p><br/><br/></p><p>雙層圓餅圖是不是一個 CP 值很高的圖表呢？簡簡單單設定就可以製作出看起來很專業的圖表，之後大家如果有遇到類似的資料型態，也可以試試看喔。至於明天，我們還是會延續同一個題目來介紹「下鑽圖表」。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10249790">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/vYGqGJj&quot;&gt;https://codepen.io/max-lee/pen/vYGqGJj&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blo</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 圖表連動</title>
    <link href="https://maxleebk.com/2020/10/05/highchart/highcharts-21/"/>
    <id>https://maxleebk.com/2020/10/05/highchart/highcharts-21/</id>
    <published>2020-10-05T03:35:00.000Z</published>
    <updated>2023-10-23T03:50:24.468Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/JjXqYyz">https://codepen.io/max-lee/pen/JjXqYyz</a></strong></p></blockquote><p>經過前面各種設定屬性與 Method 的轟炸後，我們先來個簡單的小應用，也算是給自己的一個小驗收。</p><hr><h2 id="實作目標"><a href="#實作目標" class="headerlink" title="實作目標"></a>實作目標</h2><p><img src="case.gif" alt=""></p><p>今天打算要來實作圖表連動的功能，主題是「公司部門年齡分佈與人數佔比」，功能如上圖所示，柱狀圖會有三個部門的數據列資料，且點擊數據列時會使圓餅圖更換標題，並且呈現特定部門的各年齡人數佔比，額外還提供一個按鈕來重新觀看各部門的人數佔比。而事前我們已得知的資料如下：</p><pre><code class="javascript">const categories = [&quot;18-24&quot;, &quot;25-29&quot;, &quot;30-34&quot;, &quot;35-39&quot;, &quot;40-44&quot;, &quot;45-49&quot;, &quot;50-54&quot;, &quot;55+&quot;];const colors = [ &quot;rgb(119, 146, 174)&quot;, &quot;rgb(83, 119, 122)&quot;, &quot;rgb(99, 99, 104)&quot;];const data = &#123;  &quot;工程部&quot;: [24, 37, 30, 24, 18, 11, 3, 2],  &quot;銷售部&quot;: [23, 30, 35, 28, 10, 8, 2, 1],  &quot;企劃部&quot;: [22, 32, 27, 25, 16, 6, 4, 3]&#125;;</code></pre><hr><h2 id="動手開發"><a href="#動手開發" class="headerlink" title="動手開發"></a>動手開發</h2><br/><h4 id="1-容器與元素準備"><a href="#1-容器與元素準備" class="headerlink" title="1. 容器與元素準備"></a>1. 容器與元素準備</h4><p>大略了解功能需求後，就要來一步步來完成應用了，首先把容器和按鈕準備一下吧，樣式部分就留給各位自由發揮了</p><pre><code class="html">&lt;div class=&quot;container&quot;&gt;  &lt;div id=&quot;column&quot;&gt;&lt;/div&gt;  &lt;div id=&quot;pie&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;button class=&quot;overview&quot;&gt;返回看整體佔比&lt;/button&gt;</code></pre><br/><br/><h4 id="2-資料準備"><a href="#2-資料準備" class="headerlink" title="2. 資料準備"></a>2. 資料準備</h4><p>接著把一些基本變數跟圖表資料準備一下，這個部分要注意的是「柱狀圖」和「圓餅圖」的資料格式，柱狀圖的部分我準備的是「數據列」的資料，而圓餅圖則是 Mapping 出了「數據點」的資料。</p><pre><code class="javascript">const dataKeys = Object.keys(data);const columnSeries = dataKeys.map(department =&gt; (&#123;  name: department,  data: data[department]&#125;));const piePoints = dataKeys.map(department =&gt; (&#123;  name: department,  y: data[department].reduce((arr, val) =&gt; arr + val)&#125;));</code></pre><br/><br/><h4 id="3-主題設定"><a href="#3-主題設定" class="headerlink" title="3. 主題設定"></a>3. 主題設定</h4><p>再來先用「主題設定」把一些共同的設定先處理一下，像是顏色和版權標籤。</p><pre><code class="javascript">Highcharts.setOptions(&#123;  colors: colors,  credits: &#123; enabled: false &#125;&#125;);</code></pre><br/><br/><h4 id="4-創建圖表與區塊設定"><a href="#4-創建圖表與區塊設定" class="headerlink" title="4. 創建圖表與區塊設定"></a>4. 創建圖表與區塊設定</h4><p>然後用 <code>Highcharts.chart()</code> 來把這次的兩個主要圖表處建出來，這邊我暫時還沒有設定「事件屬性」，而是先把基本的區塊設定給完成，讓圖表先出顯示出來，後面會再透過其他方式加上去。</p><blockquote><p>記得要用變數將「圖表實例」存起來，之後才能呼叫其中的 Method。</p></blockquote><pre><code class="javascript">const column = document.querySelector(&#39;#column&#39;);let columnChart = Highcharts.chart(column, &#123;  chart: &#123; type: &quot;column&quot; &#125;,  title: &#123; text: &quot;公司部門年齡分佈&quot; &#125;,  xAxis: &#123;    categories,    labels: &#123; format: &quot;&#123;value&#125;歲&quot; &#125;  &#125;,  yAxis: &#123;     title: &#123; text: &quot;人數&quot; &#125;   &#125;,  tooltip: &#123;    headerFormat: &quot;&lt;b&gt;&#123;series.name&#125;&lt;/b&gt;&lt;br/&gt;&quot;,    pointFormat: &quot;&#123;point.category&#125;: &#123;point.y&#125;人&quot;,  &#125;,  series: columnSeries&#125;);const pie = document.querySelector(&#39;#pie&#39;);let pieChart = Highcharts.chart(pie, &#123;  chart: &#123; type: &quot;pie&quot; &#125;,  title: &#123; text: &quot;公司部門人數佔比&quot; &#125;,  tooltip: &#123;    headerFormat: &quot;&lt;b&gt;&#123;point.key&#125;&lt;/b&gt;&lt;br/&gt;&quot;,    pointFormat: &quot;&#123;point.percentage:.1f&#125; %／&#123;point.y&#125;人&quot;,  &#125;,  plotOptions: &#123;    series: &#123;      size: &quot;80%&quot;,      states: &#123; inactive: &#123; enabled: false &#125; &#125;    &#125;  &#125;,  series: [&#123; data: piePoints &#125;]&#125;);</code></pre><p>這邊我在圓餅圖設定了一個之前沒介紹的屬性 <code>series.states</code>，它可以開關數據列的狀態及調整樣式，像這次我把 <code>inactive</code> (非聚焦狀態) 給關閉，這樣當我在聚焦某個數據點(扇形)時，其他非聚焦狀態的數據點就不會被反灰了。想更了解這個屬性的話可以看 <strong><a href="https://api.highcharts.com/highcharts/series.line.states">官方文件</a></strong>。</p><img src="state.png" style="max-width: 800px; margin: 16px auto 0;" /><br/><br/><h4 id="5-柱狀圖的事件設定"><a href="#5-柱狀圖的事件設定" class="headerlink" title="5. 柱狀圖的事件設定"></a>5. 柱狀圖的事件設定</h4><p>圖表都出來後，我們就要來處理事件的部分了，這邊用圖表的 <code>update()</code> 方法來為柱狀圖更新「繪圖區設定」，這樣所有數據列就都會被設定到了。那 <code>columnClick</code> 這個變數就是事件的回呼函式了，點擊發生時的邏輯就會寫在這裡面。</p><pre><code class="javascript">columnChart.update(&#123;  plotOptions: &#123;    series: &#123;      events: &#123; click: columnClick &#125;    &#125;  &#125;&#125;);</code></pre><p><strong>先來細數一下當點擊發生時會發生哪些事：</strong></p><ol><li>圓餅圖的數據點顏色會變成該部門數據列的顏色漸層</li><li>圓餅圖的數據點資料會改為該部門的各年齡人數資料</li><li>圓餅圖的標題會顯示該部門的的名稱</li></ol><br/><p>知道要做哪些事情後，就可以來設計邏輯了，主要概念會是點擊柱狀圖數據列時可以透過 <code>event</code> 事件物件來取得「數據列物件」，並利用數據列的顏色、資料和名稱來改變圓餅圖的設定。</p><pre><code class="javascript">function columnClick() &#123;  const &#123; color, points, name &#125; = event.point.series;  console.log(color, points, name);&#125;;</code></pre><p>首先顏色因為是自己設定的，所以已經知道會是 <code>rgb</code> 格式了，若要把圓餅圖數據點的顏色改成漸層色，可以轉成 <code>rgba</code> 後利用透明度做出漸層效果，所以可以先設計一個調整顏色透明度的輔助函式吧。</p><pre><code class="javascript">function rgbToRgba(rgb, alpha) &#123;  return rgb.replace(&quot;rgb&quot;, &quot;rgba&quot;).replace(&quot;)&quot;, `,$&#123;alpha&#125;)`);&#125;;</code></pre><p>再來就可以透過 <code>points</code> 來 Mapping 出我們要的數據點格式，並且使用 <code>setData()</code> 和 <code>setTitle()</code> 來更新圓餅圖了。</p><pre><code class="javascript">function columnClick() &#123;  const &#123; color, points, name &#125; = event.point.series;  let data = points.map((point, index) =&gt; (&#123;    y: point.y,    color: rgbToRgba(color, 1 - index * 0.05),    name: point.category  &#125;));  pieChart.series[0].setData(data);  pieChart.setTitle(&#123; text: `$&#123;name&#125;年齡佔比` &#125;);&#125;;</code></pre><br/><br/><h4 id="6-返回觀看整體佔比"><a href="#6-返回觀看整體佔比" class="headerlink" title="6. 返回觀看整體佔比"></a>6. 返回觀看整體佔比</h4><p>最後，把按鈕也加上原生的 <code>click</code> 事件，並在回呼函式中將圓餅圖改回最初的設定內容就大公告成了！</p><pre><code class="javascript">const overview = document.querySelector(&#39;.overview&#39;);overview.addEventListener(&quot;click&quot;, function() &#123;  pieChart.series[0].setData(piePoints);  pieChart.setTitle(&#123; text: `公司部門人數佔比` &#125;)&#125;);</code></pre><p><br/><br/></p><p>今天的範例比較著重在「事件屬性」和「方法」的使用，是否有幫助大家熟悉使用呢？另外如果對於「主題設定」、「繪圖區設定」、「格式屬性」來不太理解，也可以利用這個範例來複習一下。</p><p>接著明天，要用同一個資料案例來示範「雙層圓餅圖」的實作技巧。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10249008">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/JjXqYyz&quot;&gt;https://codepen.io/max-lee/pen/JjXqYyz&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blo</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 其他實用 Method</title>
    <link href="https://maxleebk.com/2020/10/04/highchart/highcharts-20/"/>
    <id>https://maxleebk.com/2020/10/04/highchart/highcharts-20/</id>
    <published>2020-10-04T03:47:00.000Z</published>
    <updated>2023-10-23T03:50:24.468Z</updated>
    
    <content type="html"><![CDATA[<p>Highcharts 的方法（Method）當然不止昨天介紹的「資料更新」這種類型，還有很多方便好用的 Method，而且有了它們，我們就可以在頁面的其他程式邏輯中操作圖表，讓圖表和網頁更密切的結合。</p><hr><h2 id="全域-Method"><a href="#全域-Method" class="headerlink" title="全域 Method"></a>全域 Method</h2><br/><p>當我們在網頁中引入 Highcharts 時，<code>window</code> 底下就會被註冊一個 <code>Highcharts</code> 物件，裡面會有許多函式可以使用，我習慣叫它們「全域方法」，因為你不需要建立圖表就可以在網頁中的任何位置呼叫它們，像是最重要的<code>Highcharts.chart()</code> 就是其中一個全域方法。</p><pre><code class="javascript">console.log(window.Highcharts);Highcharts.chart(container, options); // 建立一個新的圖表Highcharts.setOptions(options);       // 主題設定(全域性設定)</code></pre><p>而除了 <code>chart()</code>、<code>setOptions()</code> 這些核心函式外，<code>Highcharts</code> 底下其實還有很多輔助類型的函式供我們使用，像是在「格式化屬性」中介紹的 <code>numberFormat()</code> 就屬於輔助性的函式，而下面要介紹的都是屬於這類的 Method。</p><p><br/><br/></p><h4 id="Highcharts-arrayMax-data-Highcharts-arrayMin-data"><a href="#Highcharts-arrayMax-data-Highcharts-arrayMin-data" class="headerlink" title="# Highcharts.arrayMax(data) / Highcharts.arrayMin(data)"></a># Highcharts.arrayMax(data) / Highcharts.arrayMin(data)</h4><p><code>data: Array</code></p><p>這兩個 Method 非常的方便，可以在一組陣列裡找到最大／最小的值並將它返回。</p><pre><code class="javascript">console.log(Highcharts.arrayMax([3, 9, 4, 11, 2])); // 11</code></pre><br/><br/><h4 id="Highcharts-fireEvent-el-event"><a href="#Highcharts-fireEvent-el-event" class="headerlink" title="# Highcharts.fireEvent(el, event)"></a># Highcharts.fireEvent(el, event)</h4><p><code>el: targetObject</code> <code>event: String</code> </p><p>這個 Method 可以讓你主動觸發事件，第一個參數要傳入要觸發事件的目標，第二個參數則是事件名稱。</p><pre><code class="javascript">function clickHandle() &#123;  console.log(&quot;click fire&quot;);&#125;;var myChart = Highcharts.chart(container, &#123;  series: [&#123; data: [1,2,3], events: clickHandle &#125;]        &#125;);Highcharts.fireEvent(myChart.series[0], &quot;click&quot;);// &quot;click fire&quot;</code></pre><br/><br/><h4 id="Highcharts-merge-obj-obj-…"><a href="#Highcharts-merge-obj-obj-…" class="headerlink" title="# Highcharts.merge(obj, obj,…)"></a># Highcharts.merge(obj, obj,…)</h4><p><code>obj: Object</code> </p><p>你可用這個 Method 來把多個物件進行深層合併，就像主題設定、資料更新 Method 作的事情一樣。</p><pre><code class="javascript">let obj1 = &#123; a: 1, b: &#123; x: 5, y: 10 &#125; &#125;;let obj2 = &#123; b: &#123; z: 15 &#125;, c: 2 &#125;;let obj3 = &#123; a: 10, c: 20, d: 3 &#125;;let newObj = Highcharts.merge(obj1, obj2, obj3);// &#123; a: 10, b: &#123; x: 5, y: 10, z: 15&#125;, c: 20, d: 3 &#125;</code></pre><br/><blockquote><p>全域方法還有不少，但這邊就介紹個功能比較實用的，想看全部可以到  <strong><a href="https://api.highcharts.com/class-reference/Highcharts#toc12">官方文件</a></strong>。</p></blockquote><hr><h2 id="整體圖表-Method"><a href="#整體圖表-Method" class="headerlink" title="整體圖表 Method"></a>整體圖表 Method</h2><br/><blockquote><p>整體圖表的 Method 昨天有介紹過了，必須要先用 <code>Highcharts.chart()</code> 建立一個圖表後，才能透過「圖表物件」去呼叫下面這些方法。</p></blockquote><br/><h4 id="chart-setSize-width-height"><a href="#chart-setSize-width-height" class="headerlink" title="# chart.setSize(width, height)"></a># chart.setSize(width, height)</h4><p><code>width: Number</code> <code>height: Number</code></p><p>這個 Method 可以改變圖表的寬高尺寸，單純卻實用的功能。</p><pre><code class="javascript">var chart = Highcharts.chart(container, options);chart.setSize(800, 500);chart.setSize(800); // 只更改寬度chart.setSize(undefined, 800); // 只更改高度</code></pre><br/><br/><h4 id="chart-setTitle-options-chart-setSubtitle-options"><a href="#chart-setTitle-options-chart-setSubtitle-options" class="headerlink" title="# chart.setTitle(options) / chart.setSubtitle(options)"></a># chart.setTitle(options) / chart.setSubtitle(options)</h4><p><code>options: Object</code></p><p>這兩 Method 是用來更新主標題／副標題的設定的，只要把想更新的設定物件作為參數傳入即可。</p><pre><code class="javascript">var chart = Highcharts.chart(container, options);chart.setTitle(&#123;  text: &quot;新的標題文字&quot;,  style: &#123; color: &quot;red&quot; &#125;&#125;);</code></pre><br/><br/><h4 id="chart-destroy"><a href="#chart-destroy" class="headerlink" title="# chart.destroy()"></a># chart.destroy()</h4><p>如果你想要將一整個圖表移除可以呼叫這個 Method。</p><pre><code class="javascript">var chart = Highcharts.chart(container, options);chart.destroy();</code></pre><hr><h2 id="數據列-Method"><a href="#數據列-Method" class="headerlink" title="數據列 Method"></a>數據列 Method</h2><br/><blockquote><p>數據列 Method 也和昨天說明的一樣，必須要取得你要操作的「數據列物件」後才能呼叫其方法。</p></blockquote><br/><h4 id="series-setVisible-visible"><a href="#series-setVisible-visible" class="headerlink" title="# series.setVisible(visible)"></a># series.setVisible(visible)</h4><p><code>visible: Boolean|undefined</code></p><p>這個 Method 可以用來顯示或隱藏數據列，傳入 <code>true</code> 作為參數則顯示，傳入 <code>false</code> 則隱藏，如果不傳參就會自動進行切換。</p><pre><code class="javascript">var chart = Highcharts.chart(container, &#123;  series: [&#123; data: [1, 2, 3] &#125;]&#125;);chart.series[0].setVisible(false); // 隱藏，等同 hide()chart.series[0].setVisible(true); // 顯示，等同 show()chart.series[0].setVisible(); // 自動切換 顯示&lt;=&gt;隱藏</code></pre><br/><br/><h4 id="series-getName"><a href="#series-getName" class="headerlink" title="# series.getName()"></a># series.getName()</h4><p>一個很簡單的 Method，呼叫後可以取得該數據列的名字。</p><pre><code class="javascript">var chart = Highcharts.chart(container, &#123;  series: [    &#123; name: &quot;數據列A&quot;, data: [1, 2, 3] &#125;,    &#123; name: &quot;數據列B&quot;, data: [1, 2, 3] &#125;  ]&#125;);let result = chart.series.map(series =&gt; series.getName());// [&quot;數據列A&quot;, &quot;數據列B&quot;]</code></pre><br/><br/><h4 id="series-is-type"><a href="#series-is-type" class="headerlink" title="# series.is(type)"></a># series.is(type)</h4><p><code>visible: String</code></p><p>也是一個很單純的 Method，可以幫你判斷一組數據列的類型，例如以 <code>&quot;column&quot;</code> 作為參數，便會判斷此數據列是否為柱狀圖並回傳布林值。</p><pre><code class="javascript">var chart = Highcharts.chart(container, &#123;  chart: &#123; type: &quot;column&quot; &#125;  series: [    &#123; type: &quot;line&quot;, data: [1, 2, 3] &#125;,    &#123; data: [1, 2, 3] &#125;  ]&#125;);let result = chart.series.map(series =&gt; series.is(&quot;column&quot;));// [false, true]</code></pre><hr><h2 id="數據點-Method"><a href="#數據點-Method" class="headerlink" title="數據點 Method"></a>數據點 Method</h2><br/><blockquote><p>數據點 Method 也是一樣，必須要取得你要操作的「數據點物件」後才能呼叫其方法。</p></blockquote><br/><h4 id="point-getClassName"><a href="#point-getClassName" class="headerlink" title="# point.getClassName()"></a># point.getClassName()</h4><p>假如你有為數據點設定 <code>className</code> 屬性，那你就可以透過這個 Method 來得到其屬性值。</p><pre><code class="javascript">var chart = Highcharts.chart(container, &#123;  series: [&#123;     data: [      &#123;className: &quot;point-1&quot;, y: 10&#125;,      &#123;className: &quot;point-2&quot;, y: 20&#125;,    ]   &#125;]&#125;);let result = chart.series[0].data.map(point =&gt; point.getClassName());// [&quot;point-1&quot;, &quot;point-2&quot;]</code></pre><br/><br/><h4 id="point-onMouseOver"><a href="#point-onMouseOver" class="headerlink" title="# point.onMouseOver()"></a># point.onMouseOver()</h4><p>這個 Method 可以主動出發數據點的 <code>mouseOver</code> 事件，而且就算你沒有設定事件屬性，依然會使數據點進入聚焦狀態。</p><pre><code class="javascript">chart.series[0].data[0].onMouseOver();</code></pre><br/><br/><h4 id="point-select"><a href="#point-select" class="headerlink" title="# point.select()"></a># point.select()</h4><p>這個 Method 可以使用來選取數據點，如果有設定 <code>select</code> 事件的話也會被觸發，而且可以無視 <code>allowPointSelect</code> 的設定。</p><pre><code class="javascript">var chart = Highcharts.chart(container, &#123;  series: [&#123;    allowPointSelect: false,    data: [1, 2, 3, 4]  &#125;]&#125;);chart.series[0].data[3].select(); // 依然可以選取數據點</code></pre><p><br/><br/></p><p>今天介紹的 Method 其實不多，而且使用方式也不是非常複雜，所以就不特別附上範例了。</p><p>隨著這個章節的結束，我們也算是掌握了 Highcharts 的核心基礎，包括圖表元素、主題、響應式設定..等「基本API」，以及事件處理、圖表操作的「進階API」。而後面幾天的時間則會開始分享一些小技巧以及進階圖表的實作，透過簡單的範例來讓大家更熟悉 Highcharts 的應用。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10248806">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Highcharts 的方法（Method）當然不止昨天介紹的「資料更新」這種類型，還有很多方便好用的 Method，而且有了它們，我們就可以在頁面的其他程式邏輯中操作圖表，讓圖表和網頁更密切的結合。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;全域-Method&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 資料更新 Method</title>
    <link href="https://maxleebk.com/2020/10/03/highchart/highcharts-19/"/>
    <id>https://maxleebk.com/2020/10/03/highchart/highcharts-19/</id>
    <published>2020-10-03T02:52:00.000Z</published>
    <updated>2023-10-23T03:50:24.460Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/qBZvgGv">https://codepen.io/max-lee/pen/qBZvgGv</a></strong></p></blockquote><p>在 Highcharts 中呢，除了五花八門的設定屬性之外，還有不少內建的函式可以操作圖表，這種函式通常都稱之為「方法（Method）」。</p><p>圖表最重要的目的在於呈現資料，而資料在網頁中不僅重要卻還時常變化，時常都會利用非同步請求來取得資料，而在請求回應後就需要有辦法改變圖表中的資料或設定，所以今天就是要來專門講講這些負責 <strong>更新圖表資料或設定</strong> 的 Method。</p><hr><h2 id="資料更新-Method"><a href="#資料更新-Method" class="headerlink" title="資料更新 Method"></a>資料更新 Method</h2><br/><p>現在繪製圖表對我們來說已經駕輕就熟了，但目前圖表都是靜態的，頂多綁個事件增加一下互動功能，但假如今天想要做一個隨時更新資料的「動態圖表」好像就辦不到了。好在 Highcharts 提供了一些 Method 來讓我們可以在 <strong>圖表載入完畢後</strong> 還能操作它。</p><blockquote><p>昨天在事件屬性中有提到的 <code>show()</code>、<code>update()</code>…等等都屬於 Method，不過今天先專注在「更新」這類的 Method 上。</p></blockquote><pre><code class="javascript">// 創建一個圖表，設定內容省略var chart = Highcharts.chart(container, options);// 圖表的更新 Methodchart.update();chart.addSeries();// 數據列的更新 Methodchart.series[0].update();chart.series[0].remove();chart.series[0].setData();chart.series[0].addPoint();chart.series[0].removePoint();// 數據點的更新 Methodchart.series[0].data[0].update();chart.series[0].data[0].remove();</code></pre><br/><p>不曉得大家有沒有好奇過，為什麼在創建圖表的時候要用一個變數來儲存呢？原來在創建圖表的時候，Highcharts 會建立一個圖表的 <strong>實例(Instance)</strong>，其實也就是前面提過的「圖表物件」，裡面也包含了數據列、數據點、座標軸等等區塊的實例／物件。</p><p>而每個實例裡就會有它們專屬的 Method，當要使用時就必須從中索引後呼叫，所以才需要用變數接住實例，好方便我們呼叫。</p><hr><h2 id="整體圖表更新-Method"><a href="#整體圖表更新-Method" class="headerlink" title="整體圖表更新 Method"></a>整體圖表更新 Method</h2><br/><blockquote><p>將圖表實例儲存於變數中是必要的，以此才能選取到該圖表並呼叫其方法。</p></blockquote><br/><h4 id="chart-update-options"><a href="#chart-update-options" class="headerlink" title="# chart.update(options)"></a># chart.update(options)</h4><p><code>options: Object</code></p><p>這個 Method 可以更新圖表內的任何設定，包括數據列、座標軸等等都能夠更新，而使用方式便是將要更新<br>的 <code>options</code> 物件以參數傳入，而 Highcharts 一樣會幫你做深層的合併，所以你不需要把未更動的設定再撰寫一遍。</p><pre><code class="javascript">var chart = Highcharts.chart(container, &#123;  title: &#123; text: &quot;我的圖表&quot; &#125;,  credits: &#123; enabled: false &#125;,  series: [    &#123; name: &quot;數據列1&quot;, data: [1,2,3] &#125;,    &#123; name: &quot;數據列2&quot;, data: [4,5,6] &#125;  ]        &#125;);// 只有第一組數據列會被更新，但第二組並不會消失chart.update(&#123;  title: &#123; text: &quot;我的圖表(已更新)&quot; &#125;,  series: [&#123; data: [10,20,30] &#125;]&#125;);</code></pre><br/><br/><h4 id="chart-addSeries-series"><a href="#chart-addSeries-series" class="headerlink" title="# chart.addSeries(series)"></a># chart.addSeries(series)</h4><p><code>series: Object</code></p><p>昨天其實有簡單帶到這個 Method，它可以在圖表中新增一組新的數據列，只要把新數據列的設定物件傳進參數即可。</p><pre><code class="javascript">chart.addSeries(&#123;  name: &quot;新數據列&quot;,  dataLabels: &#123; enabled: true &#125;,  data: [[10,20], [30,40], [50,60]]&#125;);</code></pre><hr><h2 id="數據列更新-Method"><a href="#數據列更新-Method" class="headerlink" title="數據列更新 Method"></a>數據列更新 Method</h2><br/><blockquote><p>要呼叫數據列的 Method 需要透過圖表實例裡的 <code>series</code> 陣列裡去找到你要操作的數據列。</p></blockquote><br/><h4 id="series-update-options"><a href="#series-update-options" class="headerlink" title="# series.update(options)"></a># series.update(options)</h4><p><code>options: Object</code></p><p>和前面的 <code>chart.update()</code> 是一樣概念，將你要更新的數據列設定物件作為參數傳入函式中，即可改變數據列的設定。</p><pre><code class="javascript">var chart = Highcharts.chart(container, &#123;  series: [    &#123; name: &quot;數據列1&quot;, data: [1,2,3] &#125;,    &#123; name: &quot;數據列2&quot;, data: [4,5,6] &#125;  ]&#125;);// 第二組數據列將被更新chart.series[1].update(&#123;  name: &quot;數據列2(被更新)&quot;,  color: &quot;red&quot;,  data: [40, 50, 60]&#125;);</code></pre><br/><br/><h4 id="series-remove"><a href="#series-remove" class="headerlink" title="# series.remove()"></a># series.remove()</h4><p>這個 Method 就單純很多，選取你要的數據列後呼叫這個方法，該數據點便會從圖表中移除。</p><pre><code class="javascript">chart.series[0].remove();</code></pre><br/><br/><h4 id="series-setData-data"><a href="#series-setData-data" class="headerlink" title="# series.setData(data)"></a># series.setData(data)</h4><p><code>data: Array</code></p><p>如果僅僅只是要改變數據列的 <code>data</code> 屬性，那可以選擇使用這個 Method，而不需要使用 <code>update()</code>，呼叫時只要傳入新的數據點陣列即可。</p><pre><code class="javascript">var chart = Highcharts.chart(container, &#123;  series: [&#123; data: [1,2,3] &#125;]&#125;);// 數據列的數據將會改變chart.series[0].setData([4,5,6]);</code></pre><br/><br/><h4 id="series-addPoint-point"><a href="#series-addPoint-point" class="headerlink" title="# series.addPoint(point)"></a># series.addPoint(point)</h4><p><code>point: Number|Array|Object</code></p><p>看過前面的 <code>addSeries()</code> 之後應該很好理解，就是在你要操作的數據列中新增一個數據點，而傳入的參數可以接受任何形式的數據點格式，形式種類之前在「數據點設定」的章節中有介紹過。</p><pre><code class="javascript">chart.series[0].addPoint(&#123;x: 10, y: 10&#125;);</code></pre><br/><br/><h4 id="series-removePoint-index"><a href="#series-removePoint-index" class="headerlink" title="# series.removePoint(index)"></a># series.removePoint(index)</h4><p><code>index: Number</code></p><p>在你呼叫這個 Method 時，會從你正在操作的數據列中移除一個數據點，而你必須傳入該數據點的索引值，Highcharts 才知道要移除的是哪一個。</p><pre><code class="javascript">var chart = Highcharts.chart(container, &#123;  series: [&#123; data: [6,7,8,9,10] &#125;]&#125;);// 第三個數據點將會被移除chart.series[0].removePoint(2);</code></pre><hr><h2 id="數據點更新-Method"><a href="#數據點更新-Method" class="headerlink" title="數據點更新 Method"></a>數據點更新 Method</h2><br/><blockquote><p>要呼叫數據點的 Method 需要透過圖表實例裡的 <code>series.data</code> 陣列或 <code>series.points</code> 陣列裡去找到你要操作的數據點。</p></blockquote><br/><h4 id="point-update-options"><a href="#point-update-options" class="headerlink" title="# point.update(options)"></a># point.update(options)</h4><p><code>options: Number|Array|Object</code></p><p>和前面的所有的 <code>update</code> 方法都是一樣的，將你要更新的數據點設定作為參數傳入函式中，即可改變數據點的設定，不過此 Method 的參數可以接受任何數據點設定格式。</p><pre><code class="javascript">var chart = Highcharts.chart(container, &#123;  series: [&#123; data: [10, 11, 12, 13, 14] &#125;]&#125;);// 第四個數據點將被更新chart.series[0].data[3].update(&#123; y: 20, color: &quot;red&quot; &#125;);</code></pre><br/><br/><h4 id="point-remove"><a href="#point-remove" class="headerlink" title="# point.remove()"></a># point.remove()</h4><p>也是很單純的一個 Method，選取好要操作的數據點後並呼叫函式，便會將該數據點從數據列中移除。</p><pre><code class="javascript">chart.series[0].data[3].remove();</code></pre><hr><h2 id="指定選取"><a href="#指定選取" class="headerlink" title="指定選取"></a>指定選取</h2><br/><p>我們把今天的更新 Method 都認識完了，不過卻發現，若是想要操作數據列或數據點似乎稍嫌麻煩，必須先知道他們的索引值，還要一層層往裡面找才能選到，所以這邊要額外介紹兩個設定屬性：</p><br/><br/><h4 id="series-id-series-data-id"><a href="#series-id-series-data-id" class="headerlink" title="# series.id / series.data.id"></a># series.id / series.data.id</h4><p><code>型別: String</code> <code>預設: undefined</code></p><p>這兩個屬性可以為數據列／數據點設定 ID Name，這樣就可以透過 <code>chart.get()</code> 這個 Method 來直接選取它們。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  series: [&#123;     id: &quot;mySeries&quot;,    data: [1, 2, &#123;y: 3, id: &quot;myPoint&quot; &#125;]  &#125;]&#125;);let series = myChart.get(&quot;mySeries&quot;);let point = myChart.get(&quot;myPoint&quot;);</code></pre><hr><p>今天認識的這些 Method 都可以在圖表載入完成後去操作圖表，好處在於可以動態的更新圖表中的資料或設定，讓圖表可以跟整個網頁互動，或是利用非同步事件來做到下面這樣的效果，希望大家吸收的還順利，明天會繼續介紹其他的常用 Method。</p><img src="dynamic.gif" style="max-width: 600px; margin: 24px auto;" /><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10248326">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/qBZvgGv&quot;&gt;https://codepen.io/max-lee/pen/qBZvgGv&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blo</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 事件屬性</title>
    <link href="https://maxleebk.com/2020/10/02/highchart/highcharts-18/"/>
    <id>https://maxleebk.com/2020/10/02/highchart/highcharts-18/</id>
    <published>2020-10-02T03:22:00.000Z</published>
    <updated>2023-10-23T03:50:24.456Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/bGpzoZr">https://codepen.io/max-lee/pen/bGpzoZr</a></strong><br>避免文章篇幅過長，沒辦法每個屬性都利用圖片示意，所以記得善用範例來測試不太了解的屬性。</p></blockquote><p>第一天就有跟各位說過，Highcharts 除了豐富的圖表設定外，另一大看點就是可以做到圖表的事件監聽，讓我們的圖表不僅僅只是展示資料，更是一個可以跟使用者互動的介面，所以今天就要來好好講講「事件屬性」。</p><hr><h2 id="事件屬性"><a href="#事件屬性" class="headerlink" title="事件屬性"></a>事件屬性</h2><br/><p>事件屬性和格式化屬性一樣，分佈在各個圖表區塊當中，不過基本上「圖表事件」、「數據列事件」、「數據點事件」這三個就能囊括八成以上的應用了，下面就大致先讓大家看看有哪些事件名稱吧。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  chart: &#123;    events: &#123; // 圖表整體事件屬性      load: function() &#123;&#125;,      redraw: function() &#123;&#125;,      render: function() &#123;&#125;,      addSeries: function() &#123;&#125;,      click: function() &#123;&#125;    &#125;  &#125;,  series: [&#123;    events: &#123; // 數據列事件屬性，繪圖區設定亦同      click: function() &#123;&#125;,      mouseOver: function() &#123;&#125;,      mouseOut: function() &#123;&#125;,      show: function() &#123;&#125;,      hide: function() &#123;&#125;,      legendItemClick: function() &#123;&#125;    &#125;,      data: [&#123;      events: &#123; // 數據點事件屬性        click: function() &#123;&#125;,        mouseOver: function() &#123;&#125;,        mouseOut: function() &#123;&#125;,        select: function() &#123;&#125;,        unselect: function() &#123;&#125;,        update: function() &#123;&#125;,        remove: function() &#123;&#125;      &#125;    &#125;]  &#125;]&#125;);</code></pre><p>其實這些事件屬性都不會很複雜，有部分跟 DOM 元素的事件也大同小異，而且設定上也很簡單，就是給予一個回呼函式 (Call-Back) 就好了，未來只要事件觸發了，Highcharts 就會幫你執行函式囉。</p><br/><br/><h4 id="this-和-event-物件"><a href="#this-和-event-物件" class="headerlink" title="# this 和 event 物件"></a># this 和 event 物件</h4><p>在一般 JavaScript 的事件中，<code>this</code> 代表的是被賦予事件監聽的那個 DOM 元素，在 Highcharts 也是類似的，<code>this</code> 代表的就是那個被設定事件的圖表物件、數據列物件或數據點物件。</p><p>相同地，你可以透過參數的設定去接住回呼函式中被 Highcharts 傳入的 <code>event</code> 物件，而不同的事件類型，<code>event</code> 物件會提供不同的屬性內容。</p><pre><code class="javascript">events: &#123;  click: function(event) &#123;    console.log(this, event)  &#125;&#125;</code></pre><p>透過 <code>this</code> 與 <code>event</code> 所提供的內容，我們就可以利用這些資訊來達到許多複雜互動與操作。</p><br/><blockquote><p>由於實在是很難特別想一些應用來給大家做演示，所以今天主要會介紹的是事件的觸發時機以及 <code>event</code> 物件的資料內容。</p></blockquote><hr><h2 id="圖表整體事件"><a href="#圖表整體事件" class="headerlink" title="圖表整體事件"></a>圖表整體事件</h2><br/><blockquote><p>圖表整體事件中，<code>this</code> 會是「圖表物件」，內容包含了該圖表的各種屬性內容與方法。</p></blockquote><br/><h4 id="chart-events-load"><a href="#chart-events-load" class="headerlink" title="# chart.events.load"></a># chart.events.load</h4><p><code>型別: Function</code> <code>預設: undefined</code></p><p>當圖表載入完成後觸發，<code>event</code> 物件中則沒有什麼特別的屬性，倒是 <code>event.target</code> 和 <code>this</code> 一樣，提供的是「圖表物件」。</p><br/><br/><h4 id="chart-events-redraw"><a href="#chart-events-redraw" class="headerlink" title="# chart.events.redraw"></a># chart.events.redraw</h4><p><code>型別: Function</code> <code>預設: undefined</code></p><p>當圖表重新繪圖時觸發，包括「尺寸改變」、「數據列、數據點或座標軸的變更」，<code>event</code> 物件的內容則與 <code>load</code> 事件相同。</p><br/><br/><h4 id="chart-events-render"><a href="#chart-events-render" class="headerlink" title="# chart.events.render"></a># chart.events.render</h4><p><code>型別: Function</code> <code>預設: undefined</code></p><p>這個事件觸發時機等於 <code>load</code> 事件加上 <code>redraw</code> 事件，而 <code>event</code> 物件的內容也與它們相同。</p><br/><br/><h4 id="chart-events-addSeries"><a href="#chart-events-addSeries" class="headerlink" title="# chart.events.addSeries"></a># chart.events.addSeries</h4><p><code>型別: Function</code> <code>預設: undefined</code></p><p>這個事件的觸發時機比較特別，當有一個新的數據列被加進圖表時會觸發，也就是使用 <code>addSeries()</code> 這個方法的時候會觸發，而它的 <code>event</code> 物件中有一個 <code>options</code> 屬性，有著該次加入的數據列內容。</p><p>另外你也可以在函式中返回 <code>false</code> 就可以阻止這次的新增，如果成功新增也會觸發 <code>redraw</code> 和 <code>render</code> 事件。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  chart: &#123;    events: &#123;      addSeries: function(event) &#123;        console.log(event.options)        return event.options.data.length &gt;= 5;        // 如果要被加入的數據列少於五個數據點，就不加入      &#125;    &#125;  &#125;&#125;);myChart.addSeries(&#123;  name: &quot;newSeries&quot;,  data: [12, 15, 12, 5]&#125;)// console: &#123; name: &quot;newSeries&quot;, data: [12, 15, 12, 5] &#125;</code></pre><br/><br/><h4 id="chart-events-click"><a href="#chart-events-click" class="headerlink" title="# chart.events.click"></a># chart.events.click</h4><p><code>型別: Function</code> <code>預設: undefined</code></p><p>當你點擊「繪圖區」時會觸發這個事件，它的 <code>event</code> 物件除了有滑鼠事件的相關屬性外，還有提供「座標軸物件」，甚至還有「該點擊處」在圖表中所代表的Ｘ／Ｙ軸數值。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  chart: &#123;    events: &#123;      click: function(event) &#123;        // 拿到點擊處的Ｘ／Ｙ數值，並加進數據列當中        this.series[0].addPoint([          event.xAxis[0].value,          event.yAxis[0].value,        ])      &#125;    &#125;  &#125;&#125;);</code></pre><hr><h2 id="數據列事件"><a href="#數據列事件" class="headerlink" title="數據列事件"></a>數據列事件</h2><br/><blockquote><p>數據列事件中，<code>this</code> 會是「數據列物件」，內容包含了該數據列的各種屬性內容與方法。</p></blockquote><br/><h4 id="series-events-click"><a href="#series-events-click" class="headerlink" title="# series.events.click"></a># series.events.click</h4><p><code>型別: Function</code> <code>預設: undefined</code></p><p>當數據列被點擊時會觸發這個事件，由於是滑鼠事件，所以 <code>event</code> 中會有鼠標的相關資訊，另外 <code>event.point</code> 會提供你點擊時，處於聚焦狀態的數據點之「數據點物件」。</p><img src="seriesClick.png" style="max-width: 800px; margin: 16px auto 0;" /><br/><br/><h4 id="series-events-mouseOver"><a href="#series-events-mouseOver" class="headerlink" title="# series.events.mouseOver"></a># series.events.mouseOver</h4><p><code>型別: Function</code> <code>預設: undefined</code></p><p>當鼠標使數據列聚焦時就會觸發這個事件，要注意的是有一些圖表類型 (例如折線圖)，有預設開啟 <code>series.stickyTracking</code> 這個屬性，導致鼠標進入繪圖區時，一定會使數據列被聚焦。</p><p>它的 <code>event</code> 物件比較沒那麼特殊，當中的 <code>target</code> 屬性和 <code>this</code> 一樣，都是「數據列物件」。</p><img src="seriesOver.png" style="max-width: 800px; margin: 16px auto 0;" /><br/><br/><h4 id="series-events-mouseOut"><a href="#series-events-mouseOut" class="headerlink" title="# series.events.mouseOut"></a># series.events.mouseOut</h4><p><code>型別: Function</code> <code>預設: undefined</code></p><p>當鼠標使數據列從聚焦轉為失焦時就會觸發，其他內容與 <code>mouseOver</code> 都一樣。</p><br/><br/><h4 id="series-events-show"><a href="#series-events-show" class="headerlink" title="# series.events.show"></a># series.events.show</h4><p><code>型別: Function</code> <code>預設: undefined</code></p><p>當你將數據列從隱藏狀態改為顯示狀態時，就會觸這個事件，另外這個動作也會同時觸發前面介紹的 <code>redraw</code> 和 <code>render</code> 事件。</p><p>而它的 <code>event</code> 物件也是只有 <code>target</code> 屬性而已，內容為「數據列物件」。</p><br/><br/><h4 id="series-events-hide"><a href="#series-events-hide" class="headerlink" title="# series.events.hide"></a># series.events.hide</h4><p><code>型別: Function</code> <code>預設: undefined</code></p><p>就是 <code>show</code> 的相反版本，其餘並無不同。</p><blockquote><p>大部分都是透過點擊圖例來顯示／隱藏數據列，但你也可以使用 <code>show()</code>、<code>hide()</code> 這兩個數據列方法來操作，可見本章節範例。</p></blockquote><br/><br/><h4 id="series-events-legendItemClick"><a href="#series-events-legendItemClick" class="headerlink" title="# series.events.legendItemClick"></a># series.events.legendItemClick</h4><p><code>型別: Function</code> <code>預設: undefined</code></p><p>這個屬性是你只要點擊圖例就會觸發，因此觸發順序應該會是 <code>legendItemClick</code> 才接到 <code>show</code> 或 <code>hide</code>，另外你還可以在回呼函式中返回一個 <code>false</code>，那就會使本次點擊圖例的效果失效。</p><p>它的 <code>event</code> 物件比前兩者多了一個 <code>browserEvent</code>，內容為滑鼠事件的相關屬性。</p><pre><code class="javascript">series: [&#123;  events: &#123;    legendItemClick: function(event)&#123;      // event.target.visible 為數據列目前是否顯示      // 會使數據點只許隱藏，卻無法再次顯示      return event.target.visible;    &#125;   &#125;&#125;] </code></pre><br/><br/><hr><h2 id="數據點事件"><a href="#數據點事件" class="headerlink" title="數據點事件"></a>數據點事件</h2><br/><blockquote><p>數據點事件中，<code>this</code> 會是「數據點物件」，內容包含了該數據點的各種屬性內容與方法。</p></blockquote><br/><h4 id="series-data-events-click"><a href="#series-data-events-click" class="headerlink" title="# series.data.events.click"></a># series.data.events.click</h4><p><code>型別: Function</code> <code>預設: undefined</code></p><p>會在點擊數據點時觸發，要注意的是，只要有數據點是「聚焦狀態」，點擊到數據列的任一位置都會觸發此事件，也就是說鼠標並非要在「點」上。而它的 <code>event</code> 物件一樣有滑鼠事件的相關屬性，且 <code>point</code> 屬性中也有該數據點的「數據點物件」，和數據列的點擊事件只差在 <code>this</code> 的不同。</p><br/><br/><h4 id="series-data-events-mouseOver"><a href="#series-data-events-mouseOver" class="headerlink" title="# series.data.events.mouseOver"></a># series.data.events.mouseOver</h4><p><code>型別: Function</code> <code>預設: undefined</code></p><p>當鼠標使數據點聚焦時就觸發，依然受到 <code>series.stickyTracking</code> 屬性影響，而 <code>event</code> 物件也是只有 <code>target</code> 屬性，內容與 <code>this</code> 一樣是「數據點物件」。</p><br/><br/><h4 id="series-data-events-mouseOut"><a href="#series-data-events-mouseOut" class="headerlink" title="# series.data.events.mouseOut"></a># series.data.events.mouseOut</h4><p><code>型別: Function</code> <code>預設: undefined</code></p><p>當鼠標使數據點從聚焦轉為失焦時觸發，其他內容與 <code>mouseOver</code> 都一樣。</p><br/><br/><h4 id="series-data-events-select"><a href="#series-data-events-select" class="headerlink" title="# series.data.events.select"></a># series.data.events.select</h4><p><code>型別: Function</code> <code>預設: undefined</code></p><p>在你選取了數據點時會觸發這個事件，此事件必須在 <code>series.allowPointSelect</code> 開啟的狀態下才能作用，<code>event</code> 物件的內容和 <code>mouse</code> 系列相同。此外你可以透過回傳 <code>false</code> 來取消選取動作：</p><pre><code class="javascript">data: [&#123;  y: 3,  events: &#123;    select: function()&#123;      // 這個數據點將無法被選取      return this.y &gt; 5     &#125;   &#125;&#125;]</code></pre><br/><br/><h4 id="series-data-events-unselect"><a href="#series-data-events-unselect" class="headerlink" title="# series.data.events.unselect"></a># series.data.events.unselect</h4><p><code>型別: Function</code> <code>預設: undefined</code></p><p>當數據點被取消選取時觸發，其餘特性均與 <code>select</code> 相同。</p><br/><br/><h4 id="series-data-events-update"><a href="#series-data-events-update" class="headerlink" title="# series.data.events.update"></a># series.data.events.update</h4><p><code>型別: Function</code> <code>預設: undefined</code></p><p>當數據點被更新時會觸發事件，它與 <code>addSeries</code> 很類似，<code>event</code> 物件中一樣有 <code>options</code> 屬性來提供這次要更新的內容，並且也可以在函式中返回 <code>false</code> 來阻止這次更新，且數據點成功更新也會觸發 <code>redraw</code> 和 <code>render</code> 事件。</p><br/><blockquote><p>要更新數據點要使用 <code>update()</code> 這個數據點方法，請見本章節範例。</p></blockquote><br/><br/><h4 id="series-data-events-remove"><a href="#series-data-events-remove" class="headerlink" title="# series.data.events.remove"></a># series.data.events.remove</h4><p><code>型別: Function</code> <code>預設: undefined</code></p><p>當數據點被移除時會觸發，<code>event.target</code> 和 <code>this</code> 中都會有此次被刪除的數據點之「數據點物件」，且一樣可以返回 <code>false</code> 來阻止這次刪除，且數據點成功刪除也會觸發 <code>redraw</code> 和 <code>render</code> 事件。</p><br/><blockquote><p>要更新數據點要使用 <code>remove()</code> 這個數據點方法，請見本章節範例。</p></blockquote><p><br/><br/></p><p>今天把比較主力的幾個事件屬性介紹完畢，非常強烈建議大家到今天的範例裡去玩玩看，我準備的應該算很周全，可以讓大家知道各件事的機制以及觸發順序，明天的話則是要跟大家介紹 Highcharts 裡一些更新資料與設定的方法 (method)。</p><p>像是今天就有稍微帶到 <code>addSeries()</code> 和 <code>update()</code>…等等，在下個章節中都會比較詳細的介紹它們。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10247862">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/bGpzoZr&quot;&gt;https://codepen.io/max-lee/pen/bGpzoZr&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;避免文章篇幅</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 響應式設定</title>
    <link href="https://maxleebk.com/2020/10/01/highchart/highcharts-17/"/>
    <id>https://maxleebk.com/2020/10/01/highchart/highcharts-17/</id>
    <published>2020-10-01T05:13:00.000Z</published>
    <updated>2023-10-23T03:50:24.368Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/NWNeevP">https://codepen.io/max-lee/pen/NWNeevP</a></strong></p></blockquote><p>近年來響應式網站已成為主流，尤其當網站需要支援行動裝置的使用時，RWD 的設定勢必要考慮進去，好加在 Highcharts 本來就對各種瀏覽器、裝置、系統有很高的相容性，而且還提供了「響應式設定」讓我們隨視窗大小的改變而修改圖的設定。</p><hr><h2 id="響應式設定-基本介紹"><a href="#響應式設定-基本介紹" class="headerlink" title="響應式設定 - 基本介紹"></a>響應式設定 - 基本介紹</h2><br/><p>一般在設計響應式網站時，肯定會使用 CSS 的媒體查詢 (Media queries) 來規範元素樣式要在什麼樣的視窗尺寸下做何種變化，而 Highcharts 的「響應式設定」也是類似原理。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  responsive: &#123; // 響應式設定    rules: [&#123;      condition: &#123;&#125;,     // 條件設定      chartOptions: &#123;&#125;   // 圖表options物件    &#125;]   &#125;&#125;);</code></pre><hr><h2 id="響應式設定-條件設定"><a href="#響應式設定-條件設定" class="headerlink" title="響應式設定 - 條件設定"></a>響應式設定 - 條件設定</h2><br/><p>Media queries 在撰寫時都會相下面這樣去訂定變化的條件時機，其中 <code>max-width:790px</code> 就是樣式的轉變時機。</p><pre><code class="css">/* 在視窗寬度小於 790px 時，做以下變化 */@media screen and (max-width:790px) &#123;   color: red;  border: 1px solid #292929;&#125;</code></pre><p>而 Highcharts 的「響應式設定」也是一樣的，同樣要定義圖表設定變化的條件，而 <code>condition</code> 屬性可以幫我們做到這件事，不過…</p><br/><blockquote><p>Highcharts 監聽的並非視窗寬高，而是圖表本身的寬高，這點非常重要，千萬別搞錯了！</p></blockquote><br/><br/><h4 id="responsive-rules-condition-maxWidth"><a href="#responsive-rules-condition-maxWidth" class="headerlink" title="# responsive.rules.condition.maxWidth"></a># responsive.rules.condition.maxWidth</h4><p><code>型別: Number</code> <code>預設: undefined</code></p><p>當圖表的寬度小於這個屬性設定的值時，便會發生設定變化。</p><br/><br/><h4 id="responsive-rules-condition-maxHeight"><a href="#responsive-rules-condition-maxHeight" class="headerlink" title="# responsive.rules.condition.maxHeight"></a># responsive.rules.condition.maxHeight</h4><p><code>型別: Number</code> <code>預設: undefined</code></p><p>當圖表的寬度小於這個屬性設定的值時，便會發生設定變化。</p><br/><br/><h4 id="responsive-rules-condition-minWidth"><a href="#responsive-rules-condition-minWidth" class="headerlink" title="# responsive.rules.condition.minWidth"></a># responsive.rules.condition.minWidth</h4><p><code>型別: Number</code> <code>預設: 0</code></p><p>當圖表的寬度大於這個屬性設定的值時，便會發生設定變化。</p><br/><br/><h4 id="responsive-rules-condition-minHeight"><a href="#responsive-rules-condition-minHeight" class="headerlink" title="# responsive.rules.condition.minHeight"></a># responsive.rules.condition.minHeight</h4><p><code>型別: Number</code> <code>預設: 0</code></p><p>當圖表的高度大於這個屬性設定的值時，便會發生設定變化。</p><br/><br/><p>看完屬性的介紹後，應該會發現「響應式設定」真的就和 <code>@media</code> 一樣，只要將條件設定完畢，Highcharts 就會自動偵測圖表的大小了。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  responsive: &#123;    rules: [&#123;      // 當圖表寬度在 768 ~ 1280 之間，就會發生設定變化      condition: &#123;        maxWidth: 1280,        minWidth: 768,      &#125;    &#125;]   &#125;&#125;);</code></pre><hr><h2 id="響應式設定-圖表變化"><a href="#響應式設定-圖表變化" class="headerlink" title="響應式設定 - 圖表變化"></a>響應式設定 - 圖表變化</h2><br/><p>有了條件，剩下就是讓圖表產生改變了，這時候 <code>chartOptions</code> 屬性就是「響應式設定」中的主角了。</p><br/><h4 id="responsive-rules-chartOptions"><a href="#responsive-rules-chartOptions" class="headerlink" title="# responsive.rules.chartOptions"></a># responsive.rules.chartOptions</h4><p><code>型別: Object</code> <code>預設: undefined</code></p><p>物件內容就是你希望改變的圖表設定及其值，前面所有介紹過的圖表元素設定都可以改變！</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  responsive: &#123;    rules: [&#123;      condition: &#123;&#125;      chartOptions: &#123;        chart: &#123;&#125;,       // 圖表整體設定        credits: &#123;&#125;,     // 版權標籤設定        title: &#123;&#125;,       // 標題設定        subtitle: &#123;&#125;,    // 副標題設定        caption: &#123;&#125;,     // 圖表說明設定        colors: [],      // 顏色設定        xAxis: [&#123;&#125;],     // Ｘ座標軸設定        yAxis: [&#123;&#125;],     // Ｙ座標軸設定        legend: &#123;&#125;,      // 圖例設定        tooltip: &#123;&#125;,     // 提示框設定        plotOptions: &#123;&#125;, // 繪圖區設定        series: [&#123;&#125;]     // 數據列設定      &#125;    &#125;]   &#125;&#125;);</code></pre><p>其實全部列出來才發現，我們已經認識了一大堆的圖表設定，而這些你全部都可以在 <code>chartOptions</code> 裡進行新的設定，而只要 <code>condition</code> 當中的條件發生了，圖表就會被套用這些設定。</p><hr><h2 id="響應式設定-實際使用"><a href="#響應式設定-實際使用" class="headerlink" title="響應式設定 - 實際使用"></a>響應式設定 - 實際使用</h2><br/><p>既然兩個屬性都知道如何設定了，那接下來就是實際運看看囉，今天就來做個手機市佔率的圓餅圖好了。</p><p>在之前的範例中，我們都會把容器的寬度給寫死，但這樣圖表就不會隨視窗改變大小了，所以這次的容器就不設定固定寬度了：</p><pre><code class="html">&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</code></pre><p>接著先把資料給準備好，然後用 <code>showInLegend</code> 屬性把圓餅圖的圖例打開，並且做一些細節的設定：</p><pre><code class="javascript">let phoneData = [  [&quot;蘋果&quot;, 30],  [&quot;三星&quot;, 29.8],  [&quot;realme&quot;, 9.2],  [&quot;OPPO&quot;, 7.2],  [&quot;vivo&quot;, 6.3],  [&quot;其他&quot;, 17.5]];</code></pre><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  chart: &#123; type: &quot;pie&quot; &#125;,  title: &#123; text: &quot;手機品牌市佔率&quot; &#125;,  credits: &#123; enabled: false &#125;,  legend: &#123;    align: &quot;center&quot;,    verticalAlign: &quot;middle&quot;,    layout: &quot;vertical&quot;,    floating: true,    x: 260,    itemMarginTop: 5,    itemMarginBottom: 5,    labelFormat: &quot;&#123;name&#125; &#123;y&#125;%&quot;  &#125;,  plotOptions: &#123;    series: &#123;      showInLegend: true,       dataLabels: &#123; enabled: false &#125;    &#125;  &#125;,  series: [&#123; data: phoneData &#125;]&#125;);</code></pre><img src="pie.png" style="max-width: 800px; margin: 24px auto;" /><p>這樣我們就有一張手機品牌市佔率的圓餅圖了，並且將圖例顯示在圓餅圖的右側，不過如果你有跟著做的話，就會發現當圖表的寬度隨著視窗縮小到一定程度時，圖例就會超出畫面而無法完整顯示，為了解決這樣的「破版」，就來增加「響應式設定」吧！</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  //..省略原設定  responsive: &#123;    rules: [      &#123;        condition: &#123;  maxWidth: 650 &#125;,        chartOptions: &#123;          legend: &#123;            verticalAlign: &quot;bottom&quot;,            layout: &quot;horizontal&quot;,            floating: false,            x: 0          &#125;        &#125;      &#125;,      &#123;        condition: &#123; maxWidth: 450 &#125;,        chartOptions: &#123;          legend: &#123; verticalAlign: &quot;top&quot; &#125;,        &#125;      &#125;    ]  &#125;&#125;);</code></pre><p>是否有發現，我在 <code>responsive.rules</code> 增加的是兩組條件與設定呢？就如同 <code>@media</code> 一樣，「響應式設定」並非只能設立一個斷點，所以現在當圖表寬度小於 <code>650px</code> 以及 <code>450px</code> 的時候都會有一次改變，最後的成果就像下面這樣。</p><p><img src="legendChange.gif" alt=""></p><p><br/><br/></p><p>是不是覺得「響應式設定」還蠻有趣的呢？透過它我們可以做到很多的排版上的變化，讓任何尺寸的裝置都可順利的觀看圖表。</p><p>另外也要特別恭喜各位，因為到今天為止，我們已經把所有常見的「基本API」給介紹完了，而接下來的三天則會進入「進階API」的介紹，首當其衝的就是負責互動操作的「事件屬性」。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10247405">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/NWNeevP&quot;&gt;https://codepen.io/max-lee/pen/NWNeevP&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blo</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 主題設定</title>
    <link href="https://maxleebk.com/2020/09/30/highchart/highcharts-16/"/>
    <id>https://maxleebk.com/2020/09/30/highchart/highcharts-16/</id>
    <published>2020-09-30T01:30:00.000Z</published>
    <updated>2023-10-23T03:50:24.368Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/Vwaqvab">https://codepen.io/max-lee/pen/Vwaqvab</a></strong></p></blockquote><p>昨天在介紹到「語言設定」時有提到 <code>Highcharts.setOptions</code>， 說到它的功能是負責調整全域設定，讓整個網頁的圖表都受到影響，而今天要介紹的「主題設定」其實就是透過它來達成的。</p><hr><h2 id="主題設定"><a href="#主題設定" class="headerlink" title="主題設定"></a>主題設定</h2><br/><p>目前我們已經把七成的圖表區塊設定屬性給認識完了，基本上已經可以把 Highcharts 順利地運用在網頁中，但隨著頁面中的圖表越來越多，就會逐漸發現程式碼也變得越來越龐大。</p><p>由於我們在設計網頁時，總會有固定的風格、字型、顏色等等，所以會精心調整圖表的樣式細節，例如標題的字型樣式，圖例、提示框的顏色邊框等等。但是當我們想要把精心設定的樣式套用到每張圖表時，卻發現只能不斷寫著重複的程式碼。</p><pre><code class="javascript">var lineChart = Highcharts.chart(container, &#123;  chart: &#123;    type: &quot;line&quot;    borderWidth: 1,    borderColor: &quot;#ddd&quot;,    borderRadius: 4  &#125;&#125;);var columnChart = Highcharts.chart(container, &#123;  chart: &#123;    type: &quot;column&quot;    borderWidth: 1,    borderColor: &quot;#ddd&quot;,    borderRadius: 4  &#125;&#125;);</code></pre><p>就像上面這個簡單的案例，明明只是想要把每個圖表都加上邊框，卻要每張圖表都寫一堆重複的設定。這時候就可以使用 <code>Highcharts.setOptions</code> 來解決這種麻煩的窘境。</p><br/><p>首先要把每張圖表都會重複的部份抽出來，然後再透過 <code>Highcharts.setOptions</code> 進行設定，這樣以後每個圖表都只要設定那些不一樣地方就好了。</p><pre><code class="javascript">var theme = &#123;  chart: &#123;    borderWidth: 1,    borderColor: &quot;#ddd&quot;,    borderRadius: 4  &#125;&#125;;Highcharts.setOptions(theme);var lineChart = Highcharts.chart(container, &#123;  chart: &#123; type: &quot;line&quot; &#125;&#125;);var columnChart = Highcharts.chart(container, &#123;  chart: &#123; type: &quot;column&quot; &#125;&#125;);</code></pre><br/><br/><h4 id="權重最小"><a href="#權重最小" class="headerlink" title="# 權重最小"></a># 權重最小</h4><br/><p>當然，要是圖表數量多了，總是會有變動的可能，但如果你還記得「越細節，權重越高」這個原則的話，就會知道「主題設定」的權重是最小的，因為它影響的範圍是所有設定中最大的。</p><pre><code class="javascript">var theme = &#123;  chart: &#123;    borderWidth: 1,    borderColor: &quot;#ddd&quot;,    borderRadius: 4  &#125;&#125;;Highcharts.setOptions(theme);var myChart = Highcharts.chart(container, &#123;  chart: &#123;    // 主題設定是可以被覆蓋的    borderColor: &quot;blue&quot;,    borderRadius: 5  &#125;&#125;);</code></pre><p>所以要是有與「主題設定」不同的設定，直接寫在圖表設定中就可以了，Highcharts 會自動幫你覆蓋。</p><br/><br/><h4 id="深層合併"><a href="#深層合併" class="headerlink" title="# 深層合併"></a># 深層合併</h4><br/><p>如果遇到某些物件類型的屬性，例如 <code>style</code>、<code>xAxis.label</code> …等等，你可能會覺得要把整個屬性重新覆蓋一次，但其實你一樣只要撰寫不同的地方即可，因為 Highcharts 會自動幫我們做到深層的物件合併。</p><pre><code class="javascript">var theme = &#123;  title: &#123;    style: &#123;      fontFamily: &quot;微軟正黑體&quot;,      fontWeight: &quot;bold&quot;,      color: &quot;#292929&quot;    &#125;  &#125;,&#125;;Highcharts.setOptions(theme);var myChart = Highcharts.chart(container, &#123;  title: &#123;    text: &quot;公司員工年齡分佈&quot;,    style: &#123; color: &quot;red&quot; &#125; // 還是有吃到字型和粗細  &#125;&#125;);</code></pre><br/><br/><h4 id="順序與重複"><a href="#順序與重複" class="headerlink" title="# 順序與重複"></a># 順序與重複</h4><br/><p>雖然「主題設定」非常的方便，不過要特別注意它的執行順序以及重複執行的問題，像是下面的程式碼中，我們先建立圖表才進行主題設定，那圖表是吃不到主題設定的。</p><pre><code class="javascript">var theme = &#123;  chart: &#123;    borderWidth: 1,    borderColor: &quot;#ddd&quot;,    borderRadius: 4  &#125;&#125;;// 沒有吃到主題設定var lineChart = Highcharts.chart(container, &#123;  chart: &#123; type: &quot;line&quot; &#125;&#125;);Highcharts.setOptions(theme);// 執行全域設定後，才吃得到主題設定var columnChart = Highcharts.chart(container, &#123;  chart: &#123; type: &quot;column&quot; &#125;&#125;);</code></pre><br/><p>另外，重複執行 <code>Highcharts.setOptions</code> 是允許的，Highcharts 會自動把每次執行的設定內容合併，但是一樣要注意執行的順序。</p><pre><code class="javascript">var theme = &#123;  chart: &#123;    borderWidth: 1,    borderColor: &quot;#ddd&quot;,    borderRadius: 4  &#125;&#125;;// 第一次執行全域設定Highcharts.setOptions(theme);// 有邊框，顏色為 #dddvar lineChart = Highcharts.chart(container, &#123;  chart: &#123; type: &quot;line&quot; &#125;&#125;);// 第二次執行全域設定Highcharts.setOptions(&#123;  chart: &#123; borderColor: &quot;red&quot; &#125;&#125;);// 一樣有邊框，但邊框顏色為 redvar columnChart = Highcharts.chart(container, &#123;  chart: &#123; type: &quot;column&quot; &#125;&#125;);</code></pre><p><br/><br/></p><p>那今天的「主題設定」就介紹到這邊，雖然是比較間單的功能，但卻能幫我們省去很多重複的工作，跟先前介紹的「繪圖區設定」有異曲同工之妙，接著明天要繼續介紹的是「響應式設定」，讓我們的圖表也能適應 RWD 網站。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10246743">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/Vwaqvab&quot;&gt;https://codepen.io/max-lee/pen/Vwaqvab&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blo</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 日期座標軸&amp;語言設定</title>
    <link href="https://maxleebk.com/2020/09/29/highchart/highcharts-15/"/>
    <id>https://maxleebk.com/2020/09/29/highchart/highcharts-15/</id>
    <published>2020-09-29T04:30:00.000Z</published>
    <updated>2023-10-23T03:50:24.364Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/GRZwKjW">https://codepen.io/max-lee/pen/GRZwKjW</a></strong></p></blockquote><p>今天要又要來填坑了，在座標軸設定時有說會特別介紹「日期座標軸」，因為它的設定不僅僅與「座標軸設定」有關，還必須連動「數據列設定」，並且搭配昨天介紹的「格式化屬性」，算是比較複雜的應用。</p><br/><p>另外今天還會提到「語言設定」，它可以讓我們定義一些因 <strong>地區習慣</strong> 不同而變化的預設字符，包含昨天的千份位符號以及今天會用到的月份、星期名稱…等等。</p><hr><h2 id="日期座標軸"><a href="#日期座標軸" class="headerlink" title="日期座標軸"></a>日期座標軸</h2><p>當圖表的資料是包含時間維度的，那就有使用「日期座標軸的」需求，用來標示個別數據點的測量／紀錄時間。</p><p>而在 <strong><a href="/2020/09/22/highcharts-9/#Axis-type">座標軸設定</a></strong> 介紹過了，只要將 <code>Axis.type</code> 設為 <code>datetime</code> 即可將座標軸設定為「日期座標軸」。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  title: &#123; text: &quot;臺北市每日氣溫&quot; &#125;,  subtitle: &#123; text: &quot;2020年9月第一週&quot; &#125;,  credits: &#123; enabled: false &#125;,  xAxis: &#123;    type: &quot;datetime&quot;  &#125;,  yAxis: &#123;    title: &#123; text: &quot;攝氏溫度&quot; &#125;,    labels: &#123; format: &quot;&#123;value&#125;°C&quot;&#125;  &#125;,  series: [&#123;    name: &quot;平均溫度&quot;,    data: [30, 30, 31, 28, 29, 29, 28]  &#125;]&#125;);</code></pre><p>但如果僅僅只是這樣設定，你會發現座標軸的刻度與 <strong>每日氣溫</strong> 這個圖表主題不太相符，因為「日期座標軸」預設是以 <code>1970/1/1</code> 作為數據點的起始值，並且間距為 <code>1毫秒</code>。那下面我們就以完成這張圖表為目標，一步步學習如何設定「日期座標軸」吧。</p><img src="axisNoDate.png" style="max-width: 650px; margin: 24px auto;" /><h4 id="調整座標刻度間距"><a href="#調整座標刻度間距" class="headerlink" title="# 調整座標刻度間距"></a># 調整座標刻度間距</h4><br/><p>首先，我們先將座標刻度的間距改為「一天」，這裡要運用的屬性是 <code>Axis.tickInterval</code>，之前在 <strong><a href="/2020/09/22/highcharts-9/#Axis-tickInterval-Axis-minorTickInterval">座標軸設定</a></strong> 裡一樣有介紹過。</p><pre><code class="javascript">xAxis: &#123;  type: &quot;datetime&quot;,  tickInterval: 24 * 3600 * 1000 // 一天的毫秒數&#125;,</code></pre><p>設定完之後會發現座標刻度都消失了，只剩下一個 <code>1.Jan</code>，因為雖然刻度間距已經調整為一天了，但數據點之間的時間間隔還是被 Highcharts 認定為是 <code>1毫秒</code>。所以對圖表來說，這七個點都是同一天的數據，自然也就不需要顯示第二天、第三天的刻度了。</p><img src="tickInterval.png" style="max-width: 650px; margin: 24px auto;" /><br/><h4 id="調整數據點間距"><a href="#調整數據點間距" class="headerlink" title="# 調整數據點間距"></a># 調整數據點間距</h4><br/><p>為了解決上面的問題，要利用之前在 <strong><a href="/2020/09/24/highcharts-11/#series-pointInterval">數據點設定</a></strong> 中提過的 <code>series.pointInterval</code> 來將數據點的間距改為一天。</p><pre><code class="javascript">series: [&#123;  name: &quot;平均溫度&quot;,  data: [30, 30, 31, 28, 29, 29, 28],  pointInterval: 24 * 3600 * 1000 // 一天的毫秒數&#125;]</code></pre><p>這樣座標刻度與數據點就對上了，剛好一天一個點，不過目前的起始Ｘ軸座標還是 <code>1970/1/1</code>，所以接下來要將日期改成我們要的九月第一週。</p><img src="pointInterval.png" style="max-width: 650px; margin: 24px auto;" /><br/><h4 id="調整數據點起始X值"><a href="#調整數據點起始X值" class="headerlink" title="# 調整數據點起始Ｘ值"></a># 調整數據點起始Ｘ值</h4><br/><p>由於我們設定數據點資料的方式是「數值設定法」，所以數據點本身沒有Ｘ軸數值，使得 Highcharts 以 <code>1970/1/1 零毫秒</code> 作為我們第一個數據點的起始Ｘ軸數值，所以我們要用 <code>series.pointStart</code> 來將數據點的起始設定為 <code>8/31</code>，也就是九月第一週的星期一。</p><pre><code class="javascript">series: [&#123;  name: &quot;平均溫度&quot;,  data: [30, 30, 31, 28, 29, 29, 28],  pointStart: new Date(&quot;2020/8/31&quot;).getTime(),  pointInterval: 24 * 3600 * 1000 &#125;]</code></pre><p>在使用日期座標軸的圖表中，數據點Ｘ軸數值是以「時間戳數值」來表示的，所以我們只要傳入 <code>2020/8/31</code> 這一天的時間戳數值即可。</p><p>但如此設定後，卻發現數據點發生了偏移，而且看了一下第一個數據點的提示框，發現起始點竟然不是 <code>2020/8/31</code> 而是 <code>2020/8/30 16:00</code>，原來 Highcharts 是以格林威治的時間來計算的，但 <code>new Date()</code> 拿到的是台灣本地時間，所以才會早了八個小時。</p><br/><blockquote><p>台灣的時區是 <code>GMT+8</code>，比格林威治標準時間快八個小時。所以在台灣進入 <code>2020/8/31 00:00</code> 時，格林威治還在 <code>2020/8/30 16:00</code>。</p></blockquote><img src="pointStart.png" style="max-width: 650px; margin: 24px auto;" /><br/><h4 id="調整時區的時間差"><a href="#調整時區的時間差" class="headerlink" title="# 調整時區的時間差"></a># 調整時區的時間差</h4><br/><p>為了讓圖表的數據點時間點和刻度可以對得起來，就要處理因為時區所造成的時間差，這裡有兩種方法提供給大家。</p><p>你可以使用「時間設定」裡的 <code>time.timezoneOffset</code> 來告訴 Highcharts 你的時區偏移隔離威治多少，而這個數值可以透過 <code>getTimezoneOffset</code> 這個日期方法來取得。</p><pre><code class="javascript">let offset = new Date().getTimezoneOffset(); // -480var myChart = Highcharts.chart(container, &#123;  time: &#123; timezoneOffset: offset &#125;&#125;);</code></pre><p>或是比較簡單的做法是以 <code>Date.UTC</code> 來取得時間戳數值，而非 <code>new Date()</code>，因為它可以直接取得國際標準時間的時間戳。</p><pre><code class="javascript">series: [&#123;  name: &quot;平均溫度&quot;,  data: [30, 30, 31, 28, 29, 29, 28],  pointStart: Date.UTC(2020, 7, 31),  pointInterval: 24 * 3600 * 1000 &#125;]</code></pre><p>如此一來，我們就有一個時間完全正確的圖表了。</p><img src="utc.png" style="max-width: 650px; margin: 24px auto;" /><br/><h4 id="指定時間的數據點"><a href="#指定時間的數據點" class="headerlink" title="# 指定時間的數據點"></a># 指定時間的數據點</h4><br/><p>雖然目前的成果基本滿足需求，但假如 <code>9/3 中午12:00</code> 有一個歷年高溫我們想要加到圖表中，那該怎麼辦？</p><p>由於我們已經利用 <code>pointStart</code> 設定了數據點間隔，如果從中穿插一個點，只會讓圖表多增加一天而已，所以在加入這個數據點時，我們要直接為它指定時間戳在Ｘ軸數值。</p><pre><code class="javascript">let specifyPoint = &#123;  x: new Date(&quot;2020/9/3 12:00&quot;).getTime(),  y: 36,  color: &quot;red&quot;,  custom: &quot;中午12:00&quot;&#125; var myChart = Highcharts.chart(container, &#123;  series: [&#123;    name: &quot;平均溫度&quot;,    data: [30, 30, 31, 28, specifyPoint, 29, 29, 28],    pointStart: new Date(&quot;2020/8/31&quot;).getTime(),    pointInterval: 24 * 3600 * 1000   &#125;]&#125;);</code></pre><p>這樣就可以有指定時間的數據點了，另外，其實你也可以不用 <code>pointStart</code> 和 <code>pointInterval</code>，完全使用指定的Ｘ軸數值來製作日期座標軸圖表。</p><img src="specifyPoint.png" style="max-width: 650px; margin: 24px auto;" /><br/><h4 id="語言設定"><a href="#語言設定" class="headerlink" title="# 語言設定"></a># 語言設定</h4><br/><p>到這裡，我們的溫度圖表已經完全可以拿來提供給使用者觀看了，可是看著英文的月份和星期實在是有點不親切，為了改變這些 Highcharts 預設的字符，必須使用全域的「語言設定」。</p><pre><code class="javascript">Highcharts.setOptions(&#123;  lang: &#123;    months: [&#39;一月&#39;, &#39;二月&#39;, .... &#39;十二月&#39;], // 中間省略    shortMonths: [&#39;1月&#39;, &#39;2月&#39;, .... &#39;12月&#39;], // 中間省略    weekdays: [&quot;星期一&quot;,&quot;星期二&quot;, .... &quot;星期日&quot;] // 中間省略  &#125;&#125;)var myChart = Highcharts.chart(container, &#123;  //...省略&#125;);</code></pre><p>程式碼中可以看到一個新的方法 <code>Highcharts.setOptions</code>，它是用來設定全域設定的，影響範圍是頁面中的全部圖表，所以只要設定一次即可。其中「語言設定」必須使用這個方式來定義，這裡我們將月份和星期改成中文的版本。</p><p>如此一來，刻度標籤和提示框就有親切的中文顯示囉～</p><img src="lang.png" style="max-width: 650px; margin: 24px auto;" /><blockquote><p>另外昨天提到的小數點與千分位符號也是在「語言設定」中調整的。</p></blockquote><pre><code class="javascript">lang: &#123;  decimalPoint: &quot;.&quot;, // 小數點預設值  thousandsSep: &quot;\u0020&quot; // 千分位預設值，\u0020 為空白符號&#125;</code></pre><br/><br/><h4 id="日期格式化"><a href="#日期格式化" class="headerlink" title="# 日期格式化"></a># 日期格式化</h4><br/><p>雖然已經有中文了，不過日期的字串格式似乎不太符合台灣人的習慣，這時候就可以運用昨天才學到的格式化屬性來調整了，而且 Highcharts 一樣有提供日期的特殊符號可以使用。</p><img src="dateSymbol.png" style="max-width: 500px; margin: 24px auto;" /><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  yAxis: &#123;    title: &#123; text: &quot;攝氏溫度&quot; &#125;,    labels: &#123; format: &quot;&#123;value&#125;°C&quot;&#125;  &#125;,  tooltip: &#123;    headerFormat: &quot;&#123;point.key:%Y/%m/%d %A&#125;&lt;br/&gt;&quot;,    pointFormatter() &#123;      let type =  this.custom ? &quot;最高溫度&quot; : &quot;平均溫度&quot;;      let time = this.custom ? `($&#123;this.custom&#125;)` : &quot;&quot; ;      return `$&#123;type&#125;: $&#123;this.y&#125;°C $&#123;time&#125;`    &#125;  &#125;,&#125;);</code></pre><p>最後把上面的符號表規則應用在昨天學到的格式化屬性後，我們就有一個非常完美的客製化圖表了，同時也把「日期座標軸」的設定方法和應用搞清楚了。</p><img src="format.png" style="max-width: 650px; margin: 24px auto;" /><p><br/><br/></p><p>今天利用了一整個範例來學習「日期座標軸」，並且成功製作了一個包含時間維度的圖表，相信未來如果有類似需求，各位應該可以易如反掌得解決了。而明天要繼續跟大家介紹的是「主題設定」。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10246182">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/GRZwKjW&quot;&gt;https://codepen.io/max-lee/pen/GRZwKjW&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blo</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 格式化屬性</title>
    <link href="https://maxleebk.com/2020/09/28/highchart/highcharts-14/"/>
    <id>https://maxleebk.com/2020/09/28/highchart/highcharts-14/</id>
    <published>2020-09-28T10:10:00.000Z</published>
    <updated>2023-10-23T03:50:24.360Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/mdPjEEZ">https://codepen.io/max-lee/pen/mdPjEEZ</a></strong><br>避免文章篇幅過長，沒辦法每個屬性都利用圖片示意，所以記得善用範例來測試不太了解的屬性。</p></blockquote><p>在 Highcharts 中，格式化屬性是一個很強大的功能，它可以讓我們把圖表做得更細緻完善，例如將座標軸的刻度標籤加上單位、千分位，或是把提示框的內容補充的更詳盡等等…</p><hr><h2 id="格式化屬性-基本介紹"><a href="#格式化屬性-基本介紹" class="headerlink" title="格式化屬性 - 基本介紹"></a>格式化屬性 - 基本介紹</h2><br/><p>雖然我們已經看過格式化屬性很多次了，但是卻一直避過不談，它到底是做什麼用的？其實它做的事情就是<strong>「把一系列相似的項目轉換為相同規格的文字」</strong>，可以用一個簡單的 JavaScript 程式碼來解釋這個過程：</p><pre><code class="javascript">let max =  &#123; name: &quot;Max&quot;, age: &quot;27&quot; &#125;;let sam =  &#123; name: &quot;Sam&quot;, age: &quot;32&quot; &#125;;let items = [max, sam];let formatter = function()&#123;  return `$&#123;this.name&#125; is $&#123;this.age&#125; years old`;&#125; let result = items.map(item =&gt; formatter.apply(item)); // [&quot;Max is 27 years old&quot;, &quot;Sam is 32 years old&quot;]</code></pre><p>Highcharts 就是這樣把一系列的物件輸出成我們想要的文字格式，最後呈現在標籤上或內容裡。而這<strong>「一系列物件」</strong>在不同的區塊屬性中都不盡相同。</p><p>例如在「圖例設定」的格式化屬性中你可以拿到一組組的數據列物件，但在「座標軸設定」中你拿到的又會是一組組的刻度標籤物件。</p><br/><p><strong>而格式化屬性主要分佈在以下四個區塊設定中：</strong></p><ul><li><strong>圖例設定：</strong> 調整圖例標籤</li><li><strong>提示框設定：</strong> 調整提示框內容</li><li><strong>座標軸設定：</strong> 調整刻度標籤</li><li><strong>數據列設定：</strong> 調整數據標籤</li></ul><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  legend: &#123;    labelFormat: &quot;&quot;,    labelFormatter: function() &#123;&#125;  &#125;,  tooltip: &#123;    headerFormat: &quot;&quot;,    footerFormat: &quot;&quot;,    pointFormat: &quot;&quot;,    pointFormatter: function() &#123;&#125;,    formatter:  function() &#123;&#125;  &#125;,  xAxis: &#123; // Y軸亦同    labels: &#123;      format: &quot;&quot;,      formatter: function() &#123;&#125;    &#125;  &#125;,  series: [&#123; // 繪圖區和數據點亦同    dataLabels: &#123;      format: &quot;&quot;,      formatter: function() &#123;&#125;    &#125;  &#125;]&#125;);</code></pre><p>看到這堆屬性大家可能又頭昏了，不過「格式化屬性」不像昨天的顏色屬性那麼複雜，就只是屬性看起來多了點，如果仔細一看就會發現，其實格式化屬性就分為兩種，一個是用字串設定的 <code>format</code>，以及利用函式設定的 <code>formatter</code>。</p><p>所以我們只要先把這兩種設定方式搞清楚後，再看看每個區塊能拿到什麼樣的物件，就可以知道如何利用格式化屬性啦。</p><hr><h2 id="格式化屬性-Format"><a href="#格式化屬性-Format" class="headerlink" title="格式化屬性 - Format"></a>格式化屬性 - Format</h2><br/><p>先來介紹以字串設定的 <code>format</code>，假如希望顯示的文字格式不是太複雜，而且不需要特別的判斷或計算，那基本上 <code>format</code> 就已經可以滿足我們的需求了，設定技巧如下：</p><br/><h4 id="格式語法"><a href="#格式語法" class="headerlink" title="# 格式語法"></a># 格式語法</h4><p>其實就和我們上面的 JavaScript 案例中使用的「ES6 - 模版字符串」有點類似，但只需要「大括號」即可。</p><pre><code class="javascript">`這是一個變數: $&#123;variables&#125;` // ES6 - 模版字符串&quot;這是一個變數: &#123;variables&#125;&quot; // Highcharts - format設定字串</code></pre><br/><br/><h4 id="HTML標籤"><a href="#HTML標籤" class="headerlink" title="# HTML標籤"></a># HTML標籤</h4><p>另外，格式化字串中可以使用部分 HTML 行內元素，像是 <code>&lt;b&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;i&gt;</code>、<code>&lt;em&gt;</code>、<code>&lt;br/&gt;</code>、<code>&lt;span&gt;</code>，並且也可以加上行內樣式來調整外觀，但因為 Highcharts 是以 SVG 渲染的，所以只接受能夠與 SVG 相容的 CSS 屬性。</p><pre><code class="javascript">&quot;&lt;b&gt;這是一個變數&lt;/b&gt;:&lt;br/&gt; &lt;span style=&#39;color: red&#39;&gt;&#123;variables&#125;&lt;span&gt;&quot;</code></pre><br/><br/><h4 id="數字處理"><a href="#數字處理" class="headerlink" title="# 數字處理"></a># 數字處理</h4><p>最後，Highcharts 還提供了一些符號來幫助我們處理數字「千分位」與「小數點」。當中的「冒號」要接在你的變數名稱後，而「逗號」表示使用千分位符號，而後面的 <code>.0f</code> 表示要顯示小數點後第幾位。</p><pre><code class="javascript">// 假如 variables 為 12500.333&quot;&#123;variables:,.2f&#125;&quot; // 12 500.333&quot;&#123;variables:.4f&#125;&quot; // 12500.3330&quot;&#123;variables:,&#125;&quot; // 不可單獨使用！！！</code></pre><blockquote><p>你可能有發現千分位是用空白格開的，明天會教大家如何改變預設的千分位符號。</p></blockquote><hr><h2 id="格式化屬性-Formatter"><a href="#格式化屬性-Formatter" class="headerlink" title="格式化屬性 - Formatter"></a>格式化屬性 - Formatter</h2><br/><p>再來是用函式設定的 <code>formatter</code> 屬性，這個函式必須返回一組字串，且不需要使用 Highcharts 的特殊語法，直接使用 JavaScrip 的字串即可，而使用函式的好處就是可以對資料先進行計算或判斷處理。</p><br/><h4 id="函式裡的This"><a href="#函式裡的This" class="headerlink" title="# 函式裡的This"></a># 函式裡的This</h4><p>其實 <code>formatter</code> 的原理和開頭的 JavaScript 程式碼一樣，Highcharts 會把一組一組的物件放進 <code>this</code> 裡。</p><p>以數據標籤來說，假如數據點有五個，那格式化函式就會執行五次，而每一次都可以從 <code>this</code> 裡拿到個別的<strong>「數據點物件」</strong>，如此一來，就可以獲取需多資訊來進行判斷或計算。</p><br/><blockquote><p><strong>注意：</strong> 因為需要使用 <code>this</code> 才能取得物件資料，所以不能使用箭頭函式，箭頭函式沒有 <code>this</code>。</p></blockquote><pre><code class="javascript">series: [&#123;  data: [5, 6, 7, 8, 9],  dataLabels: &#123;    enabled: true,    formatter: function() &#123;      console.log(this); // 會有五次console，每一次代表一個數據點      return this.y // 數據點物件中 y 屬性即數據點數值    &#125;  &#125;&#125;]</code></pre><br/><br/><h4 id="數字處理-1"><a href="#數字處理-1" class="headerlink" title="# 數字處理"></a># 數字處理</h4><p>在 <code>formatter</code> 函式中你可以呼叫 <code>Highcharts.numberFormat</code> 來處理「千分位」與「小數點」，不需要自己寫冗長的程式碼。</p><pre><code class="javascript">formatter: function() &#123;  // 假如 this.y 為 12500.333  return Highcharts.numberFormat(this.y, 4, &quot;.&quot;, &quot;,&quot;) // 輸出 12,500.3330  return Highcharts.numberFormat(this.y, 2, &quot;,&quot;, &quot;&quot;)  // 輸出 12500.33  return Highcharts.numberFormat(this.y, 0)  // 輸出 12 500&#125;</code></pre><br/><br/><h4 id="series-custom-series-data-custom"><a href="#series-custom-series-data-custom" class="headerlink" title="# series.custom / series.data.custom"></a># series.custom / series.data.custom</h4><p><code>型別: Any</code> <code>預設: undefined</code></p><p>假如你很肯定某些資訊在 <code>this</code> 是沒有的，那可以在這兩個屬性中放入自定義的資料，這樣就可以在 <code>formatter</code> 中拿到這些資料了</p><pre><code class="javascript">series: [&#123;  custom: &#123; total: 35 &#125;,  data: [5, 6, 7, 8, 9],  dataLabels: &#123;    enabled: true,    formatter: function() &#123;      let total = this.series.options.custom.total      return Highcharts.numberFormat(this.y / total * 100, 1) + &quot;%&quot;;    &#125;  &#125;&#125;]</code></pre><hr><h2 id="格式化屬性-區塊屬性"><a href="#格式化屬性-區塊屬性" class="headerlink" title="格式化屬性 - 區塊屬性"></a>格式化屬性 - 區塊屬性</h2><br/><p>了解兩種屬性的設定方式後，就可以來看看各個區塊裡的格式化屬性可以拿到什麼「物件」了。</p><p>但這些「物件」裡的屬性又是一個海量的存在，應該都夠我參加兩次鐵人賽了，所以就只大概簡介一下，如果想要深入了解，最好辦法還是直接使用看看，然後用 <code>formatter</code> 直接 <code>console.log(this)</code> 最快。</p><br/><p><img src="config.png" alt=""></p><br/><blockquote><h5 id="※-補充說明"><a href="#※-補充說明" class="headerlink" title="※ 補充說明"></a>※ 補充說明</h5><p>這裡的「物件」指的是 Highcharts 將該區塊的相關資料包裝好後提供給格式化屬性的，並且只要是同一組的格式化屬性，拿到的物件都是相同的，因此 <code>this.y</code> 和 <code>&#123;y&#125;</code> 代表的都是一樣的值。</p><p><strong>注意：</strong> 有些屬性 <code>format</code> 不支援，如果確定要使用的話就改用 <code>formatter</code> 吧！</p></blockquote><br/><br/><h4 id="圖例文字標籤"><a href="#圖例文字標籤" class="headerlink" title="# 圖例文字標籤"></a># 圖例文字標籤</h4><p>圖例標籤的格式化屬性拿到的物件一般是「數據列物件」，但如果是圓餅圖這種以數據點為圖例單位的圖表，則是「數據點物件」，兩種物件長得不太一樣，不過常用的有 <code>name</code>、<code>color</code>、<code>index</code> 這幾個。</p><ul><li><strong>官方文件： <a href="https://api.highcharts.com/class-reference/Highcharts.Series">數據列物件</a> / <a href="https://api.highcharts.com/class-reference/Highcharts.Point">數據點物件</a></strong></li></ul><pre><code class="javascript">// 以下為預設值legend: &#123;  labelFormat: &quot;&#123;name&#125;&quot;,  labelFormatter: undefined&#125;</code></pre><p>另外「數據點物件」還多了 <code>total</code>、<code>percentage</code> 這兩個直接幫你計算好的值，所以你就可以直接在圖例上顯示百分比。</p><img src="legend.png" style="max-width: 600px; margin: 20px auto;" /><h4 id="提示框內容"><a href="#提示框內容" class="headerlink" title="# 提示框內容"></a># 提示框內容</h4><p>提示框內容的格式化屬性是最多也最特別的，可以看看下方的說明圖可能較好理解，另外 <code>tooltip.formatter</code> 所拿到的物件屬性會受到 <code>tooltip.shared</code> 的影響，建議可以印出來看看差別。</p><blockquote><p><strong>注意：</strong> <code>pointFormat</code> 在屬性前方必須加上 <code>point.</code> 例如 <code>&#123;point.color&#125;</code>，但並不清楚為何這個屬性多了這個規定。</p></blockquote><p>這邊也提供我的應用給大家參考：<strong><a href="https://codepen.io/max-lee/pen/bGpmmjj">https://codepen.io/max-lee/pen/bGpmmjj</a></strong></p><ul><li><strong>官方文件： <a href="https://api.highcharts.com/class-reference/Highcharts.Point">數據點物件</a> / <a href="https://api.highcharts.com/class-reference/Highcharts.TooltipFormatterContextObject">提示框內容物件</a></strong></li></ul><pre><code class="javascript">// 以下為預設值tooltip: &#123;  headerFormat: &#39;&lt;span style=&quot;font-size: 10px&quot;&gt;&#123;point.key&#125;&lt;/span&gt;&lt;br/&gt;&#39;,  footerFormat: &#39;&#39;,  pointFormat: &#39;&lt;span style=&quot;color:&#123;point.color&#125;&quot;&gt;●&lt;/span&gt; &#123;series.name&#125;: &lt;b&gt;&#123;point.y&#125;&lt;/b&gt;&lt;br/&gt;.&#39;,  pointFormatter: undefined,  formatter:  undefined&#125;</code></pre><img src="tooltip.png" style="max-width: 800px; margin: 20px auto;" /><br/><h4 id="座標軸刻度標籤"><a href="#座標軸刻度標籤" class="headerlink" title="# 座標軸刻度標籤"></a># 座標軸刻度標籤</h4><p>座標軸刻度標籤的格式化屬性拿到的物件是「刻度標籤物件」，裡面會有座標軸的相關設定屬性、圖表物件，以及該刻度所代表的Ｘ／Ｙ值 <code>value</code>，也有 <code>isFirst</code>、<code>isLast</code>，幫助你判斷該刻度是否為第一個或最後一個。</p><ul><li><strong>官方文件： <a href="https://api.highcharts.com/class-reference/Highcharts.AxisLabelsFormatterContextObject">刻度標籤物件</a></strong></li></ul><pre><code class="javascript">// 以下為預設值xAxis: &#123; // Y軸亦同  labels: &#123;    format: &quot;&#123;value&#125;&quot;,    formatter: undefined  &#125;&#125;</code></pre><br/><br/><h4 id="數據標籤"><a href="#數據標籤" class="headerlink" title="# 數據標籤"></a># 數據標籤</h4><p>數據標籤的格式化屬性拿到的物件是「數據標籤物件」，基本上內含屬性就和圖例標籤是差不多的，不過同時包含了「數據列物件」、「數據點物件」，所以可用的數據又更多了。</p><p>另外繪圖區跟數據點也都可以設定格式化屬性，權重大小就和之前介紹的一樣。</p><ul><li><strong>官方文件： <a href="https://api.highcharts.com/class-reference/Highcharts.PointLabelObject">數據標籤物件</a></strong></li></ul><pre><code class="javascript">// 以下為預設值series: [&#123; // 繪圖區和數據點亦同  dataLabels: &#123;    format: &quot;&#123;point.value&#125;&quot;,    formatter: undefined  &#125;&#125;]</code></pre><p><br/><br/></p><p>今天又解決一個難纏的屬性，不過難歸難，格式化屬性在 Highcharts 中的重要性還是非常高的，大大提升了圖表的自定義程度，尤其提示框內容運用得宜的話，可以很大程度上的補充圖表資訊。</p><p>但如果真覺得很複雜的話，我推薦一律使用 <code>formatter</code>，寫起來就跟一般在寫 JavaScript 沒兩樣，想知道有哪些屬性也可以直接 <code>console</code>。</p><p>那接著明天，要帶大家完整設定出一個「日期座標軸」的圖表，當中涉及了座標軸設定、數據列設定以及今天的格式化屬性。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10245718">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/mdPjEEZ&quot;&gt;https://codepen.io/max-lee/pen/mdPjEEZ&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;避免文章篇幅</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 顏色屬性</title>
    <link href="https://maxleebk.com/2020/09/27/highchart/highcharts-13/"/>
    <id>https://maxleebk.com/2020/09/27/highchart/highcharts-13/</id>
    <published>2020-09-27T03:00:00.000Z</published>
    <updated>2023-10-23T03:50:24.356Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/poyZgWx">https://codepen.io/max-lee/pen/poyZgWx</a></strong><br>避免文章篇幅過長，沒辦法每個屬性都利用圖片示意，所以記得善用範例來測試不太了解的屬性。</p></blockquote><p>我猜可能有些人在前面幾天一直很在意到底要怎麼更換「數據列／點」的顏色吧，還是其實已經有人等不及，自己偷偷跑去翻出調整顏色的屬性了。</p><p>Highcharts 當然是可以調整顏色的，但不是我不想跟大家介紹，而是能夠設定顏色的方法很多，而且又有權重的問題，所以才會想接在「繪圖區設定」後面介紹顏色的部分。</p><hr><h2 id="數據列顏色"><a href="#數據列顏色" class="headerlink" title="數據列顏色"></a>數據列顏色</h2><br/><p>昨天有講到繪圖區、數據列、數據點的權重大小，而調整顏色的屬性除了在這些區塊裡都可以調整外，顏色本身也有獨立的屬性可以設定。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  colors: [&quot;red&quot;, &quot;orange&quot;],    // 所有數據列依序採用陣列中顏色   plotOptions: &#123;    series:&#123;       color: &quot;green&quot;,           // 所有數據列都採用這個顏色      colorByPoint: true,       // 所有數據列是否都用colors設定數據點顏色      colors: [&quot;cyan&quot;, &quot;navy&quot;], // 所有數據列的數據點依序採用陣列中顏色    &#125;,    line: &#123;       color: &quot;blue&quot;,            // 指定類型數據列都採用這個顏色      colorByPoint: true,       // 指定類型數據列是否都用colors設定數據點顏色      colors: [&quot;lime&quot;, &quot;plum&quot;], // 指定類型數據列的數據點依序採用陣列中顏色     &#125;  &#125;,  series: [&#123;    color: &quot;purple&quot;,            // 這組數據列採用這個顏色    colorByPoint: true,         // 是否要用colors設定數據點顏色    colors: [&quot;pink&quot;, &quot;gray&quot;],   // 這組數據列裡的數據點依序採用陣列中顏色    data: [&#123; color: &quot;black&quot; &#125;]  // 這個數據點採用這個顏色  &#125;]&#125;);</code></pre><p>是不是看得頭都暈了？這樣應該知道為何我要等的現在才講顏色了吧？那下面就從權重最低到最高一個個詳細介紹。</p><br/><h4 id="options-colors"><a href="#options-colors" class="headerlink" title="# options.colors"></a># options.colors</h4><p><code>型別: Array[String]</code> <code>預設: 請見下方</code></p><p>這個顏色屬性直接隸屬於 <code>options</code> 物件底下，而它的值是一組陣列，陣列裡必須是合法的顏色字串，然後 <strong>「所有數據列」</strong> 便會依據它自己的順序從 <code>colors</code> 裡拉出顏色來設定，<strong>假如顏色用完了就會在回到第一個繼續循環</strong>。</p><p>這也是為什麼我們前面的範例總是藍色的，因為它被設定的是預設 <code>colors</code> 裡的第一個顏色 <code>#7cb5ec</code>。</p><pre><code class="javascript">default = [&quot;#7cb5ec&quot;, &quot;#434348&quot;, &quot;#90ed7d&quot;, &quot;#f7a35c&quot;, &quot;#8085e9&quot;, &quot;#f15c80&quot;, &quot;#e4d354&quot;, &quot;#2b908f&quot;, &quot;#f45b5b&quot;, &quot;#91e8e1&quot;]</code></pre><img src="color.png" style="max-width: 600px; margin: 20px auto;" /><br/><br/><h4 id="plotOptions-series-color"><a href="#plotOptions-series-color" class="headerlink" title="# plotOptions.series.color"></a># plotOptions.series.color</h4><p><code>型別: String</code> <code>預設: undefined</code></p><p>這個顏色屬性就非常很單純了，就是把 <strong>「所有數據列」</strong> 改成指定的顏色。</p><br/><br/><h4 id="plotOptions-type-color"><a href="#plotOptions-type-color" class="headerlink" title="# plotOptions.[type].color"></a># plotOptions.[type].color</h4><p><code>型別: String</code> <code>預設: undefined</code></p><p>由於昨天解釋過繪圖區的權重關係，所以這個顏色屬性應該也不難懂，就是把 <strong>「所有指定類型的數據列」</strong> 改成指定的顏色，須要特別注意的是，假如你設定的圖表種類未涵蓋所有圖表的話，那其他圖表會「從頭」開始設定 <code>options.colors</code> 中的顏色，並且跳過已經有指定顏色的圖表。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  colors: [&quot;green&quot;, &quot;blue&quot;, &quot;purple&quot;], // 所有數據列依序採用陣列中顏色   plotOptions: &#123;    column: &#123; color: &quot;red&quot; &#125;  &#125;,  series: [    &#123; type: &quot;column&quot;, data: [2, 2, 2] &#125;, // 紅色    &#123; type: &quot;line&quot;,   data: [6, 6, 6] &#125;, // 綠色    &#123; type: &quot;column&quot;, data: [4, 4, 4] &#125;, // 紅色    &#123; type: &quot;line&quot;,   data: [2, 2, 2] &#125;  // 藍色  ]&#125;);</code></pre><br/><br/><h4 id="series-color"><a href="#series-color" class="headerlink" title="# series.color"></a># series.color</h4><p><code>型別: String</code> <code>預設: undefined</code></p><p>這個顏色屬性一樣很簡單，就是把 <strong>「這個數據列」</strong> 改成指定的顏色。而且和上一個屬性一樣，剩下的數據列會「從頭」開始設定 <code>options.colors</code> 中的顏色，並且跳過已經有指定顏色的圖表。</p><br/><br/><h4 id="plotOptions-series-colorByPoint"><a href="#plotOptions-series-colorByPoint" class="headerlink" title="# plotOptions.series.colorByPoint"></a># plotOptions.series.colorByPoint</h4><p><code>型別: Boolean</code> <code>預設: false</code></p><p>這個屬性可以決定是否要用 <code>colors</code> 來依序設定 <strong>「所有數據列的數據點顏色」</strong>，這裡指的 <code>colors</code> 不一定是 <code>options.colors</code>，而是權重最高的 <code>colors</code>。</p><br/><br/><h4 id="plotOptions-series-colors"><a href="#plotOptions-series-colors" class="headerlink" title="# plotOptions.series.colors"></a># plotOptions.series.colors</h4><p><code>型別: Array[String]</code> <code>預設: undefined</code></p><p>假如你的數據列沒有開啟 <code>colorByPoint</code>，那這個顏色屬性基本上就沒以任何作用，但如果開啟了，這個屬性就會覆蓋 <code>options.colors</code>，並用你提供的顏色陣列來依序設定<strong>「所有數據列的數據點顏色」</strong>。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  colors: [&quot;green&quot;, &quot;blue&quot;, &quot;purple&quot;],  plotOptions: &#123;    series: &#123;      colorByPoint: true,      colors: [&quot;pink&quot;, &quot;red&quot;, &quot;orange&quot;]    &#125;  &#125;,  series: [&#123;     // 粉紅色, 紅色, 橘色, 粉紅色, 紅色    data: [5, 3, 7, 4, 10]   &#125;] &#125;);</code></pre><br/><br/><h4 id="plotOptions-type-colorByPoint-plotOptions-type-colors"><a href="#plotOptions-type-colorByPoint-plotOptions-type-colors" class="headerlink" title="# plotOptions.[type].colorByPoint / plotOptions.[type].colors"></a># plotOptions.[type].colorByPoint / plotOptions.[type].colors</h4><p>這組應該就不用多作介紹了吧，作用和前面一樣，只不過對象換成 <strong>「所有指定類型數據列的數據點顏色」</strong>。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  colors: [&quot;green&quot;, &quot;blue&quot;, &quot;purple&quot;],  plotOptions: &#123;    series: &#123;      colors: [&quot;pink&quot;, &quot;red&quot;, &quot;orange&quot;]    &#125;,    line: &#123;      colorByPoint: true,    &#125;  &#125;,  series: [    // 粉紅色, 紅色, 橘色, 粉紅色, 紅色    &#123; type: &quot;line&quot;, data: [5, 5, 5, 5, 5] &#125;,    // 所有數據列都是綠色的    &#123; type: &quot;column&quot;, data: [3, 3, 3, 3, 3] &#125;,    // 粉紅色, 紅色, 橘色, 粉紅色, 紅色    &#123; type: &quot;line&quot;, data: [2, 2, 2, 2, 2] &#125;  ] &#125;);</code></pre><img src="color1.png" style="max-width: 600px; margin: 20px auto;" /><br/><br/><h4 id="series-colorByPoint-series-colors"><a href="#series-colorByPoint-series-colors" class="headerlink" title="# series.colorByPoint / series.colors"></a># series.colorByPoint / series.colors</h4><p>數據列中也是有同一組的設定，也是必須要 <code>colorByPoint</code> 開啟才會作用，不過作用對象就換成了 <strong>「單一數據列的數據點顏色」</strong>。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  chart: &#123; type: &quot;column&quot; &#125;,  colors: [&quot;green&quot;, &quot;blue&quot;, &quot;purple&quot;],  plotOptions: &#123;    series: &#123;      colorByPoint: true,      colors: [&quot;pink&quot;, &quot;red&quot;, &quot;orange&quot;]    &#125;,  &#125;,  series: [    // 粉紅色, 紅色, 橘色, 粉紅色, 紅色    &#123; data: [5, 3, 7, 4, 10] &#125;,    // 所有數據列都是綠色的    &#123; colorByPoint: false, data: [5, 3, 7, 4, 10] &#125;,    // 黑色, 灰色, 褐色, 黑色, 灰色    &#123; colors: [&quot;black&quot;, &quot;gray&quot;, &quot;brown&quot;], data: [5, 3, 7, 4, 10] &#125;  ] &#125;);</code></pre><img src="color2.png" style="max-width: 600px; margin: 20px auto;" /><br/><br/><h4 id="series-data-color"><a href="#series-data-color" class="headerlink" title="# series.data.color"></a># series.data.color</h4><p><code>型別: String</code> <code>預設: undefined</code></p><p>這個顏色屬性是權重最高的，它可以決定 <strong>「單一數據點顏色」</strong>，不過跟數據列不同的是，它會直接覆蓋 <code>colors</code> 設定的顏色，而 <strong>不會被跳過</strong>。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  chart: &#123; type: &quot;column&quot; &#125;,  colors: [&quot;green&quot;, &quot;blue&quot;, &quot;purple&quot;],  plotOptions: &#123;    series: &#123; colorByPoint: true &#125;  &#125;,  series: [&#123;     // 綠色, 紅色, 紫色, 綠色, 藍色    data: [5, &#123; y: 3, color: &quot;red&quot; &#125;, 7, 4, 10]  &#125;] &#125;);</code></pre><img src="color3.png" style="max-width: 600px; margin: 20px auto;" /><br/><blockquote><p>補充： 圓餅圖這類以「數據點」為單位的圖表類型，<code>colorByPoint</code> 是強制開啟無法調整的。</p></blockquote><p><br/><br/></p><p>今天完全在物理上體會了什麼叫「給你一點顏色瞧瞧」，單單一個顏色 Highcharts 就可以搞得那麼複雜。不過也因為這樣，在圖表的設計上就可以有很大的發揮空間，例如依據數據點的數值大小來調整顏色深淺。</p><p>而明天終於要來填「格式化屬性」的坑了。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10244723">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/poyZgWx&quot;&gt;https://codepen.io/max-lee/pen/poyZgWx&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;避免文章篇幅</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 繪圖區設定</title>
    <link href="https://maxleebk.com/2020/09/26/highchart/highcharts-12/"/>
    <id>https://maxleebk.com/2020/09/26/highchart/highcharts-12/</id>
    <published>2020-09-26T03:10:00.000Z</published>
    <updated>2023-10-23T03:50:24.356Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/ExKRLGP">https://codepen.io/max-lee/pen/ExKRLGP</a></strong><br>避免文章篇幅過長，沒辦法每個屬性都利用圖片示意，所以記得善用範例來測試不太了解的屬性。</p></blockquote><p>如果前面幾個圖表元素的設定介紹你都有跟到的話，你可以想想看繪圖區設定還能調整或修改什麼？</p><p>繪圖區裡的數據列和數據點都有專屬的區塊設定，隔線、標記線(帶)由座標軸控制，就連繪圖區自己本身的背景、外框都是在「圖表整體設定」裡做調整，那繪圖區設定到底還能設定什麼？</p><p><strong>其實繪圖區本身沒有任何屬性可以設定，但它卻可以幫我們把數據列的重複設定抽出並統一管理。</strong></p><hr><h2 id="繪圖區設定-使用方法"><a href="#繪圖區設定-使用方法" class="headerlink" title="繪圖區設定 - 使用方法"></a>繪圖區設定 - 使用方法</h2><br/><p>繪圖區的設定就像是我們把重複的值抽出來設為變數一樣，它可以把重複的數據列設定給拉出來，統一放在它自己這邊，讓所有數據列都能吃到個設定。</p><p>由此可知，繪圖區的所有屬性都跟「數據列」一模一樣，除了 <code>type</code>、<code>name</code>、<code>data</code>、<code>index</code>、<code>legendIndex</code>…這些「不該共用」數據列的屬性。你可以自己比較看看折線圖的 <strong><a href="https://api.highcharts.com/highcharts/series.line">數據列設定</a></strong> 和 <strong><a href="https://api.highcharts.com/highcharts/plotOptions.line">繪圖區設定</a></strong> 有哪些不同。</p><br/><br/><p>不過你可能會好奇，如果是 <code>marker</code>、<code>size</code> 這類專屬於某個圖表類型的屬性怎麼辦？其實繪圖區設定的撰寫方式是這樣的…</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  plotOptions: &#123;    series:&#123;      // 在這張圖表裡的所有數據列都會套用    &#125;,    line: &#123;      // 在這張圖表裡type為line的數據列會套用    &#125;,    column: &#123;      // 在這張圖表裡type為column的數據列會套用    &#125;  &#125;,&#125;);</code></pre><p>透過這樣的設定結構，你可以把通用的屬性放在 <code>series</code> 子物件底下，而折線圖專屬的設定放在 <code>line</code> 底下，這樣就可以區分通用與專門屬性了。</p><blockquote><p>但其實寫在一起也沒關係，就算設定了一個該圖表沒有的屬性，也不會發生錯誤或造成影響。</p></blockquote><br/><br/><h4 id="用一個簡單的案例來感受繪圖區設定的方便："><a href="#用一個簡單的案例來感受繪圖區設定的方便：" class="headerlink" title="用一個簡單的案例來感受繪圖區設定的方便："></a>用一個簡單的案例來感受繪圖區設定的方便：</h4><p>假設我們今天有一個「兩組折線圖／一組柱狀圖」的複合圖表，當中的三組數據列都要顯示「數據標籤」，然後兩組折線圖都要將線條改為虛線。沒用繪圖區設定的話要這樣寫…</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  // 省略其他區塊設定...  series: [    &#123;      type: &quot;column&quot;,      name: &quot;柱狀圖&quot;,      data: [10,20,30,40,50],      dataLabels: &#123; enabled: true &#125;    &#125;,    &#123;      name: &quot;折線圖一&quot;,      data: [35,35,35,35,35],      dashStyle: &quot;Dash&quot;,      dataLabels: &#123; enabled: true &#125;    &#125;,    &#123;      name: &quot;折線圖二&quot;,      data: [55,55,55,55,55],      dashStyle: &quot;Dash&quot;,      dataLabels: &#123; enabled: true &#125;    &#125;  ]&#125;);</code></pre><p>但如果利用繪圖區設定改寫一下，我們就可以避免大量重複的程式碼，而且如果未來要調整，就只要統一修改繪圖區設定一個地方就好，大大提升了程式碼的管理品質。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  // 省略其他區塊設定...  plotOptions: &#123;    series: &#123;      dataLabels: &#123; enabled: true &#125;    &#125;,    line: &#123;      dashStyle: &quot;Dash&quot;,    &#125;  &#125;,  series: [    &#123;      name: &quot;折線圖一&quot;,      data: [1,3,5,7,9]    &#125;,    &#123;      name: &quot;折線圖二&quot;,      data: [2,4,6,8,10]    &#125;,    &#123;      type: &quot;column&quot;,      name: &quot;柱狀圖&quot;,      data: [10,20,30,40,50]    &#125;  ]&#125;);</code></pre><br/><blockquote><p>其實就算不是複合圖表，甚至只有單組數據列，我都習慣把數據列設定挪到繪圖區設定裡，這樣可以讓數據列專注在設定「數據點資料」。</p></blockquote><hr><h2 id="繪圖區設定-權重高低"><a href="#繪圖區設定-權重高低" class="headerlink" title="繪圖區設定 - 權重高低"></a>繪圖區設定 - 權重高低</h2><br/><p>既然「數據列設定」和「繪圖區設定」都能調整數據列，那如果不小心兩邊對同個屬性設定了不同的值會發生什麼事呢？</p><p>「越細節，權重越高」，在 Highcharts 中保持著一個觀念就不會容易被搞糊塗，以這個原則來看的話我們可以得到下圖的結果，也就是說如果「數據列設定」和「繪圖區設定」發生衝突，那最後會以數據列設定為優先。</p><p><img src="weights.png" alt=""></p><br/><br/><p>因此，只要把權重運用得宜的話，就可以這樣做：<strong><a href="https://codepen.io/max-lee/pen/RwaJyjg">https://codepen.io/max-lee/pen/RwaJyjg</a></strong></p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  // 省略其他區塊設定...  plotOptions: &#123;    series: &#123;       marker: &#123;          enabled: true,         symbol: &quot;diamond&quot;,         radius: 6      &#125;    &#125;,    line: &#123;      marker: &#123; symbol: &quot;triangle&quot; &#125;    &#125;  &#125;,  series: [    &#123;      name: &quot;折線圖一&quot;,      marker: &#123; enabled: false &#125;,      data: [30,30,30,30,&#123;        y: 30,        marker: &#123; enabled: true, symbol: &quot;triangle-down&quot; &#125;,      &#125;]    &#125;,    &#123;      name: &quot;折線圖二&quot;,      data: [60,60,60,60,60]    &#125;,    &#123;      type: &quot;area&quot;,      name: &quot;面積圖&quot;,      fillColor: &quot;rgba(144, 237, 125, 0.2)&quot;,      data: [10,10,10,10,10]    &#125;  ]&#125;);</code></pre><img src="weight-case.png" style="max-width: 700px; margin: 24px auto;" /><p><br/><br/></p><p>那繪圖區設定的介紹就到這邊，是不是覺得這樣統一的集中數據列設定清爽多了呢？不僅避免重複的程式碼還增加了易讀性，所以強烈建議大家試著多利用繪圖區設定來管理數據列！</p><p>接著明天要介紹的是看似簡單卻被我刻意跳過的「顏色設定」。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10244400">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/ExKRLGP&quot;&gt;https://codepen.io/max-lee/pen/ExKRLGP&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;避免文章篇幅</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 數據點設定</title>
    <link href="https://maxleebk.com/2020/09/25/highchart/highcharts-11/"/>
    <id>https://maxleebk.com/2020/09/25/highchart/highcharts-11/</id>
    <published>2020-09-25T01:50:00.000Z</published>
    <updated>2023-10-23T03:50:24.356Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/rNevgYm">https://codepen.io/max-lee/pen/rNevgYm</a></strong><br>避免文章篇幅過長，沒辦法每個屬性都利用圖片示意，所以記得善用範例來測試不太了解的屬性。</p></blockquote><p>昨天我們才介紹完數據列設定，而數據列其實就是一個個數據點所組成的一系列資料。講簡單一點，數據點就是折線圖裡的一個個點，圓餅圖裡的一個個扇形，而 Highcharts 的設定就是細到這樣的顆粒度，讓你每個點都能微調。</p><img src="point.png" style="max-width: 800px; margin: 16px auto 0;" /><hr><h2 id="數據點設定-基本介紹"><a href="#數據點設定-基本介紹" class="headerlink" title="數據點設定 - 基本介紹"></a>數據點設定 - 基本介紹</h2><br/><p>數據點其實就是透過數據列的 <code>data</code> 屬性設定的，也就是說數據列與數據點是相依相存的，而且就算只有一個數據點依然能稱為一個數據列。</p><p>而既然數據列設定的屬性會受到圖表類型影響，理所當然數據點就也會，甚至連設定方式都會有所改變。而且每一種圖表類型的數據點方式還不只一種，所以常常讓人搞得霧煞煞，不過今天就讓我幫大家統整歸納一下吧！</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  series: [&#123;    data: [] // 數據點設定  &#125;]&#125;);</code></pre><p><code>series.data</code> 能夠接受的型別是陣列，其中陣列裡每個項目所代表的就是一個一個的數據點（point），每個數據點又能以數字、陣列、或物件這三種型別來表示，至於要用哪一種取決於<strong>每個數據點之間的差異程度</strong>。</p><hr><h2 id="數據點設定-數值設定法"><a href="#數據點設定-數值設定法" class="headerlink" title="數據點設定 - 數值設定法"></a>數據點設定 - 數值設定法</h2><br/><pre><code class="javascript">series: [&#123;  data: [0, 5, 3, 5] // 數據點設定-數字型別&#125;]</code></pre><p>若以數字設定數據點，則這個數字會被 Highcharts 解析為數據點的Ｙ軸數值，Ｘ軸數值則會根據你的 <code>xAxis.type</code> 自動計算，如下。</p><ul><li>線性座標軸：從 <code>0</code> 開始，每個數據點依序增加 <code>1</code></li><li>類別座標軸：從 <code>xAxis.categories[0]</code> 開始，每個數據點依序拉出項目</li><li>日期座標軸：從 <code>1970/1/1 00:00</code> 開始，每個數據點依序增加一毫秒</li></ul><br/><p><strong>而當你用數值設定法來設定數據點，就可以下方兩個數據列屬性來調整上述規則。</strong></p><h4 id="series-pointStart"><a href="#series-pointStart" class="headerlink" title="# series.pointStart"></a># series.pointStart</h4><p><code>型別: Number</code> <code>預設: 0</code> </p><p>這個屬性設定的是你數據列中第一個數據點的Ｘ軸起始數值。</p><br/><br/><h4 id="series-pointInterval"><a href="#series-pointInterval" class="headerlink" title="# series.pointInterval"></a># series.pointInterval</h4><p><code>型別: Number</code> <code>預設: 1</code></p><p>這個屬性設定的是你數據列中每個數據點之間相隔多少Ｘ軸數值。如果不太理解這兩個屬性的話，可以看看我準備的 <strong><a href="https://codepen.io/max-lee/pen/XWdqNmR">範例</a></strong>。</p><br/><br/><blockquote><p>只要數據點本身沒有指定的Ｘ軸數值就很適合用這種設定方式，缺點是這種設定方式不能對數據點進行額外的屬性設定，所以要是希望各別數據點能有不一樣的外觀或特性的話，就不太適用了。</p></blockquote><p><span class="emoji" alias="exclamation" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">&#x2757;</span> <strong>提醒：</strong>圓餅圖的數據點雖然也可以用這個方式法設定，但會缺失數據點名稱。</p><hr><h2 id="數據點設定-陣列設定法"><a href="#數據點設定-陣列設定法" class="headerlink" title="數據點設定 - 陣列設定法"></a>數據點設定 - 陣列設定法</h2><br/><pre><code class="javascript">series: [&#123;  // 數據點設定-陣列型別[Number,Number]  data: [[0, 5], [3, 5], [6, 12]]&#125;]</code></pre><p>若以陣列來設定數據點的話，這個陣列就必須要有兩個型別為「數字」的值，其一會被 Highcharts 解析為數據點的Ｘ軸數值，其二為Ｙ軸數值。</p><blockquote><p>如果數據點需要有指定Ｘ數值的話，就必須採用這個設定方式，例如散佈圖或是加速度圖這種類的圖表，不過缺點依然是無法對數據點進行額外的屬性設定。</p></blockquote><br/><br/><pre><code class="javascript">series: [&#123;  // 數據點設定-陣列型別[String,Number]  data: [[&quot;數據點1&quot;, 5], [&quot;數據點3&quot;, 5], [&quot;數據點3&quot;, 12]] &#125;]</code></pre><p>或是你也可以將第一個值改為字串，這樣 Highcharts 就會把第一個值解析為該數據點的名稱，而第二個值依然是Ｙ軸數值。</p><blockquote><p>這種設定方式雖然和「數值設定法」很像，就只是多了一個名稱的字串而已，但卻是圓餅圖很常用的數據點設定方式。</p></blockquote><hr><h2 id="數據點設定-物件設定法"><a href="#數據點設定-物件設定法" class="headerlink" title="數據點設定 - 物件設定法"></a>數據點設定 - 物件設定法</h2><br/><pre><code class="javascript">series: [&#123;  // 數據點設定-物件型別  data: [    &#123; x:5, y: 5, name: &quot;Point1&quot; &#125;,    &#123; x:8, y: 8, name: &quot;Point2&quot; &#125;  ] &#125;]</code></pre><p>如果以物件型別來設定數據點，那靈活性就非常高了，因為每個數據點（物件）內部又有不少屬性可以個別設定，也就代表每個數據點都可以有不同的外觀或特性。</p><p>但其實數據點大部分的屬性在數據列都有，只不過數據列設定是一次改變所有數據點，而數據點設定就單單只是改變它自身，下面的話我們就只介紹數據點才有的屬性，要看全部到話就到 <strong><a href="https://api.highcharts.com/highcharts/series.line.data">官方文件</a></strong> 吧。</p><br/><br/><h4 id="series-data-x-series-data-y"><a href="#series-data-x-series-data-y" class="headerlink" title="# series.data.x / series.data.y"></a># series.data.x / series.data.y</h4><p><code>型別: Number</code> <code>預設: undefined</code></p><p><strong>特別注意，這裡的Ｘ和Ｙ不再是調整偏移量了，它們設定的是數據點的Ｘ軸數值以及Ｙ軸數值。</strong></p><p>Ｘ軸數值並非必要屬性是可以省略的，甚至某些圖表也不會有 <code>x</code> 屬性（如圓餅圖），但Ｙ軸數值就是必須的了，如果沒設定就等同沒有數據，沒有數據就畫不出數據點。</p><br/><br/><h4 id="series-data-name"><a href="#series-data-name" class="headerlink" title="# series.data.name"></a># series.data.name</h4><p><code>型別: String</code> <code>預設: undefined</code></p><p>這個屬性可以對數據點設定名稱，如果有設定的話提示框還會以名稱來取代Ｘ軸刻度標籤，另外這個屬性對圓餅圖來說也很重要，因為圓餅圖的圖例、數據標籤顯示的都是「數據點名稱」，而非數據列名稱或數值。</p><br/><br/><h4 id="series-data-className"><a href="#series-data-className" class="headerlink" title="# series.data.className"></a># series.data.className</h4><p><code>型別: String</code> <code>預設: undefined</code></p><p>顧名思義，這個屬性是用來增加數據點在 HTML 中的 Class Attribute 的，好處是我們可以更針對性地選取到某個數據點，可以方便日後進行圖表互動。</p><br/><br/><h4 id="series-data-legendIndex"><a href="#series-data-legendIndex" class="headerlink" title="# series.data.legendIndex"></a># series.data.legendIndex</h4><p><code>型別: Number</code> <code>預設: undefined</code></p><p>前面有說圓餅圖的圖例顯示的是「數據點名稱」，而這個屬性就是讓圓餅圖數據點可以調整圖例順序的，用法和 <code>series.legendIndex</code> 一樣。</p><br/><br/><h4 id="series-data-sliced"><a href="#series-data-sliced" class="headerlink" title="# series.data.sliced"></a># series.data.sliced</h4><p><code>型別: Boolean</code> <code>預設: undefined</code></p><p>這個屬性也是圓餅圖的數據點才有，讓你可以決定某塊扇形是否要向外突出。而突出的偏移量你可以用數據列的 <code>series.slicedOffset</code> 屬性來調整。</p><img src="sliced.png" style="max-width: 600px; margin: 12px auto;" alt="特別突顯25-29歲" /><blockquote><p>物件設定法適用於所有圖表類型，而且非常適合各數據點差異性大的情況。</p></blockquote><hr><h2 id="數據點設定-混合"><a href="#數據點設定-混合" class="headerlink" title="數據點設定 - 混合"></a>數據點設定 - 混合</h2><br/><pre><code class="javascript">series: [&#123;  data: [[0, 5, &#123;y: 3, name: &quot;數據點&quot;&#125;, 5]] // 數字混物件&#125;]</code></pre><pre><code class="javascript">series: [&#123;  data: [[0, 5], &#123;x: 3, y: 5, name: &quot;數據點&quot;&#125;, [6, 12]] // 陣列混物件&#125;]</code></pre><p>是的沒錯，以上這三種設定法還可以混用，讓你的數據點設定更加彈性輕鬆，不過數字搭陣列的效果不是很優，所以大部分都是用物件去搭配另外兩種。</p><blockquote><p>這種混和的設定方法，很適合用在你想要為某幾個特定的數據點進行額外設定時使用。</p></blockquote><hr><h2 id="數據點設定-陣列搭配Keys設定法"><a href="#數據點設定-陣列搭配Keys設定法" class="headerlink" title="數據點設定 - 陣列搭配Keys設定法"></a>數據點設定 - 陣列搭配Keys設定法</h2><br/><pre><code class="javascript">series: [&#123;  keys: [&quot;y&quot;, &quot;name&quot;, &quot;className&quot;],  data: [    [13, &quot;數據點一&quot;, &quot;point-1&quot;],    [21, &quot;數據點二&quot;, &quot;point-2&quot;]  ]&#125;]</code></pre><p>這種設定方式比較特別，它和陣列設定法一樣是以陣列設定數據點，但卻能放進不只兩個項目，而且沒有順序的限制。不過這樣的彈性，使得 Highcharts 不知道如何解析陣列裡的數值，此時就需要借助 <code>keys</code> 的幫忙。</p><br/><h4 id="series-keys"><a href="#series-keys" class="headerlink" title="# series.keys"></a># series.keys</h4><p><code>型別: Array[String]</code> <code>預設: undefined</code> </p><p>這個屬性融合了陣列設定法與物件設定法，讓你能用陣列設定數據點卻又可以加入額外屬性，而使用方式是提供 <code>keys</code> 一組陣列，陣列項目為想設定的<strong>數據點屬性名稱</strong>，接下來你只要按這個陣列的順序來設定數據點，Highcharts 就會以這個順序去解析你的 <code>data</code> 項目。</p><br/><blockquote><p>如果你想調整的數據點屬性僅僅只有一兩個，那就很適合使用這種設定方式，不用像物件法一樣搞得很冗長，卻又能設定少量的額外屬性。</p></blockquote><p><br/><br/></p><p>恭喜各位，我們已經把最重要的數據列與數據點介紹完了，雖然後面還有一部分的設定技巧和屬性，但基本上到這裡你就可以很順利的將 Highcharts 導入專案中了，那明天我們要介紹的是「繪圖區」，雖然它是圖表中占比不小的元素區塊，但它其實不僅沒有額外屬性，還能為我們省很多事。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10243702">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/rNevgYm&quot;&gt;https://codepen.io/max-lee/pen/rNevgYm&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;避免文章篇幅</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 數據列設定</title>
    <link href="https://maxleebk.com/2020/09/24/highchart/highcharts-10/"/>
    <id>https://maxleebk.com/2020/09/24/highchart/highcharts-10/</id>
    <published>2020-09-24T01:50:00.000Z</published>
    <updated>2023-10-23T03:50:24.352Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/mdPxGyq">https://codepen.io/max-lee/pen/mdPxGyq</a></strong><br>避免文章篇幅過長，沒辦法每個屬性都利用圖片示意，所以記得善用範例來測試不太了解的屬性。</p></blockquote><p>我們前面的章節其實時不時都會提到數據列，而所謂的數據列指的是「一系列的數據」，這些數據是以某個統一的基準進行統計與計算的，然後在圖表中我們將這一系列的數據畫出合適的圖形。而數據列設定其實就是在設定圖表上這些具體圖形。</p><hr><h2 id="數據列設定"><a href="#數據列設定" class="headerlink" title="數據列設定"></a>數據列設定</h2><br/><p>同樣的一組數據列，在不同的圖表中就會用不同圖形呈現，所以數據列設定會根據你的圖表類型有不一樣的屬性，不過我們先介紹所有圖表都通用的屬性，最後再補充一些不同圖表類型的專屬屬性。</p><p><strong>特別注意，同一張圖表中可以有多組數據列，所以是用陣列來做設定，就算只有一組數據列也「不能」省略中括號。</strong></p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  series: [&#123;&#125;] // 數據列設定&#125;);</code></pre><br/><h4 id="series-type"><a href="#series-type" class="headerlink" title="# series.type"></a># series.type</h4><p><code>型別: String</code> <code>預設: undefined</code></p><p>在圖表整體設定中有介紹過 <code>chart.type</code> 這個非常重要的屬性，它決定了圖表是何種類型，所以在一般情況下你不用再特別設定 <code>series.type</code>，因為它會直接從整體設定中繼承。</p><p><strong>但是，Highcharts 是可以製作複合圖表的，像是柱狀圖和折線圖就常常搭配使用，此時就必須為數據列指定它的資料類型了。</strong></p><img src="complex.png" style="max-width: 600px; margin: 12px auto;" alt="折線圖與柱狀圖的複合圖表" /><br/><h4 id="series-data"><a href="#series-data" class="headerlink" title="# series.data"></a># series.data</h4><p><code>型別: Array[Number|Array|Object]</code> <code>預設: undefined</code></p><p>這是整個圖表中<strong>「最重要」</strong>的屬性，也就是我們賦予圖表資料的地方，但是因為它設定的方式有很多種，加上數據點 (point) 又還有獨立的屬性，所以讓我明天再用整篇文章來好好介紹，今天暫時先跳過。</p><br/><br/><h4 id="series-name"><a href="#series-name" class="headerlink" title="# series.name"></a># series.name</h4><p><code>型別: String</code> <code>預設: undefined</code></p><p>這個屬性是設定數據列名稱用的，其用處在於「圖例」會以這個名稱來標示你的數據列，基本上沒有不設置理由。不過部分圖表的圖例顯示的可能會是數據點 (point) 名稱，如圓餅圖。</p><br/><br/><h4 id="series-visible"><a href="#series-visible" class="headerlink" title="# series.visible"></a># series.visible</h4><p><code>型別: Boolean</code> <code>預設: true</code></p><p>這個屬性可以設定該數據列是否要在初始化時顯示，不過設為 <code>false</code> 並不是完全消失，依然可以透過點擊圖例來再次顯示。</p><br/><br/><h4 id="series-showInLegend"><a href="#series-showInLegend" class="headerlink" title="# series.showInLegend"></a># series.showInLegend</h4><p><code>型別: Boolean</code> <code>預設: true | false</code></p><p>這個屬性我們之前在圖例設定有提過，在某些圖表類型中，數據列不會顯示圖例，必須開啟這個屬性才會出現。而如果你希望某個數據列不要出現在圖例中的話，也可以特別將其設為 <code>false</code>。</p><br/><br/><h4 id="series-index-series-legendIndex-series-zIndex"><a href="#series-index-series-legendIndex-series-zIndex" class="headerlink" title="# series.index / series.legendIndex / series.zIndex"></a># series.index / series.legendIndex / series.zIndex</h4><p><code>型別: Number</code> <code>預設: undefined</code></p><p>因為數據列設定是陣列，所以每組數據列都有索引值，這個索引值會影響「圖例的順序」以及「圖形覆蓋的順序」，而你可以透過 <code>index</code> 來手動決定數據列的索引值，或是你也可以單一去調整 <code>legendIndex</code> 來改變圖例的順序，以及調整 <code>zIndex</code> 來改變覆蓋的上下順序。</p><br/><br/><h4 id="series-cursor"><a href="#series-cursor" class="headerlink" title="# series.cursor"></a># series.cursor</h4><p><code>型別: String</code> <code>預設: undefined</code></p><p>調整鼠標移至數據列上時的光標樣式，適用的值與 CSS 相同。</p><br/><br/><h4 id="series-allowPointSelect"><a href="#series-allowPointSelect" class="headerlink" title="# series.allowPointSelect"></a># series.allowPointSelect</h4><p><code>型別: Boolean</code> <code>預設: false</code></p><p>決定數據列上的數據點（point）能否被選取，選取之後該數據點會有外觀上的改變，並且你可以透過 <code>getSelectedPoints</code> 這個函式來取得「被選取的」數據點的相關訊息。</p><pre><code class="javascript">// 在數據列設定裡增加 allowPointSelect 屬性var myChart = Highcharts.chart(container, &#123;  series: [&#123; allowPointSelect: true &#125;]&#125;);// 在畫面上新增一個按紐，並監聽點擊事件document.querySelector(&quot;button&quot;).adEventListener(&quot;click&quot;, function()&#123;  console.log(myChart.getSelectedPoints()); // 數據點相關的訊息&#125;);</code></pre><p>有興趣的話我也有準備完整的範例：<strong><a href="https://codepen.io/max-lee/pen/MWyVOmP">https://codepen.io/max-lee/pen/MWyVOmP</a></strong></p><br/><br/><h4 id="series-enableMouseTracking"><a href="#series-enableMouseTracking" class="headerlink" title="# series.enableMouseTracking"></a># series.enableMouseTracking</h4><p><code>型別: Boolean</code> <code>預設: true</code></p><p>開啟或關閉數據列的滑鼠互動，一般來說鼠標停留在數據列上時樣式會稍微改變並顯示提示框，但當你關閉這個屬性時，便不會再有這些效果。</p><br/><br/><h4 id="series-shadow"><a href="#series-shadow" class="headerlink" title="# series.shadow"></a># series.shadow</h4><p><code>型別: Boolean|Object</code> <code>預設: false</code></p><p>你可以為數據列開啟陰影的選項，重現一種不一樣的畫面風格。也可以透過傳入物件來微調陰影的樣式，有需要可以看看 <strong><a href="https://api.highcharts.com/class-reference/Highcharts.ShadowOptionsObject">官方文件</a></strong>，文章中就不多著墨。</p><br/><br/><h4 id="series-xAxis-series-yAxis"><a href="#series-xAxis-series-yAxis" class="headerlink" title="# series.xAxis / series.yAxis"></a># series.xAxis / series.yAxis</h4><p><code>型別: Number</code> <code>預設: 0</code></p><p>在「座標軸設定」時有說過，只要在座標軸設定中傳入陣列就可以畫出複數Ｘ軸或複數Ｙ軸，這樣的話勢必要為數據列指定它該以哪一組座標軸作為尺標，而這兩個屬性的作用就是如此，設定時要傳入的是你要指定的座標軸索引值。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  yAxis: [    &#123; &#125;, // 第一組Ｙ軸設定，索引值：0    &#123; &#125;  // 第二組Ｙ軸設定，索引值：1  ],  series: [    &#123; yAxis: 0 &#125;, // 採用第一組Ｙ軸    &#123; yAxis: 1 &#125;  // 採用第二組Ｙ軸  ]&#125;);</code></pre><br/><br/><h4 id="series-stacking"><a href="#series-stacking" class="headerlink" title="# series.stacking"></a># series.stacking</h4><p><code>型別: String</code> <code>預設: undefined</code></p><p>這個屬性可以決定數據列的堆疊模式，讓數據點的數值疊加上去，很適合用在面積圖或柱狀圖，有純粹疊加數值的 <code>normal</code> 模式，或是計算成百分比的 <code>percent</code> 模式。而在不同的模式下圖表會被賦予不同的意義，所以使用前要仔細思考你的用途是什麼。</p><p>範例：<strong><a href="https://codepen.io/max-lee/pen/yLOjYMj">https://codepen.io/max-lee/pen/yLOjYMj</a></strong></p><p><img src="stacking.png" alt=""></p><hr><h2 id="數據標籤設定"><a href="#數據標籤設定" class="headerlink" title="數據標籤設定"></a>數據標籤設定</h2><br/><p>數據標籤是呈現在每個數據點附近用來明確標示個數據點數值的文字標籤，可以讓觀看者不用對照座標軸就能立即獲得資料數據。由於數據標籤的屬性不少都跟前面介紹的圖表元素重複了，所以我們下面就只介紹一些比較重要的，想看完整內容再請大家到 <strong><a href="https://api.highcharts.com/highcharts/series.line.dataLabels">官方文件</a></strong>。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  series: [&#123;    dataLabels: &#123;&#125; // 數據標籤設定  &#125;],&#125;);</code></pre><img src="dataLabels.png" style="max-width: 600px; margin: 12px auto;" alt="其中一個數據列加上數據標籤" /><h4 id="series-dataLabels-enabled"><a href="#series-dataLabels-enabled" class="headerlink" title="# series.dataLabels.enabled"></a># series.dataLabels.enabled</h4><p><code>型別: Boolean</code> <code>預設: true|false</code></p><p>數據標籤在某些圖表類型是預設顯示，有些則無，但你依然可以透過這個屬性來決定是否顯示。</p><br/><br/><h4 id="series-dataLabels-allowOverlap"><a href="#series-dataLabels-allowOverlap" class="headerlink" title="# series.dataLabels.allowOverlap"></a># series.dataLabels.allowOverlap</h4><p><code>型別: Boolean</code> <code>預設: true|false</code></p><p>這個屬性是決定數據標籤之間能不能重疊，在數據點比較密集情況下，數據標籤常常會擠在一起影響閱讀，這時後就可以禁止重疊，Highcharts 會自動把部分標籤給隱藏。</p><br/><br/><h4 id="series-dataLabels-overflow"><a href="#series-dataLabels-overflow" class="headerlink" title="# series.dataLabels.overflow"></a># series.dataLabels.overflow</h4><p><code>型別: String</code> <code>預設: &quot;justify&quot;</code></p><p>這個屬性會控制數據標籤在溢出繪圖區 (plot) 時的作法，預設情況下它調整溢出標籤的對齊設定，想辦法讓它進到繪圖區內。但假如你不想破壞標籤的位置一致性，你可以把這個屬性改為 <code>allow</code>，那它就會放任數據標籤渲染到繪圖區外。</p><br/><br/><h4 id="series-dataLabels-crop"><a href="#series-dataLabels-crop" class="headerlink" title="# series.dataLabels.crop"></a># series.dataLabels.crop</h4><p><code>型別: Boolean</code> <code>預設: true</code></p><p>這個屬性似乎只是輔助 <code>overflow</code> 用的，當你把 <code>overflow</code> 改為 <code>allow</code>，那你必須將這個屬性一起改為 <code>false</code>，才能達到效果。</p><br/><br/><h4 id="series-dataLabels-format-series-dataLabels-formatter"><a href="#series-dataLabels-format-series-dataLabels-formatter" class="headerlink" title="# series.dataLabels.format / # series.dataLabels.formatter"></a># series.dataLabels.format / # series.dataLabels.formatter</h4><p>相信你已經發現了，只要是<strong>標籤</strong>或<strong>隨資料變動的文字</strong>都會有這兩個「格式化屬性」，但請耐住性子，我們後面會再好好介紹的。</p><hr><h2 id="線條類圖表專屬設定"><a href="#線條類圖表專屬設定" class="headerlink" title="線條類圖表專屬設定"></a>線條類圖表專屬設定</h2><br/><blockquote><p>線條類的圖表算是最常見的，適用的 <code>type</code> 有折線圖 (line)、曲線圖 (spline)、折線面積圖 (area)、曲線面積圖 (areaspline) 等…</p></blockquote><br/><h4 id="series-lineWidth"><a href="#series-lineWidth" class="headerlink" title="# series.lineWidth"></a># series.lineWidth</h4><p><code>型別: Number</code> <code>預設: 2</code></p><p>應該非常容易理解，這個屬性是調整線條類圖表中「線」的粗，單位為 <code>px</code>，如果設為 <code>0</code> 線便會消失。</p><br/><br/><h4 id="series-dashStyle"><a href="#series-dashStyle" class="headerlink" title="# series.dashStyle"></a># series.dashStyle</h4><p><code>型別: String</code> <code>預設: &quot;Solid&quot;</code></p><p>可以改變線條類圖表中「線」的線條樣式，所有樣式可以看 <strong><a href="https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-dashstyle-all/">官方範例</a></strong>。</p><br/><br/><h4 id="series-marker"><a href="#series-marker" class="headerlink" title="# series.marker"></a># series.marker</h4><p><code>型別: Object</code> <code>預設: 請見下方</code></p><p>Marker 指的是線條類圖表中標記「數據點」的符號，預設是實心圓，而你可以透過一組物件來調整他的樣式。下面我們只介紹幾個重要的，要了解所有屬性請看 <strong><a href="https://api.highcharts.com/highcharts/series.line.marker">官方文件</a></strong>。</p><p>簡單的範例：<strong><a href="https://codepen.io/max-lee/pen/zYqjGya">https://codepen.io/max-lee/pen/zYqjGya</a></strong></p><pre><code class="javascript">series: [&#123;  marker: &#123;    enabled: true,          // 是否要顯示 marker    fillColor: undefined,   // 圖形的填色，預設繼承數據列顏色    lineWidth: 0,           // 圖形的外框粗細    lineColor: &quot;#ffffff&quot;,   // 圖形的外框填色，改為 undefined 則繼承數據列顏色    radius: 4,              // 圖形的半徑    symbol: &quot;circle&quot;        // 決定圖形的形狀，有&quot;circle&quot;,&quot;square&quot;,&quot;diamond&quot;,&quot;triangle&quot;,&quot;triangle-down&quot;  &#125;&#125;],</code></pre><hr><h2 id="長條類圖表專屬設定"><a href="#長條類圖表專屬設定" class="headerlink" title="長條類圖表專屬設定"></a>長條類圖表專屬設定</h2><br/><blockquote><p>長條類的圖表也是很常見，常用的 <code>type</code> 主要有直橫兩種的柱狀圖 (column) 及橫條圖 (bar)。</p></blockquote><br/><h4 id="series-pointWidth"><a href="#series-pointWidth" class="headerlink" title="# series.pointWidth"></a># series.pointWidth</h4><p><code>型別: Number</code> <code>預設: undefined</code></p><p>長條類圖表中的矩形寬度會因應圖表大小而調整，但你可以透過這個屬性自行決定一個固定的寬度。</p><br/><br/><h4 id="series-minPointLength"><a href="#series-minPointLength" class="headerlink" title="# series.minPointLength"></a># series.minPointLength</h4><p><code>型別: Number</code> <code>預設: 0</code></p><p>在一組數據列中，假如有某個數據點的數值大幅低於平均值，那該數據點的矩形很有可能會被 Highcharts 省略，此時你可以利用這個屬性來決定圖表中的矩形最短要多少長度。</p><br/><br/><h4 id="series-stack"><a href="#series-stack" class="headerlink" title="# series.stack"></a># series.stack</h4><p><code>型別: Number</code> <code>預設: undefined</code></p><p>這個屬性其他類型的圖表也有，但用在長條類圖表中效果是最好的，當你開啟 <code>stacking</code> 時，這個屬性可以決定堆疊的分組方式。</p><p>你可以調整看看這個範例的 <code>stack</code> 屬性：<strong><a href="https://codepen.io/max-lee/pen/PoNeqMZ">https://codepen.io/max-lee/pen/PoNeqMZ</a></strong></p><p><img src="stack.png" alt=""></p><hr><h2 id="圓餅圖專屬設定"><a href="#圓餅圖專屬設定" class="headerlink" title="圓餅圖專屬設定"></a>圓餅圖專屬設定</h2><br/><blockquote><p>另外一個常見的圖表類型就是圓餅圖，但因為它和那些有座標軸的圖表類型相當不同，所以專屬的屬性也就比較多。</p></blockquote><br/><h4 id="series-size-series-innerSize"><a href="#series-size-series-innerSize" class="headerlink" title="# series.size / # series.innerSize"></a># series.size / # series.innerSize</h4><p><code>型別: Number|String</code> <code>預設: null</code></p><p>你可以用像素(可省略單位)或百分比調整圓餅圖的尺寸，甚至可以用 <code>innerSize</code> 設定圓餅圖的內圈空白，來讓圓餅圖改為甜甜圈圖。</p><p>有興趣可以看看範例：<strong><a href="https://codepen.io/max-lee/pen/eYZrYQo">https://codepen.io/max-lee/pen/eYZrYQo</a></strong></p><img src="donut.png" style="max-width: 600px; margin: 12px auto;" alt="" /><br/><br/><h4 id="series-dataLabels-distance"><a href="#series-dataLabels-distance" class="headerlink" title="# series.dataLabels.distance"></a># series.dataLabels.distance</h4><p><code>型別: Number|String</code> <code>預設: 30</code></p><p>這是圓餅圖的數據標籤才有的圖特屬性，它可以調整標籤距離圓餅圖的距離，可以接受像素或百分比，而且如果以負數設定的話，標籤會顯示在圓餅圖內部。</p><br/><br/><h4 id="series-dataLabels-connectorWidth"><a href="#series-dataLabels-connectorWidth" class="headerlink" title="# series.dataLabels.connectorWidth"></a># series.dataLabels.connectorWidth</h4><p><code>型別: Number|String</code> <code>預設: 30</code></p><p>如果圓餅圖中某幾個數據點所佔的百分比較低時會導致扇形面積較小，讓數據標籤難以顯示，所以 Highcharts 會將某些標籤的距離拉遠並用連接線標示，而你可以用這個屬性來調整連間線的粗細。</p><p>另外還可以透過 <code>connectorColor</code>、<code>connectorShape</code> 來調整連接線的顏色和形狀，有興趣的話再到 <strong><a href="https://api.highcharts.com/highcharts/series.pie.dataLabels">官方文件</a></strong> 看看，這邊就不細說了。</p><p><br/><br/></p><p>今天介紹了數據列中比較常用的一些屬性，不過 Highcharts 的圖表類型實在太多了，每種數據列的設定都不太一樣，請原諒我沒辦法全部介紹，但這種大型的 library 本來就是邊做邊查，所以剩下的屬性就留給大家慢慢發掘吧！</p><p>至於明天，終於要輪到整個圖表的靈魂「數據點」的設定了！</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10243081">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/mdPxGyq&quot;&gt;https://codepen.io/max-lee/pen/mdPxGyq&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;避免文章篇幅</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 座標軸設定 - 座標刻度</title>
    <link href="https://maxleebk.com/2020/09/23/highchart/highcharts-9/"/>
    <id>https://maxleebk.com/2020/09/23/highchart/highcharts-9/</id>
    <published>2020-09-23T10:07:00.000Z</published>
    <updated>2023-10-23T03:50:24.516Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/KKzQmRZ">https://codepen.io/max-lee/pen/KKzQmRZ</a></strong><br>避免文章篇幅過長，沒辦法每個屬性都利用圖片示意，所以記得善用範例來測試不太了解的屬性。</p></blockquote><p>雖然有部分圖表類型（如圓餅圖、文字雲）並不會用到座標軸，但大多數常見的圖表都是需要座標軸來輔助的，座標軸提供的是一個絕對值尺標，讓觀看者可以得到確切的資料數值，而非只是觀察資料間的相對關係。</p><p>由於座標軸的屬性較多，將會以屬性性質的不同分為「外觀樣式」與「座標刻度」兩篇文章來介紹。</p><hr><h2 id="座標軸設定-座標刻度相關"><a href="#座標軸設定-座標刻度相關" class="headerlink" title="座標軸設定 - 座標刻度相關"></a>座標軸設定 - 座標刻度相關</h2><br/><p>以常見的折線圖或長條圖來說，一般Ｘ座標軸的刻度通常是標示數據列的項目或日期，Ｙ座標軸刻度則標示數據列的統計數值（數字），但也有部分圖表的ＸＹ座標軸會各別標示不同的統計數值，例如速度曲線圖表會於ＸＹ座標軸上顯示時間和距離的數值。</p><p><strong>特別注意，座標軸的設定其實是使用陣列，因為圖表是可以有多Ｘ軸或多Ｙ軸的，但如果確定只有單個的話，你可以省略陣列的中括號。</strong></p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  xAxis: [&#123;&#125;], // Ｘ座標軸設定  yAxis: [&#123;&#125;]  // Ｙ座標軸設定&#125;);</code></pre><br/><blockquote><p>以下以 Axis 同時表示 xAxis 及 yAxis</p></blockquote><br/><h4 id="Axis-visible"><a href="#Axis-visible" class="headerlink" title="# Axis.visible"></a># Axis.visible</h4><p><code>型別: Boolean</code> <code>預設: true</code></p><p>座標軸正常來說是必要的圖表元素，所以不像其他元素有 <code>enabled</code> 屬性來做開關，但你可以用 <code>visible</code> 來隱藏座標軸。</p><br/><br/><h4 id="Axis-type"><a href="#Axis-type" class="headerlink" title="# Axis.type"></a># Axis.type</h4><p><code>型別: String</code> <code>預設: &quot;linear</code></p><p>座標軸共有四種類型可以設定，</p><ul><li>線性（linear）：線性會根據你提供的數據去做由小到大的數字刻度</li><li>類別（category）：當你有設定 <code>Axis.categories</code> 時，座標軸會自動改成「類別」類型，並以你提供的 category 作為座標刻度</li><li>日期（datetime）：以日期作為座標刻度。因為必須配合數據列（series）一起設定，所以我們會在後面的章節詳細介紹</li><li>對數（logarithmic）：以對數作為座標刻度，也就是高中數學教的 log，由於使用情境太少，所以就不多作介紹</li></ul><p><img src="type.png" alt=""></p><p>如果你好奇線性座標如何設定的話可以看這個範例：<strong><a href="https://codepen.io/max-lee/pen/eYZVWxP">https://codepen.io/max-lee/pen/eYZVWxP</a></strong></p><br/><br/><h4 id="Axis-categories"><a href="#Axis-categories" class="headerlink" title="# Axis.categories"></a># Axis.categories</h4><p><code>型別: Array[String]</code> <code>預設: undefined</code></p><p>當你要以類別作為座標刻度時，你需要為這個屬性提供一組陣列，當中即是你所要顯示的類別字串，我們的範例就是一個使用 <code>categories</code> 的案例，</p><pre><code class="javascript">xAxis: &#123;  categories: [&quot;18-24歲&quot;, &quot;25-29歲&quot;, &quot;30-34歲&quot;]&#125;</code></pre><br/><br/><h4 id="Axis-tickAmount"><a href="#Axis-tickAmount" class="headerlink" title="# Axis.tickAmount"></a># Axis.tickAmount</h4><p><code>型別: Number</code> <code>預設: undefined</code></p><p>這個屬性是線性類型專屬，它可以控制你的座標刻度的數量，如果沒有設定的話，則 Highcharts 會自動幫你計算合適的數量。</p><br/><br/><h4 id="Axis-tickInterval-Axis-minorTickInterval"><a href="#Axis-tickInterval-Axis-minorTickInterval" class="headerlink" title="# Axis.tickInterval / Axis.minorTickInterval"></a># Axis.tickInterval / Axis.minorTickInterval</h4><p><code>型別: Number</code> <code>預設: undefined</code></p><p>座標刻度之間要相隔多少數值也是可以調整的，而根據不同的座標軸類型會有不同的定義：</p><ul><li>線性（linear）：表示刻度相隔多少「值」，若設定 <code>2</code>，則刻度會是 <code>0</code>, <code>2</code>, <code>4</code>, <code>6</code>, <code>8</code>…</li><li>類別（category）：表示刻度間相隔多少「個」，預設是 <code>1</code> 每個都會出現，若設定 <code>2</code>，則只有奇數個會出現</li><li>日期（datetime）：表示刻度間相隔多少「毫秒」，若設定 <code>24 * 3600 * 1000</code>，則刻度之間會相隔一天</li></ul><br/><br/><h4 id="Axis-minTickInterval"><a href="#Axis-minTickInterval" class="headerlink" title="# Axis.minTickInterval"></a># Axis.minTickInterval</h4><p><code>型別: Number</code> <code>預設: undefined</code></p><p>和上面兩個很類似的還有這個屬性，你可以設定座標刻度「最少」要間隔多少數值，定義方法跟上面列舉的方式一模一樣。</p><br/><br/><h4 id="Axis-tickPositions"><a href="#Axis-tickPositions" class="headerlink" title="# Axis.tickPositions"></a># Axis.tickPositions</h4><p><code>型別: Array[Number]</code> <code>預設: undefined</code></p><p>你可以用這個屬性來決定「哪幾個」座標刻度要出現，設定時你需要提供一組陣列，陣列裡則是你希望顯示刻度的索引，當然在線性座標軸中數值本身就是索引。</p><br/><br/><h4 id="Axis-tickPositioner"><a href="#Axis-tickPositioner" class="headerlink" title="# Axis.tickPositioner"></a># Axis.tickPositioner</h4><p><code>型別: Function =&gt; Array[Number]</code> <code>預設: undefined</code></p><p>這個屬性與 <code>tickPositions</code> 有一樣的功能，不過你提供的是一個函式，想當然這個函式的輸出也必須是索引陣列，但好處是你可以進行一些計算，而且在函式中你可以透過 <code>this.tickPositions</code> 來拿到初始的刻度索引陣列。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  xAxis: &#123;    tickPositions: [1, 3, 6, 7]  &#125;,  yAxis: &#123;    tickPositioner() &#123;      console.log(this.tickPositions) // [0, 10, 20, 30, 40]       return [...this.tickPositions, 44.3, 55, 60, 100]    &#125;  &#125;&#125;</code></pre><img src="tickPositions.png" style="max-width: 600px; margin: 20px auto;" /><h4 id="Axis-reversed"><a href="#Axis-reversed" class="headerlink" title="# Axis.reversed"></a># Axis.reversed</h4><p><code>型別: Boolean</code> <code>預設: false</code></p><p>一般來說座標刻度大小是由左至右/由下至上地排列，但你可用這個屬性將這樣的順序給顛倒。</p><br/><br/><h4 id="Axis-opposite"><a href="#Axis-opposite" class="headerlink" title="# Axis.opposite"></a># Axis.opposite</h4><p><code>型別: Boolean</code> <code>預設: false</code></p><p>這個屬性可以決定要不要讓座標軸出現在另外一邊，即Ｘ軸出現在上方或Ｙ軸出現在右邊，像如果你有雙座標軸的話，其中一個就可以放在另一邊。</p><br/><br/><h4 id="Axis-alignTicks"><a href="#Axis-alignTicks" class="headerlink" title="# Axis.alignTicks"></a># Axis.alignTicks</h4><p><code>型別: Boolean</code> <code>預設: false</code></p><p>另一個與雙座標軸相關的屬性是 <code>alignTicks</code>，它可以決定兩邊的座標刻度是否要對齊，關掉的話觀看起來會比較混亂，所以如果沒特殊需求的話一般不會調整。</p><p><img src="alignTicks.png" alt=""></p><br/><h4 id="Axis-allowDecimals"><a href="#Axis-allowDecimals" class="headerlink" title="# Axis.allowDecimals"></a># Axis.allowDecimals</h4><p><code>型別: Boolean</code> <code>預設: true</code></p><p>這個屬性可以決定是否允許出現浮點數的座標軸刻度，如果不希望出現小數點記得要設為 <code>false</code>。</p><br/><br/><h4 id="Axis-max-Axis-min"><a href="#Axis-max-Axis-min" class="headerlink" title="# Axis.max / Axis.min"></a># Axis.max / Axis.min</h4><p><code>型別: Number</code> <code>預設: undefined</code></p><p>預設的情況下 Highcharts 會自動幫你計算合適的座標刻度的數值範圍，但你可以用這兩個屬性來設定座標軸的最大／最小刻度，並且會固定顯示在座標軸上，當有數據點高於 <code>max</code> 或低於 <code>min</code> 就會被畫布切掉。</p><br/><br/><h4 id="Axis-softMax-Axis-softMin"><a href="#Axis-softMax-Axis-softMin" class="headerlink" title="# Axis.softMax / Axis.softMin"></a># Axis.softMax / Axis.softMin</h4><p><code>型別: Number</code> <code>預設: undefined</code></p><p>與上面的 <code>min/max</code> 相似，這兩個屬性也是設定座標軸的最大／最小刻度，並且會固定顯示在座標軸上，不過當有數據點高於 <code>softMax</code> 或低於 <code>softMin</code> 時並不會被切掉，而是會重新計算合適的刻度數值。</p><br/><br/><h4 id="Axis-ceiling-Axis-floor"><a href="#Axis-ceiling-Axis-floor" class="headerlink" title="# Axis.ceiling / Axis.floor"></a># Axis.ceiling / Axis.floor</h4><p><code>型別: Number</code> <code>預設: undefined</code></p><p>另外一組設定最大／最小刻度的是 <code>ceiling</code> 和 <code>floor</code>，當你設定它們時，它們並不會固定顯示在座標軸上，而是當有數據點高於 <code>softMax</code> 或低於 <code>softMin</code> 時才會出現，並且將其切掉。</p><p>想更清楚了解上面三組屬性之間的差別可以看這個範例 <strong><a href="https://codepen.io/max-lee/pen/NWNXoVy">https://codepen.io/max-lee/pen/NWNXoVy</a></strong></p><img src="max.png" style="max-width: 800px; margin: 20px auto;" /><br/><h4 id="Axis-startOnTick-Axis-endOnTick"><a href="#Axis-startOnTick-Axis-endOnTick" class="headerlink" title="# Axis.startOnTick / Axis.endOnTick"></a># Axis.startOnTick / Axis.endOnTick</h4><p><code>型別: Boolean</code> <code>預設: 請見提醒</code></p><p>這兩個屬性可以控制你的座標軸是否要以一個座標刻度做開頭／結尾，如果設為 <code>false</code>，第一個／最後一個座標刻度就會與繪圖區 (plot) 邊界有些微的間距。</p><p><span class="emoji" alias="exclamation" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">&#x2757;</span> <strong>提醒：</strong>Ｘ軸預設均為 <code>false</code>，Ｙ軸預設均為 <code>true</code>。</p><br/><br/><h4 id="Axis-showFirstLabel-Axis-showLastLabel"><a href="#Axis-showFirstLabel-Axis-showLastLabel" class="headerlink" title="# Axis.showFirstLabel / Axis.showLastLabel"></a># Axis.showFirstLabel / Axis.showLastLabel</h4><p><code>型別: Boolean</code> <code>預設: true</code></p><p>決定座標軸的第一個／最後一個座標刻度要不要顯示它的文字標籤。 </p><p><br/><br/></p><p>我們終於花了兩天把常見的座標軸屬性都介紹完了，不過我們目前介紹的所有屬性你都不用熟記，等有需要的時候再查找就好。而明天要繼續介紹的就是圖表中最重要的「數據列」了。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/KKzQmRZ&quot;&gt;https://codepen.io/max-lee/pen/KKzQmRZ&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;避免文章篇幅</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 座標軸設定 - 外觀樣式</title>
    <link href="https://maxleebk.com/2020/09/22/highchart/highcharts-8/"/>
    <id>https://maxleebk.com/2020/09/22/highchart/highcharts-8/</id>
    <published>2020-09-22T05:15:00.000Z</published>
    <updated>2023-10-23T03:50:24.512Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/abNqLjX">https://codepen.io/max-lee/pen/abNqLjX</a></strong><br>避免文章篇幅過長，沒辦法每個屬性都利用圖片示意，所以記得善用範例來測試不太了解的屬性。</p></blockquote><p>雖然有部分圖表類型（如圓餅圖、文字雲）並不會用到座標軸，但大多數常見的圖表都是需要座標軸來輔助的，座標軸提供的是一個絕對值尺標，讓觀看者可以得到確切的資料數值，而非只是觀察資料間的相對關係。</p><p>由於座標軸的屬性較多，將會以屬性性質的不同分為「外觀樣式」與「座標刻度」兩篇文章來介紹。</p><hr><h2 id="座標軸設定-外觀樣式相關"><a href="#座標軸設定-外觀樣式相關" class="headerlink" title="座標軸設定 - 外觀樣式相關"></a>座標軸設定 - 外觀樣式相關</h2><br/><p>本次系列我們只會提到平面圖表，所以最多只會有Ｘ座標軸和Ｙ座標軸，而座標軸中又由刻度、標籤、隔線等等…元素所組成，在 Highcharts 中你都可以為這些元素做樣式的微調。</p><p><img src="axis.png" alt=""></p><p><strong>特別注意，座標軸的設定其實是傳入陣列，因為圖表是可以有多Ｘ軸或多Ｙ軸的，但如果確定只有單個的話，你可以省略陣列的中括號。</strong></p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  xAxis: [&#123;&#125;], // Ｘ座標軸設定  yAxis: [&#123;&#125;]  // Ｙ座標軸設定&#125;);</code></pre><br/><blockquote><p>以下以 Axis 同時表示 xAxis 及 yAxis</p></blockquote><br/><h4 id="Axis-title"><a href="#Axis-title" class="headerlink" title="# Axis.title"></a># Axis.title</h4><p>座標軸標題與圖表標題的設定非常相像，這邊就不多花篇幅介紹，有興趣可以看看 <strong><a href="https://api.highcharts.com/highcharts/xAxis.title">官方文件</a></strong>。</p><p>需要注意的是Ｘ軸預設是沒有標題的，但Ｙ軸會有一個預設的 <code>&quot;Values&quot;</code> 標題。</p><br/><br/><h4 id="Axis-minorTicks"><a href="#Axis-minorTicks" class="headerlink" title="# Axis.minorTicks"></a># Axis.minorTicks</h4><p><code>型別: Boolean</code> <code>預設: false</code></p><p>你可以決定是否要顯示座標軸中的副刻度及副格線，另外要注意「類別座標軸」是無法開啟此屬性的。</p><p style="font-size:12px; line-height:1.5;">注：類別座標即以「類別」作為座標刻度，在下篇文章中會介紹。</p><br/><br/><h4 id="Axis-tickWidth-Axis-minorTickWidth"><a href="#Axis-tickWidth-Axis-minorTickWidth" class="headerlink" title="# Axis.tickWidth / Axis.minorTickWidth"></a># Axis.tickWidth / Axis.minorTickWidth</h4><p><code>型別: Number</code> <code>預設: 請見表格</code></p><p>這兩個屬性分別是調整主刻度／副刻度的粗細，單位為 <code>px</code>，設為 <code>0</code> 的話則會隱藏。</p><table><thead><tr><th align="center">座標軸</th><th align="center">tickWidth</th><th align="center">minorTickWidth</th></tr></thead><tbody><tr><td align="center">Ｘ軸</td><td align="center">預設值：1</td><td align="center">預設值：0</td></tr><tr><td align="center">Ｙ軸</td><td align="center">預設值：0</td><td align="center">預設值：0</td></tr><tr><td align="center">類別座標軸</td><td align="center">預設值：0</td><td align="center">無</td></tr></tbody></table><br/><br/><h4 id="Axis-tickLength-Axis-minorTickLength"><a href="#Axis-tickLength-Axis-minorTickLength" class="headerlink" title="# Axis.tickLength / Axis.minorTickLength"></a># Axis.tickLength / Axis.minorTickLength</h4><p><code>型別: Number</code> <code>預設: 10 / 2</code></p><p>除了粗細之外，主刻度／副刻度的長度也可以調整，單位為 <code>px</code>，設為 <code>0</code> 的話則會隱藏。</p><br/><br/><h4 id="Axis-tickColor-Axis-minorTickColor"><a href="#Axis-tickColor-Axis-minorTickColor" class="headerlink" title="# Axis.tickColor / Axis.minorTickColor"></a># Axis.tickColor / Axis.minorTickColor</h4><p><code>型別: String</code> <code>預設: &quot;ccd6eb&quot; / &quot;#999999&quot;</code></p><p>顏色的部分也是可以主刻度／副刻度個別調整，先前提過的顏色格式都是適用的。</p><br/><br/><h4 id="Axis-tickPosition-Axis-minorTickPosition"><a href="#Axis-tickPosition-Axis-minorTickPosition" class="headerlink" title="# Axis.tickPosition / Axis.minorTickPosition"></a># Axis.tickPosition / Axis.minorTickPosition</h4><p><code>型別: String</code> <code>預設: &quot;outside&quot;</code></p><p>這兩個屬性是調整主刻度／副刻度要在軸線以內或以外，但並不包括刻度標籤，可接受的值有 <code>outside</code>、<code>inside</code>。</p><p><img src="tickPosition.png" alt=""></p><br/><h4 id="Axis-tickmarkPlacement"><a href="#Axis-tickmarkPlacement" class="headerlink" title="# Axis.tickmarkPlacement"></a># Axis.tickmarkPlacement</h4><p><code>型別: String</code> <code>預設: &quot;between&quot;</code></p><p>這個屬性是專屬於「類別座標軸」的，與「線性座標軸」不同的是，它的刻度標籤並不會與主刻度對齊，而是夾在兩個刻度之間，因此你可以透過這個屬性來調整，可接受的值有 <code>between</code>、<code>on</code>。</p><p><img src="tickmarkPlacement.png" alt=""></p><br/><h4 id="Axis-lineWidth-Axis-gridLineWidth-Axis-minorGridLineWidth"><a href="#Axis-lineWidth-Axis-gridLineWidth-Axis-minorGridLineWidth" class="headerlink" title="# Axis.lineWidth / Axis.gridLineWidth / Axis.minorGridLineWidth"></a># Axis.lineWidth / Axis.gridLineWidth / Axis.minorGridLineWidth</h4><p><code>型別: Number</code> <code>預設: 請見表格</code></p><p>這三屬性分別是調整軸線／主格線／副格線的粗細，單位為 <code>px</code>，設為 <code>0</code> 的話則會隱藏。</p><table><thead><tr><th align="center">座標軸</th><th align="center">lineWidth</th><th align="center">gridLineWidth</th><th align="center">minorGridLineWidth</th></tr></thead><tbody><tr><td align="center">Ｘ軸</td><td align="center">預設值：1</td><td align="center">預設值：0</td><td align="center">預設值：0</td></tr><tr><td align="center">Ｙ軸</td><td align="center">預設值：0</td><td align="center">預設值：1</td><td align="center">預設值：0</td></tr></tbody></table><br/><br/><h4 id="Axis-lineColor-Axis-gridLineColor-Axis-minorGridLineColor"><a href="#Axis-lineColor-Axis-gridLineColor-Axis-minorGridLineColor" class="headerlink" title="# Axis.lineColor / Axis.gridLineColor / Axis.minorGridLineColor"></a># Axis.lineColor / Axis.gridLineColor / Axis.minorGridLineColor</h4><p><code>型別: String</code> <code>預設: &quot;ccd6eb&quot; / &quot;#e6e6e6&quot; / &quot;#f2f2f2&quot;</code></p><p>軸線／主格線／副格線的線條顏色也可以透過這三個屬性做個別設定，先前提過的顏色格式都是適用的。</p><br/><br/><h4 id="Axis-gridLineDashStyle-Axis-minorGridLineDashStyle"><a href="#Axis-gridLineDashStyle-Axis-minorGridLineDashStyle" class="headerlink" title="# Axis.gridLineDashStyle / Axis.minorGridLineDashStyle"></a># Axis.gridLineDashStyle / Axis.minorGridLineDashStyle</h4><p><code>型別: String</code> <code>預設: &quot;Solid&quot;</code></p><p>主格線和副格線的線條樣式是能夠調整的，除了實線外，有各種類的虛線可以選擇。想看所有類型的話可以看這個<strong><a href="https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-dashstyle-all/">官方範例</a></strong>。</p><hr><h2 id="Axis-labels-刻度標籤"><a href="#Axis-labels-刻度標籤" class="headerlink" title="Axis.labels 刻度標籤"></a>Axis.labels 刻度標籤</h2><br/><p>座標軸的刻度標籤設定也是一包不小的物件，所以我們往裡面深入一個層級來看看刻度標籤中又有哪些屬性。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  xAxis: [&#123;    labels: &#123;&#125; // Ｘ軸刻度標籤設定  &#125;],  yAxis: [&#123;    labels: &#123;&#125; // Ｙ軸刻度標籤設定  &#125;]&#125;);</code></pre><br/><h4 id="xAxis-labels-style"><a href="#xAxis-labels-style" class="headerlink" title="# xAxis.labels.style"></a># xAxis.labels.style</h4><p><code>型別: Object</code> <code>預設: &#123; color: &quot;#666666&quot;, fontSize: &quot;11px&quot; &#125;</code></p><p>樣式屬性在前面已經介紹過蠻多次了，如果需要複習的話可以 <strong><a href="/2020/09/18/highcharts-5/#title-style">按這邊</a></strong>，這裡就不再多做介紹。</p><br/><br/><h4 id="Axis-labels-align"><a href="#Axis-labels-align" class="headerlink" title="# Axis.labels.align"></a># Axis.labels.align</h4><p><code>型別: String</code> <code>預設: 見清單</code></p><p>這次跟前面的「水平位置」就不一樣了，這次代表的就真的是「文字對齊」了，一樣有 <code>left</code>、<code>center</code>、<code>right</code>可以設定。</p><ul><li>Ｘ座標軸預設值：<code>center</code></li><li>Ｙ座標軸預設值：<code>right</code></li></ul><br/><br/><h4 id="Axis-labels-reserveSpace"><a href="#Axis-labels-reserveSpace" class="headerlink" title="# Axis.labels.reserveSpace"></a># Axis.labels.reserveSpace</h4><p><code>型別: Boolean</code> <code>預設: undefined</code></p><p>決定是否要為刻度標籤保留空間，一般來說它會是啟動的，但下面兩個狀況會取消，所以記得要特別設定，不然標籤會跟標題擠在一起或超出畫布。</p><ol><li><code>labels.align</code> 設定為 <code>right</code> 的右側Ｙ軸。</li><li><code>labels.align</code> 設定為 <code>left</code> 的左側Ｙ軸。</li></ol><br/><br/><h4 id="Axis-labels-x-Axis-labels-y"><a href="#Axis-labels-x-Axis-labels-y" class="headerlink" title="# Axis.labels.x / Axis.labels.y"></a># Axis.labels.x / Axis.labels.y</h4><p><code>型別: Number</code> <code>預設: 見清單</code></p><p>調整刻度標籤的偏移量，用法在之前都有介紹過，單位為<code>px</code>。</p><ul><li>Ｘ座標軸預設值：<code>x: 0</code> <code>y: 0</code></li><li>Ｙ座標軸預設值：<code>x: -8</code> <code>y: 3</code></li></ul><br/><br/><h4 id="Axis-labels-rotation"><a href="#Axis-labels-rotation" class="headerlink" title="# Axis.labels.rotation"></a># Axis.labels.rotation</h4><p><code>型別: Number</code> <code>預設: 0</code></p><p>你可以設定刻度標籤的旋轉角度，這在刻度較多或圖表較窄的時候非常實用。</p><br/><br/><h4 id="Axis-labels-autoRotation"><a href="#Axis-labels-autoRotation" class="headerlink" title="# Axis.labels.autoRotation"></a># Axis.labels.autoRotation</h4><p><code>型別: Array[Number]</code> <code>預設: [-45]</code></p><p>如果你希望標籤的旋轉角度可以是漸進式的，那你可以提供這個屬性一組度數的陣列，Highcharts 會自動在陣列中找一個最合適的角度來設定，很適合用在「自適應」的區塊。</p><br/><br/><h4 id="Axis-labels-format-Axis-labels-formatter"><a href="#Axis-labels-format-Axis-labels-formatter" class="headerlink" title="# Axis.labels.format / Axis.labels.formatter"></a># Axis.labels.format / Axis.labels.formatter</h4><p>我們前面在圖例和提示框都有看到「格式化屬性」，而座標軸的刻度標籤也能夠自訂文字格式，不過我們一樣等到之後獨立章節再來詳細介紹吧，今天先跳過。</p><hr><h2 id="Axis-plotLines-標註線"><a href="#Axis-plotLines-標註線" class="headerlink" title="Axis.plotLines 標註線"></a>Axis.plotLines 標註線</h2><br/><p>標註線主要是用來特別標註某個特殊的值，例如在業績統計表中標註目標，或收支圖中標註預算等等，文章中我們只介紹重點屬性，其餘請見 <strong><a href="https://api.highcharts.com/highcharts/xAxis.plotLines">官方文件</a></strong>。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  xAxis: [&#123;    plotLines: [&#123;&#125;] // Ｘ軸標註線設定  &#125;],  yAxis: [&#123;    plotLines: [&#123;&#125;] // Ｙ軸標註線設定  &#125;]&#125;);</code></pre><br/><h4 id="Axis-plotLines-value"><a href="#Axis-plotLines-value" class="headerlink" title="# Axis.plotLines.value"></a># Axis.plotLines.value</h4><p><code>型別: Number</code> <code>預設: undefined</code></p><p>標註線中最重要的屬性，也就是你要標示在哪個數值刻度上。</p><br/><br/><h4 id="Axis-plotLines-color"><a href="#Axis-plotLines-color" class="headerlink" title="# Axis.plotLines.color"></a># Axis.plotLines.color</h4><p><code>型別: String</code> <code>預設: &quot;#999999</code></p><p>標註線的線條顏色，前面提過的顏色格式都適用。</p><br/><br/><h4 id="Axis-plotLines-width"><a href="#Axis-plotLines-width" class="headerlink" title="# Axis.plotLines.width"></a># Axis.plotLines.width</h4><p><code>型別: Number</code> <code>預設: &quot;2</code></p><p>標註線的粗細，單位為 <code>px</code>，設為 <code>0</code> 則會消失。</p><hr><h2 id="Axis-plotBands-標註帶"><a href="#Axis-plotBands-標註帶" class="headerlink" title="Axis.plotBands 標註帶"></a>Axis.plotBands 標註帶</h2><br/><p>標註帶用途與標註線相，不過由單一數據變為數據區間，例如可以在有時間座標的圖表中標註某段特殊時間，文章中我們只介紹重點屬性，其餘請見 <strong><a href="https://api.highcharts.com/highcharts/xAxis.plotBands">官方文件</a></strong>。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  xAxis: [&#123;    plotBands: [&#123;&#125;] // Ｘ軸標註帶設定  &#125;],  yAxis: [&#123;    plotBands: [&#123;&#125;] // Ｙ軸標註帶設定  &#125;]&#125;);</code></pre><br/><h4 id="Axis-plotLines-from-Axis-plotLines-to"><a href="#Axis-plotLines-from-Axis-plotLines-to" class="headerlink" title="# Axis.plotLines.from / # Axis.plotLines.to"></a># Axis.plotLines.from / # Axis.plotLines.to</h4><p><code>型別: Number</code> <code>預設: undefined</code></p><p>標註帶中最重要的兩個屬性，用來設定數值範圍的起點與終點，兩點間距將產生標註帶。</p><br/><br/><h4 id="Axis-plotLines-color-1"><a href="#Axis-plotLines-color-1" class="headerlink" title="# Axis.plotLines.color"></a># Axis.plotLines.color</h4><p><code>型別: String</code> <code>預設: &quot;#e6ebf5</code></p><p>標註帶的區塊顏色，前面提過的顏色格式都適用。</p><p><br/><br/></p><p>那今天就把座標軸中與外觀相關的設定介紹完了，但希望大家還沒有感到疲乏，因為明天還有另一半與「座標刻度」有關的設定在等著我們，撐住啊！！</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10241866">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/abNqLjX&quot;&gt;https://codepen.io/max-lee/pen/abNqLjX&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;避免文章篇幅</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 提示框設定</title>
    <link href="https://maxleebk.com/2020/09/21/highchart/highcharts-7/"/>
    <id>https://maxleebk.com/2020/09/21/highchart/highcharts-7/</id>
    <published>2020-09-21T01:39:00.000Z</published>
    <updated>2023-10-23T03:50:24.512Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/gOroOjd">https://codepen.io/max-lee/pen/gOroOjd</a></strong><br>避免文章篇幅過長，沒辦法每個屬性都利用圖片示意，所以記得善用範例來測試不太了解的屬性。</p></blockquote><p>提示框這個圖表元素算是網頁式圖表特有的，畢竟紙本或 PowerPoint 裡的圖表應該是無法透過使用者介面進行互動的，而提示框功能在於顯示別數據點（point）的詳細資料，可以讓使用者在閱讀圖表時更直覺方便。</p><hr><h2 id="提示框設定"><a href="#提示框設定" class="headerlink" title="提示框設定"></a>提示框設定</h2><br/><p>提示框會在使用者對某個折線圖上的點或柱狀圖上的矩形（也就是數據點）進行 <code>hover</code> 互動時會出現，而其內容會顯示該數據點所屬數據列的名稱、X軸刻度標籤以及數值。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  tooltip: &#123;&#125; // 提示框設定&#125;);</code></pre><br/><h4 id="tooltip-enabled"><a href="#tooltip-enabled" class="headerlink" title="# tooltip.enabled"></a># tooltip.enabled</h4><p><code>型別: Boolean</code> <code>預設: true</code></p><p>你可以利用這個屬性將提示框功能開啟/關閉。</p><br/><br/><h4 id="tooltip-backgroundColor"><a href="#tooltip-backgroundColor" class="headerlink" title="# tooltip.backgroundColor"></a># tooltip.backgroundColor</h4><p><code>型別: String|Object|Null</code> <code>預設: undefined</code></p><p>背景色的設定方式與 <code>chart.backgroundColor</code> 一樣，可以按 <strong><a href="/2020/09/17/highcharts-4/#chart-backgroundColor-chart-plotBackgroundColor">這裡</a></strong> 複習。</p><br/><br/><h4 id="tooltip-border系列"><a href="#tooltip-border系列" class="headerlink" title="# tooltip.border系列"></a># tooltip.border系列</h4><p>因為 <code>border</code> 的相關設定在 <strong><a href="/2020/09/17/highcharts-4/#chart-borderWidth-chart-plotBorderWidth">圖表整體設定</a></strong> 提過了，所以這邊就只放預設值給大家參考。</p><pre><code class="javascript">legend: &#123;  borderWidth: 1,         // Number  borderRadius: 3,        // Number  borderColor: undefined  // String&#125;</code></pre><br/><br/><h4 id="tooltip-style"><a href="#tooltip-style" class="headerlink" title="# tooltip.style"></a># tooltip.style</h4><p><code>型別: Object</code> <code>預設: 如下顯示</code></p><p>樣式屬性在前面已經介紹過蠻多次了，如果需要複習的話可以 <strong><a href="/2020/09/18/highcharts-5/#title-style">按這邊</a></strong>，這裡就不再多做介紹。</p><pre><code class="javascript">tooltip: &#123;  style: &#123;    color: &quot;#333333&quot;,    cursor: &quot;default&quot;,    fontSize: &quot;12px&quot;,    whiteSpace: &quot;nowrap&quot;  &#125;&#125;</code></pre><br/><br/><h4 id="tooltip-padding"><a href="#tooltip-padding" class="headerlink" title="# tooltip.padding"></a># tooltip.padding</h4><p><code>型別: Number</code> <code>預設: 8</code></p><p>用來調整提示框的內間距，預設有 <code>8px</code> 的距離。</p><br/><br/><h4 id="tooltip-distance"><a href="#tooltip-distance" class="headerlink" title="# tooltip.distance"></a># tooltip.distance</h4><p><code>型別: Number</code> <code>預設: 8</code></p><p>用來調整提示框與數據點之間的距離，官網是寫預設為 <code>16px</code> 但我測試起來應該是 <code>8px</code>，剛好是提示框小箭頭的高度，另外如果你設為 <code>0</code> 的話，小箭頭會自動隱藏。</p><br/><br/><h4 id="tooltip-followPointer"><a href="#tooltip-followPointer" class="headerlink" title="# tooltip.followPointer"></a># tooltip.followPointer</h4><p><code>型別: Boolean</code> <code>預設: false</code></p><p>這兩個屬性與互動行為有關，指的是提示框是否要跟著<strong>鼠標</strong>一起移動，如果開啟的話， <code>tooltip.distance</code> 會變成是提示框與鼠標之間的距離。</p><p><span class="emoji" alias="exclamation" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">&#x2757;</span> <strong>提醒：</strong>在某些圖表類型中（如圓餅圖）這個屬性會預設是開啟。</p><br/><br/><h4 id="tooltip-outside"><a href="#tooltip-outside" class="headerlink" title="# tooltip.outside"></a># tooltip.outside</h4><p><code>型別: Boolean</code> <code>預設: undefined</code></p><p>用來決定提示框是否可以超出整個圖表的外框範圍，這個屬性的使用情境比較少，一般是用在圖表較小的時候。</p><br/><br/><h4 id="tooltip-hideDelay"><a href="#tooltip-hideDelay" class="headerlink" title="# tooltip.hideDelay"></a># tooltip.hideDelay</h4><p><code>型別: Number</code> <code>預設: 500</code></p><p>當數據點離開 <code>hover</code> 狀態時，提示框在延遲一段時間後才會消失，而這個屬性可以調整這段時間，單位是毫秒。</p><br/><br/><h4 id="tooltip-shared"><a href="#tooltip-shared" class="headerlink" title="# tooltip.shared"></a># tooltip.shared</h4><p><code>型別: Boolean</code> <code>預設: false</code></p><p>這個屬性可以調整當使用者 <code>hover</code> 數據點時，提示框的資訊要顯示<strong>該數據點</strong>還是<strong>所有數據列中的數據點</strong>資料。</p><p><img src="shared.png" alt=""></p><br/><h4 id="tooltip-format系列"><a href="#tooltip-format系列" class="headerlink" title="# tooltip.format系列"></a># tooltip.format系列</h4><p>昨天在「圖例設定」中有看到所謂的「格式化屬性」，而提示框也是有的，而且數量還不少，<code>headerFormat</code> <code>pointFormat</code> <code>footerFormat</code>…等，不過使用方法都大同小異，所以就等之後的獨立章節再來統一介紹吧，現在暫時先跳過。</p><br/><br/><h4 id="tooltip-valuePrefix-tooltip-valueSuffix"><a href="#tooltip-valuePrefix-tooltip-valueSuffix" class="headerlink" title="# tooltip.valuePrefix / tooltip.valueSuffix"></a># tooltip.valuePrefix / tooltip.valueSuffix</h4><p><code>型別: String</code> <code>預設: undefined</code></p><p>這兩個屬性和格式化屬性做的事情非常相似，不過使用方式單純很多，單純就是在數據點的數值加上前/後綴詞，非常適合用來增加單位或符號，例如我們在範例中這樣設定就可以改變提示框的文案。</p><pre><code class="javascript">tooltip: &#123; valuePrefix: &quot;共&quot;, valueSuffix: &quot;人&quot; &#125;</code></pre><img src="prefix.png" style="max-width: 550px; margin: 24px auto 0;" /><br/><h4 id="tooltip-valueDecimals"><a href="#tooltip-valueDecimals" class="headerlink" title="# tooltip.valueDecimals"></a># tooltip.valueDecimals</h4><p><code>型別: Number</code> <code>預設: undefined</code></p><p>這個屬性跟上面兩個屬性相關，它控制的是數據點的數值要顯示小數點後幾位。</p><p><br/><br/></p><p>提示框的屬性就介紹到這邊了，不過你可以等之後把「格式化屬性」補齊了再重新回來看一次這個章節，因爲它其實才是提示框的精華。那明天的話會繼續介紹「座標軸」的設定。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10241091">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/gOroOjd&quot;&gt;https://codepen.io/max-lee/pen/gOroOjd&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;避免文章篇幅</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 圖例設定</title>
    <link href="https://maxleebk.com/2020/09/20/highchart/highcharts-6/"/>
    <id>https://maxleebk.com/2020/09/20/highchart/highcharts-6/</id>
    <published>2020-09-20T02:26:00.000Z</published>
    <updated>2023-10-23T03:50:24.508Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/gOroOjd">https://codepen.io/max-lee/pen/gOroOjd</a></strong><br>避免文章篇幅過長，沒辦法每個屬性都利用圖片示意，所以記得善用範例來測試不太了解的屬性。</p></blockquote><p>有時候圖表上的數據列（series）未必只有一組，會使得我們必須協助觀看者分辨每一組數據列所代表的身份或資料內容，以我們員工年齡分佈的案例來說，假如人資想要與其他公司的資料進行比較時，那我們的圖表就必須要加上圖例。</p><hr><h2 id="圖例設定"><a href="#圖例設定" class="headerlink" title="圖例設定"></a>圖例設定</h2><br/><p>在有兩組以上數據例的圖表中，會利用不同的顏色或符號來區分不同的數據列，而圖例的功能就是負責說明各個顏色或符號代表的是哪一組數據列。</p><p>另外 Highcharts 的圖例有一些基本的特性：</p><ul><li><strong>圖例的順序與你設定的數據列在陣列裡的索引值有關</strong></li><li><strong>圖例是可以點擊的，用途是將對應的數據列進行顯示或隱藏</strong></li></ul><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  legend: &#123;&#125; // 圖例設定&#125;);</code></pre><br/><h4 id="legend-enabled"><a href="#legend-enabled" class="headerlink" title="# legend.enabled"></a># legend.enabled</h4><p><code>型別: Boolean</code> <code>預設: undefined</code></p><p>你可以利用這個屬性將圖例顯示/隱藏，另外要特別注意，假如你已經將 <code>enabled</code> 設為 <code>true</code> 卻沒顯示圖例，這是因為 <code>series.showInLegend</code> 這個屬性在某些圖表類型（例如圓餅圖）中預設是 <code>false</code>，必須要同時把這個屬性打開，圖例才會出現。</p><br/><br/><h4 id="legend-align"><a href="#legend-align" class="headerlink" title="# legend.align"></a># legend.align</h4><p><code>型別: String</code> <code>預設: &quot;center&quot;</code></p><p>決定圖例在圖表中的水平位置，可以輸入 <code>left</code>、<code>center</code>、<code>right</code>。</p><br/><br/><h4 id="legend-verticalAlign"><a href="#legend-verticalAlign" class="headerlink" title="# legend.verticalAlign"></a># legend.verticalAlign</h4><p><code>型別: String</code> <code>預設: &quot;bottom&quot;</code></p><p>決定圖例在圖表中的垂直位置，可以輸入 <code>top</code>、<code>middle</code>、<code>bottom</code>。</p><br/><br/><h4 id="legend-layout"><a href="#legend-layout" class="headerlink" title="# legend.layout"></a># legend.layout</h4><p><code>型別: String</code> <code>預設: &quot;horizontal&quot;</code></p><p>前兩個屬性，相信大家已經很熟了，但圖例多了一個 <code>layout</code> 屬性來和它們搭配，是用來調整圖例的水平或垂直排列的，如此一來圖例就可以有很多呈現的方式。</p><p>可以設定的值有 <code>&quot;horizontal&quot;</code> 和 <code>&quot;vertical&quot;</code>。</p><p><img src="layout.png" alt=""></p><br/><h4 id="legend-floating"><a href="#legend-floating" class="headerlink" title="# legend.floating"></a># legend.floating</h4><p><code>型別: Boolean</code> <code>預設: false</code></p><p>這也是昨天在標題就提過的屬性，可以讓圖例浮動在圖表之上。</p><br/><br/><h4 id="legend-x-legend-y"><a href="#legend-x-legend-y" class="headerlink" title="# legend.x / legend.y"></a># legend.x / legend.y</h4><p><code>型別: Number</code> <code>預設: 0</code></p><p>一樣的，圖例也有 <code>x</code> 和 <code>y</code> 的屬性讓你調整元素的偏移位置。</p><br/><br/><h4 id="legend-backgroundColor"><a href="#legend-backgroundColor" class="headerlink" title="# legend.backgroundColor"></a># legend.backgroundColor</h4><p><code>型別: String|Object</code> <code>預設: undefined</code></p><p>背景色的設定方式與 <code>chart.backgroundColor</code> 一樣，可以按 <strong><a href="/2020/09/17/highcharts-4/#chart-backgroundColor-chart-plotBackgroundColor">這裡</a></strong> 複習。</p><br/><br/><h4 id="legend-border系列"><a href="#legend-border系列" class="headerlink" title="# legend.border系列"></a># legend.border系列</h4><p>因為 <code>border</code> 的相關設定在 <strong><a href="/2020/09/17/highcharts-4/#chart-borderWidth-chart-plotBorderWidth">圖表整體設定</a></strong> 提過了，所以這邊就只放預設值給大家參考。</p><pre><code class="javascript">legend: &#123;  borderWidth: 0,         // Number  borderRadius: 0,        // Number  borderColor: &quot;#999999&quot;  // String&#125;</code></pre><br/><br/><h4 id="legend-margin"><a href="#legend-margin" class="headerlink" title="# legend.margin"></a># legend.margin</h4><p><code>型別: Number</code> <code>預設: 12</code></p><p>若圖例的垂直位置靠下，那圖例的 <code>margin</code> 是調整圖例與 <strong>座標軸</strong> 的間距，垂直對齊靠上則是與 <strong>繪圖區</strong> 的間距。</p><br/><br/><h4 id="legend-padding"><a href="#legend-padding" class="headerlink" title="# legend.padding"></a># legend.padding</h4><p><code>型別: Number</code> <code>預設: 8</code></p><p>所有圖例會全部包在一個容器裡，你可以調整容器的內間距，這個屬性在有設定背景色或邊框時會比較看得出來。</p><br/><br/><h4 id="legend-itemDistance"><a href="#legend-itemDistance" class="headerlink" title="# legend.itemDistance"></a># legend.itemDistance</h4><p><code>型別: Number</code> <code>預設: 8</code></p><p>這個屬性只有在 <code>legend.layout</code> 是水平配置的情況下才會有效，調整的是個別圖例之間的水平間距。</p><br/><br/><h4 id="legend-itemMarginTop-legend-itemMarginBottom"><a href="#legend-itemMarginTop-legend-itemMarginBottom" class="headerlink" title="# legend.itemMarginTop / legend.itemMarginBottom"></a># legend.itemMarginTop / legend.itemMarginBottom</h4><p><code>型別: Number</code> <code>預設: 0</code></p><p>這兩個屬性剛好相對於 <code>itemDistance</code>，它們調整的是個別圖例之間的垂直間距，不過不管是水平配置或垂直配置下都可以使用。</p><p>為了讓大家更好理解，我做了下面這張圖來標出這些跟間距有關的屬性所調整的區塊。</p><p><img src="gutter.png" alt=""></p><br/><h4 id="legend-itemStyle-legend-itemHoverStyle-legend-itemHiddenStyle"><a href="#legend-itemStyle-legend-itemHoverStyle-legend-itemHiddenStyle" class="headerlink" title="# legend.itemStyle / legend.itemHoverStyle / legend.itemHiddenStyle"></a># legend.itemStyle / legend.itemHoverStyle / legend.itemHiddenStyle</h4><p><code>型別: Object</code> <code>預設: 如下顯示</code></p><pre><code class="javascript">legend: &#123;  itemStyle: &#123;    color: &quot;#333333&quot;,    cursor: &quot;pointer&quot;,    fontSize: &quot;12px&quot;,    fontWeight: &quot;bold&quot;,    textOverflow: &quot;ellipsis&quot;  &#125;,  itemHoverStyle: &#123;    color: &quot;#000000&quot;  &#125;,  itemHiddenStyle: &#123;    color: &quot;#cccccc&quot;  &#125;&#125;</code></pre><p>圖例本身有 <code>normal</code>、<code>hover</code>、<code>hidden</code> 三種狀態，而這三種狀態下的樣式你都可以作調整，剛好對應的就是這三個屬性，用法和之前介紹的樣式屬性都一樣，如果需要複習的話可以 <strong><a href="/2020/09/18/highcharts-5//#title-style">按這邊</a></strong>。</p><br/><br/><h4 id="legend-symbolWidth-legend-symbolHeight"><a href="#legend-symbolWidth-legend-symbolHeight" class="headerlink" title="# legend.symbolWidth / legend.symbolHeight"></a># legend.symbolWidth / legend.symbolHeight</h4><p><code>型別: Number</code> <code>預設: undefined</code></p><p>你可以透過這兩個屬性調整圖例符號（symbol）的寬高，在沒有設定時會自動去抓 <code>itemStyle.fontSize</code> 的大小。</p><br/><br/><h4 id="legend-squareSymbol"><a href="#legend-squareSymbol" class="headerlink" title="# legend.squareSymbol"></a># legend.squareSymbol</h4><p><code>型別: Boolean</code> <code>預設: true</code></p><p>這個屬性會大大影響圖例符號的寬高設定，它會決定是否要讓符號維持寬高相等，所以如果你需要長方形/橢圓形的符號，記得關閉這個設定。</p><br/><br/><h4 id="legend-symbolRadius"><a href="#legend-symbolRadius" class="headerlink" title="# legend.symbolRadius"></a># legend.symbolRadius</h4><p><code>型別: Number</code> <code>預設: undefined</code></p><p>這個屬性決定了圖例符號的倒圓角，不設定的話會自動計算為 <code>symbolHeight</code> 的一半，這也是為什麼預設會是圓形的原因。</p><br/><br/><h4 id="legend-symbolPadding"><a href="#legend-symbolPadding" class="headerlink" title="# legend.symbolPadding"></a># legend.symbolPadding</h4><p><code>型別: Number</code> <code>預設: 5</code></p><p>圖例符號與圖例文字之間的間距可以透過這個屬性調整，預設有 <code>5px</code> 的距離。</p><br/><br/><h4 id="legend-labelFormat-legend-labelFormatter"><a href="#legend-labelFormat-legend-labelFormatter" class="headerlink" title="# legend.labelFormat / legend.labelFormatter"></a># legend.labelFormat / legend.labelFormatter</h4><p>這兩個屬性在「圖例設定」中算是比較重要也比較實用的，它們可以用來調整圖例標籤的「文字格式」，不過它們的使用方式比較複雜度，所以之後會用獨立的章節來特別介紹「格式化屬性」，今天我們就暫時先跳過。</p><p><br/><br/></p><p>經過三天的設定介紹，目前累積屬性也不少，但其實可以發現同樣概念的屬性不斷在重複，所以應該大家應還消化得了吧？那圖例設定的部分就到這裡，而明天要介紹的圖表元素是「提示框」。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10240463">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/gOroOjd&quot;&gt;https://codepen.io/max-lee/pen/gOroOjd&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;避免文章篇幅</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 說明文字設定</title>
    <link href="https://maxleebk.com/2020/09/19/highchart/highcharts-5/"/>
    <id>https://maxleebk.com/2020/09/19/highchart/highcharts-5/</id>
    <published>2020-09-19T03:00:00.000Z</published>
    <updated>2023-10-23T03:50:24.508Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/BaKwdyN">https://codepen.io/max-lee/pen/BaKwdyN</a></strong><br>避免文章篇幅過長，沒辦法每個屬性都利用圖片示意，所以記得善用範例來測試不太了解的屬性。</p></blockquote><p>雖然大家可能都會把圖表的重點放在「圖」上，但有時候文字可以讓觀看者更快速抓的到圖表主題或是引導觀看者發覺背後含義，而今天要介紹的就是這些文字性的圖表元素。</p><hr><h2 id="主標題設定"><a href="#主標題設定" class="headerlink" title="主標題設定"></a>主標題設定</h2><br/><p>主標題可以點出圖表所呈現的資料主題，甚至有些圖表如果沒有標題，你都未必知道它在呈現什麼資料，所以主標題算是圖表中非常重要的說明文字。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  title: &#123;&#125; // 主標題設定&#125;);</code></pre><br/><h4 id="title-text"><a href="#title-text" class="headerlink" title="# title.text"></a># title.text</h4><p><code>型別: String|null</code> <code>預設: &quot;Chart title&quot;</code></p><p>標題內容是由 <code>text</code> 屬性做設定的，要注意的是，就算沒有設定還是會有 <code>Chart title</code> 這樣的預設文字，所以要是不想用 Highcharts 提供的標題，記得把它設為 <code>null</code>。</p><p><span class="emoji" alias="exclamation" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">&#x2757;</span> <strong>提醒：</strong>在字串裡是可以加上 <code>&lt;a&gt;</code>、<code>&lt;span&gt;</code>、<code>&lt;em&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;br/&gt;</code> 等..行內標籤的。</p><br/><br/><h4 id="title-style"><a href="#title-style" class="headerlink" title="# title.style"></a># title.style</h4><p><code>型別: Object</code> <code>預設: &#123; &quot;color&quot;: &quot;#333333&quot;, &quot;fontSize&quot;: &quot;18px&quot; &#125;</code></p><p>標題的樣式可以透過這個屬性來調整，設定方式其實跟 CSS 差不多，只不過是物件的形式，並且樣式的屬性名稱要用小駝峰的方式撰寫，再者是並非所有的 CSS 屬性都支援，下面我就示意幾個比較常見的。</p><p>如果要知道所有屬性的話可以到 <strong><a href="https://api.highcharts.com/class-reference/Highcharts.CSSObject">https://api.highcharts.com/class-reference/Highcharts.CSSObject</a></strong></p><pre><code class="javascript">title: &#123;  style: &#123;    fontSize: &quot;20px&quot;,    fontWeight: &quot;bold&quot;,    textAlign: &quot;right&quot;,    color: &quot;#292929&quot;,    padding: &quot;8px&quot;  &#125;&#125;</code></pre><br/><br/><h4 id="title-useHTML"><a href="#title-useHTML" class="headerlink" title="# title.useHTML"></a># title.useHTML</h4><p><code>型別: Boolean</code> <code>預設: false</code></p><p>這個屬性比較特殊，由於 Highcharts 是採用 SVG 進行圖表繪製，標題這種文字元素會用 SVG 的 <code>text</code> 標籤去包裹，所以你在 <code>title.text</code> 撰寫的行內標籤以及 <code>title.style</code> 的設定最後都是以 SVG 呈現的。</p><p>這本身並沒有什麼問題，但有時候 SVG 的呈現效果未必是你要的，所以如果你希望 Highcharts 幫你把標題部分換成你熟悉的 HTML 標籤的話，你可以開啟這個選項。</p><p><img src="useHTML.png" alt=""></p><br/><h4 id="title-align"><a href="#title-align" class="headerlink" title="# title.align"></a># title.align</h4><p><code>型別: String</code> <code>預設: &quot;center&quot;</code></p><p>此屬性可以調整標題的水平位置，合法的值有 <code>left</code>、<code>center</code>、<code>right</code>，預設則是置中。</p><p><span class="emoji" alias="exclamation" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">&#x2757;</span> <strong>提醒：</strong><code>align</code> 調整的是「在圖表上的位置」，與 <code>style.textAlign</code> 是不同的。</p><br/><br/><h4 id="title-verticalAlign"><a href="#title-verticalAlign" class="headerlink" title="# title.verticalAlign"></a># title.verticalAlign</h4><p><code>型別: String</code> <code>預設: undefined</code></p><p>與 <code>align</code> 相對的是 <code>verticalAlign</code>，你可以用 <code>top</code>、<code>middle</code>、<code>bottom</code> 決定標題的垂直位置。</p><br/><br/><h4 id="title-floating"><a href="#title-floating" class="headerlink" title="# title.floating"></a># title.floating</h4><p><code>型別: Boolean</code> <code>預設: false</code></p><p>這個屬性會讓標題文字浮動在圖表之上，當你開啟這個設定時，<code>chart.margin</code> 的預設值會自動忽略標題，這會使標題蓋在圖表上。</p><p>同時你依然可以用 <code>align</code> 或 <code>verticalAlign</code> 調整位置，雖然很有可能會跟其他圖表元素重疊就是了。</p><p><img src="float.png" alt=""></p><br/><h4 id="title-x-title-y"><a href="#title-x-title-y" class="headerlink" title="# title.x / title.y"></a># title.x / title.y</h4><p><code>型別: Number</code> <code>預設: 0</code></p><p>如果前面的 <code>floating</code> 效果不如預期，讓你覺得很雞肋的話，那是因為我們還沒提到 <code>x</code> 和 <code>y</code>，這兩個屬性可以讓你微調標題的水平與垂直偏移，這樣你就可以隨心所欲的調整標題位置了。</p><p><span class="emoji" alias="exclamation" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">&#x2757;</span> <strong>提醒：</strong><code>x</code> 和 <code>y</code> 不一定要跟 <code>floating</code> 一起使用。</p><br/><br/><h4 id="title-margin"><a href="#title-margin" class="headerlink" title="# title.margin"></a># title.margin</h4><p><code>型別: Number</code> <code>預設: 15</code></p><p>這個屬性可以調整標題與繪圖區 (plot) 的間距，如果圖表有副標題的話則是標題與副標題的間距，有趣的是它只有在 <code>verticalAlign</code> 是 <code>top</code> 的時候才有效。</p><hr><h2 id="副標題設定"><a href="#副標題設定" class="headerlink" title="副標題設定"></a>副標題設定</h2><br/><p>副標題可以用來補充說明主標題的主旨，預設是沒有副標題的，而它的屬性幾乎跟主標題一樣，只有以下設定只有預設值不同而已。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  subtitle: &#123;&#125; // 副標題設定&#125;);</code></pre><br/><h4 id="subtitle-style"><a href="#subtitle-style" class="headerlink" title="# subtitle.style"></a># subtitle.style</h4><p><code>型別: Object</code> <code>預設: &#123; &quot;color&quot;: &quot;#666666&quot; &#125;</code></p><br/><br/><h4 id="subtitle-margin"><a href="#subtitle-margin" class="headerlink" title="# subtitle.margin"></a><del># subtitle.margin</del></h4><p>副標題沒有 <code>margin</code> 屬性。</p><hr><h2 id="圖表說明設定"><a href="#圖表說明設定" class="headerlink" title="圖表說明設定"></a>圖表說明設定</h2><br/><p>圖表說明可以詳細說明圖表的內容或是資料來源等等內容，它的屬性也是預設值跟主標題稍微不一樣而已。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  caption: &#123;&#125; // 圖表說明設定&#125;);</code></pre><br/><h4 id="caption-style"><a href="#caption-style" class="headerlink" title="# caption.style"></a># caption.style</h4><p><code>型別: Object</code> <code>預設: &#123; &quot;color&quot;: &quot;#666666&quot; &#125;</code></p><br/><br/><h4 id="caption-align"><a href="#caption-align" class="headerlink" title="# caption.align"></a># caption.align</h4><p><code>型別: String</code> <code>預設: &quot;left&quot;</code></p><br/><br/><h4 id="caption-verticalAlign"><a href="#caption-verticalAlign" class="headerlink" title="# caption.verticalAlign"></a># caption.verticalAlign</h4><p><code>型別: String</code> <code>預設: &quot;bottom&quot;</code></p><hr><h2 id="版權標籤設定"><a href="#版權標籤設定" class="headerlink" title="版權標籤設定"></a>版權標籤設定</h2><br/><p>版權標籤預設是在圖表的右下角，主要用意是要展現 Highcharts 的版權所有，不過因為 Highcharts 是可以非商業免費使用的，所以如果你的網站沒有營利，拿掉是沒有關係的。</p><p>或是有需要的話你也可以利用這個位置來說明圖表的資料來源、呈現自己網站的網址名稱等等。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  credits: &#123;&#125; // 版權標籤設定&#125;);</code></pre><br/><h4 id="credits-enabled"><a href="#credits-enabled" class="headerlink" title="# credits.enabled"></a># credits.enabled</h4><p><code>型別: Boolean</code> <code>預設: true</code></p><p>你可透過這個屬性簡單的開/關版權標籤．預設是打開的。</p><br/><br/><h4 id="credits-text"><a href="#credits-text" class="headerlink" title="# credits.text"></a># credits.text</h4><p><code>型別: String|null</code> <code>預設: &quot;Highcharts.com&quot;</code></p><p>用法與前面的主標題、副標題都一樣，也是支援行內標籤的。</p><br/><br/><h4 id="credits-href"><a href="#credits-href" class="headerlink" title="# credits.href"></a># credits.href</h4><p><code>型別: String|null</code> <code>預設: &quot;https://www.highcharts.com?credits&quot;</code></p><p>這個屬性可以讓版權標籤設定連結，等同一個 <code>&lt;a&gt;</code> 標籤，如果不想要連結就設為 <code>null</code>。</p><br/><br/><h4 id="credits-style"><a href="#credits-style" class="headerlink" title="# credits.style"></a># credits.style</h4><p><code>型別: Object</code> <code>預設: &#123; color: &quot;#999999&quot;, cursor: &quot;pointer&quot;, fontSize: &quot;9px&quot; &#125;</code></p><p>用法與前面都一樣，唯有預設值不同。</p><br/><br/><h4 id="credits-position"><a href="#credits-position" class="headerlink" title="# credits.position"></a># credits.position</h4><p><code>型別: Object</code> <code>預設: 如下顯示</code></p><pre><code class="javascript">credits: &#123;  position: &#123;    align: &quot;right&quot;,    verticalAlign: &quot;bottom&quot;,    x: -10,    y: -5  &#125;&#125;</code></pre><p>其實可以發現 <code>credits.position</code> 只是將前面看過的 <code>align</code>、<code>verticalAlign</code>、<code>x</code>、<code>y</code> 包裝成一個物件而已，而它們分別的用法也都跟前面介紹的一模一樣。</p><br/><img src="textOption.png" style="max-width: 600px; margin: 24px auto;" /><p>那今天的最後就附上一個有標題、說明、版權標籤的 <strong><a href="https://codepen.io/max-lee/pen/NWNwZoZ">案例</a></strong> 來做 Ending，而明天要介紹的圖表元素是「圖例」。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10239473">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/BaKwdyN&quot;&gt;https://codepen.io/max-lee/pen/BaKwdyN&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;避免文章篇幅</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 圖表整體設定</title>
    <link href="https://maxleebk.com/2020/09/18/highchart/highcharts-4/"/>
    <id>https://maxleebk.com/2020/09/18/highchart/highcharts-4/</id>
    <published>2020-09-18T02:05:00.000Z</published>
    <updated>2023-10-23T03:50:24.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章節範例：<strong><a href="https://codepen.io/max-lee/pen/BaKwdyN">https://codepen.io/max-lee/pen/BaKwdyN</a></strong><br>避免文章篇幅過長，沒辦法每個屬性都利用圖片示意，所以記得善用範例來測試不太了解的屬性。</p></blockquote><p>接下來的幾天，將陸續介紹 Highcharts 圖表設定裡五花八門的屬性，所以之後每個章節的開頭我都會準備一個線上範例，建議大家利用範例來玩玩看當天介紹的屬性。</p><p>相信大家都有接觸過線上遊戲，在遊戲開始時總是會創建角色並決定初始樣貌以及職業，而「圖表整體設定」正是為圖表做這些初始設定。</p><hr><h2 id="圖表整體設定"><a href="#圖表整體設定" class="headerlink" title="圖表整體設定"></a>圖表整體設定</h2><br/><p>圖表整體設定主要是一些調整圖表外觀或是整體呈現的屬性，而且這些屬性會大大影響其他區塊的設定內容，像是如果你用 <code>chart.type</code> 屬性把圖表設定為圓餅圖，那之後的座標軸設定你肯定就用不到了，所以它算是整個圖表的基底及前置。</p><pre><code class="javascript">var myChart = Highcharts.chart(container, &#123;  chart: &#123;&#125; // 圖表整體設定&#125;);</code></pre><br/><h4 id="chart-type"><a href="#chart-type" class="headerlink" title="# chart.type"></a># chart.type</h4><p><code>型別: String</code> <code>預設: &quot;line&quot;</code></p><p>這個算是比較重要的屬性，它決定了這張圖表要採用的類型是哪一種，我們的範例中設定的是 <code>column</code> 長條圖，如果沒特別設定的話，則預設會是折線圖。想知道所有圖表類型的話，可以到 <strong><a href="https://api.highcharts.com/highcharts/series">官方文件</a></strong> 查看。</p><br/><br/><h4 id="chart-inverted"><a href="#chart-inverted" class="headerlink" title="# chart.inverted"></a># chart.inverted</h4><p><code>型別: Boolean</code> <code>預設: false</code></p><p>這個屬性比較特別，如果你設為 <code>true</code> 的話，它會將你的座標軸給交換，這會導致圖表的方向性改變，像是用在柱狀圖的話它就會變成橫條圖，或是下面的折線圖改為由上而下繪製。</p><p><img src="inverted.png" alt=""></p><h4 id="chart-width-chart-height"><a href="#chart-width-chart-height" class="headerlink" title="# chart.width / chart.height"></a># chart.width / chart.height</h4><p><code>型別: String|Number|null</code> <code>預設: null</code></p><p>寬高就是非常基本的屬性了，兩者都可以用數字或字串來做設定，並且支援所有 CSS 的長度單位，如果沒特別設定的話會是預設值 <code>null</code>，不過 <code>null</code> 並非為零，而是寬度部分會自動填滿與容器，高度則預設為 <code>400px</code>。</p><br/><br/><h4 id="chart-reflow"><a href="#chart-reflow" class="headerlink" title="# chart.reflow"></a># chart.reflow</h4><p><code>型別: Boolean</code> <code>預設: true</code></p><p>前面提到過，當你沒有為圖表設定寬度時，它會主動填滿容器元素，但若你的容器會根據視窗大小和縮放時，圖表就會跟著一起變寬變窄，而 <code>reflow</code> 可以讓你決定要不要讓圖表一起縮放。</p><br/><br/><h4 id="chart-backgroundColor-chart-plotBackgroundColor"><a href="#chart-backgroundColor-chart-plotBackgroundColor" class="headerlink" title="# chart.backgroundColor / chart.plotBackgroundColor"></a># chart.backgroundColor / chart.plotBackgroundColor</h4><p><code>型別: String|Object|null</code> <code>預設: &quot;#ffffff&quot;</code></p><p>這兩個都是調整背景顏色，可以使用16進制的色碼、顏色名以及 <code>rgba()</code> 的顏色設定，若設為 <code>null</code> 的話則取消背景。那為何背景色要分成兩個設定呢？因為調整的區塊其實不太一樣，一個是設定整個圖表 (chart) 的背景，另一個則是設定繪圖區 (plot) 的背景。</p><p><img src="plot.png" alt=""></p><p>另外也可以設定漸層色，不過寫法稍微複雜，必須用一個物件來設定，其中 <code>linearGradient</code> 屬性是調整漸層方向的，而 <code>stops</code> 則是設定顏色的，說明寫在註解了，你可以試著寫寫看。</p><pre><code class="javascript">chart: &#123;  backgroundColor: &#123;    //x1:0, x2:1 為水平漸層，y1:0, y2:1 為垂直的漸層，以此邏輯便能調整出斜向或反向漸層    linearGradient: &#123; x1: 0, x2: 1, y1: 0, y2: 0 &#125;,     //第一個值為顏色位置(0~1)，第二個值為顏色    stops: [ [0, &#39;pink&#39;], [0.5, &#39;red&#39;], [1, &#39;orange&#39;] ]  &#125;&#125;</code></pre><br/><br/><h4 id="chart-borderWidth-chart-plotBorderWidth"><a href="#chart-borderWidth-chart-plotBorderWidth" class="headerlink" title="# chart.borderWidth / chart.plotBorderWidth"></a># chart.borderWidth / chart.plotBorderWidth</h4><p><code>型別: Number</code> <code>預設: 0</code></p><p>同樣地，圖表與繪圖區的邊框寬度都可以各自設定，如果不設定則沒有邊框。另外也可以用 <code>chart.borderRadius</code> 設定圖表的邊框圓角，繪圖區則沒有圓角設定。</p><br/><br/><h4 id="chart-borderColor-chart-plotBorderColor"><a href="#chart-borderColor-chart-plotBorderColor" class="headerlink" title="# chart.borderColor / chart.plotBorderColor"></a># chart.borderColor / chart.plotBorderColor</h4><p><code>型別: String</code> <code>預設: &quot;#335cad&quot; / &quot;#cccccc&quot;</code></p><p>邊框顏色的設定方式和背景色一樣，要注意的是圖表與繪圖區的邊框色預設值不一樣，圖表是深藍色 <code>#335cad</code>，繪圖區則是淺灰色 <code>#cccccc</code>。</p><br/><br/><h4 id="chart-spacing"><a href="#chart-spacing" class="headerlink" title="# chart.spacing"></a># chart.spacing</h4><p><code>型別: Array[Number]</code> <code>預設: [10, 10, 15, 10]</code></p><p>這個屬性如同圖表的 <code>padding</code>，代表的是圖表 (chart) 內容與邊框之間的內間距，設定方式是四個數字的陣列，順序和 CSS 一樣是上右下左，若你想要個別設定可以用 <code>spacingTop</code>、<code>spacingBottom</code>、<code>spacingRight</code>、<code>spacingLeft</code>，它們會覆蓋掉 <code>spacing</code>。</p><br/><br/><h4 id="chart-margin"><a href="#chart-margin" class="headerlink" title="# chart.margin"></a># chart.margin</h4><p><code>型別: Array[Number]</code> <code>預設: undefined</code></p><p>這是一個容易被混淆的屬性，你可能會以為它與 <code>spacing</code> 相對，不過它調整可不是圖表的外間距，他調整的是<strong>繪圖區 (plot) 與圖表 (chart) 邊框的距離</strong>，我覺得這算是一個蠻大的地雷，如果沒有仔細理解肯定會被搞糊塗。</p><p><img src="margin.png" alt=""></p><p>灰色區域是兩者各自代表的間距，可以發現 <code>margin</code> 的距離其實是包含 <code>spacing</code> 的。另外當你沒有設定 <code>margin</code> 的時候，間距並不為零，而是 Highcharts 會去計算圖表的其他區塊(標題、座標軸等..)，並調整成能夠避開它們的間距。</p><p>當然，<code>margin</code> 也有 <code>marginTop</code>、<code>marginBottom</code>、<code>marginRight</code>、<code>marginLeft</code> 的版本可以使用。</p><p><br/><br/></p><p>那麼以上就是「圖表整體設定」中比較常會使用到的屬性了，明天會介紹的是標題、說明等文字性質的圖表元素。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10239103">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本章節範例：&lt;strong&gt;&lt;a href=&quot;https://codepen.io/max-lee/pen/BaKwdyN&quot;&gt;https://codepen.io/max-lee/pen/BaKwdyN&lt;/a&gt;&lt;/strong&gt;&lt;br&gt;避免文章篇幅</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 圖表的組成</title>
    <link href="https://maxleebk.com/2020/09/17/highchart/highcharts-3/"/>
    <id>https://maxleebk.com/2020/09/17/highchart/highcharts-3/</id>
    <published>2020-09-17T01:24:00.000Z</published>
    <updated>2023-10-23T03:50:24.500Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>圖表的種類非常多，呈現方式各有不同，但幾乎都有幾個固定的元素內容，能夠使圖表的易讀性提昇</p></blockquote><p>昨天我們成功做出了一個 Highcharts 的圖表，今天要重新說明一下我們到底寫了些什麼，另外也要讓大家知道，其實圖表是由很多重要的元素所組成的，它們扮演了重要的角色，使觀看者能更快速的理解圖表。</p><hr><h2 id="前情回顧"><a href="#前情回顧" class="headerlink" title="前情回顧"></a>前情回顧</h2><br/><pre><code class="javascript">const container = document.querySelector(&quot;#container&quot;);const xAxisCate = Object.keys(data);const seriesData = xAxisCate.map(key =&gt; data[key]);var myChart = Highcharts.chart(container, &#123;  chart: &#123; type: &quot;column&quot; &#125;,  title: &#123; text: &quot;公司員工年齡分佈&quot; &#125;,  xAxis: &#123; categories: xAxisCate &#125;,  yAxis: &#123;    title: &#123; text: &quot;人數&quot; &#125;  &#125;,  series: [&#123;    name: &quot;XX公司員工&quot;,    data: seriesData  &#125;]&#125;);</code></pre><p>昨天這段程式碼，大家比較陌生的應該是 <code>Highcharts.chart</code> 這一段，而它其實就是 Highcharts 最主要的初始化函式。</p><pre><code class="javascript">Highcharts.chart(element, options);</code></pre><p>當你要創建一個新的圖表時，就必須使用這個函式，並且傳入兩個參數，第一個是 DOM 元素容器，第二個是圖表設定，在昨天的案例中 DOM 元素很明顯是 <code>#container</code> 這個容器，而圖表設定是這一大包物件。</p><pre><code class="javascript">&#123;  chart: &#123; type: &quot;column&quot; &#125;,  title: &#123; text: &quot;公司員工年齡分佈&quot; &#125;,  xAxis: &#123; categories: xAxisCate &#125;,  yAxis: &#123;    title: &#123; text: &quot;人數&quot; &#125;  &#125;,  series: [&#123;    name: &quot;XX公司員工&quot;,    data: seriesData  &#125;]&#125;</code></pre><p>不過目前我們不會去探究裡面的屬性到底做了些什麼，那是後面幾天會著墨的內容，今天會先用圖表的組成來理解這個 <code>options</code> 物件的結構。</p><hr><h2 id="圖表中的元素"><a href="#圖表中的元素" class="headerlink" title="圖表中的元素"></a>圖表中的元素</h2><p>其實圖表是由許多元素所組合而成的，Highcharts 的圖表也不例外，以昨天的 <a href="https://codepen.io/max-lee/pen/BaKwdyN">範例</a> 來說的話，它包含了以下內容：</p><p><img src="element.png" alt=""></p><p>透過上面的示意圖可以發現，Highcharts 圖表可以粗略的分成這七個主要區塊加上一個整體設定，並且在 <code>options</code> 物件中都有對應的屬性，不過如果圖表不會太複雜，Highcharts 本身都有預設設定，就未必每個區塊都要額外修改，像是我們的範例就沒有去調整圖例和提示框。</p><pre><code class="javascript">&#123;  chart: &#123;&#125;,      // 圖表整體設定  title: &#123;&#125;,      // 標題設定  xAxis: [&#123;&#125;],    // Ｘ座標軸設定  yAxis: [&#123;&#125;],    // Ｙ座標軸設定  legend: &#123;&#125;,     // 圖例設定  tooltip: &#123;&#125;,    // 提示框設定  series: [&#123;&#125;],   // 數據列設定  plotOptions: &#123;&#125; // 繪圖區設定  // ...還有更多更多更多更多&#125;</code></pre><p>另外 Highcharts 其實還有更多特殊的圖表元素可以進行設定，而且許多屬性底下還能再分成更細緻的區塊做調整，使得圖表的設定屬性數量非常可觀，所以後面我會把重點放在比較實用與常見的屬性上，而剩餘的就留給各位慢慢摸索了。</p><br/><p>豐富的圖表設定是 Highcharts 這個圖表庫強大的特點之一，你可以先偷偷到 <a href="https://api.highcharts.com/highcharts/">官方文件</a> 感受一下所謂的數量可觀。</p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10238356">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;圖表的種類非常多，呈現方式各有不同，但幾乎都有幾個固定的元素內容，能夠使圖表的易讀性提昇&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;昨天我們成功做出了一個 Highcharts 的圖表，今天要重新說明一下我們到底寫了些什麼，另外也要讓大家知道，其實</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 圖表的意義</title>
    <link href="https://maxleebk.com/2020/09/16/highchart/highcharts-2/"/>
    <id>https://maxleebk.com/2020/09/16/highchart/highcharts-2/</id>
    <published>2020-09-16T01:25:00.000Z</published>
    <updated>2023-10-23T03:50:24.468Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>資料視覺化是一門藝術也是一門科學，它藉由人類喜愛以視覺理解資訊的特性來增強我們資料處理的效率。</p></blockquote><p>上一篇文章裡已經知道資料視覺化大大影響現在網頁開發的趨勢，而今天就要正式使用 Highcharts 來將資料做成圖表，同時也讓大家了解為何圖表對於資料的理解有非常大的幫助。</p><hr><h2 id="使用情境"><a href="#使用情境" class="headerlink" title="使用情境"></a>使用情境</h2><br/><p>如果把資料比喻成故事，那視覺化就是我們說故事的手法，由此可知「資料」其實才是資料視覺化中的主角，而為了讓我們的資料更有實際意義，我幫大家模擬了一個情境：</p><p><strong><em>假設公司的人資想透過員工資料來統計公司內部的年齡分佈，他經過一連串的計算後給了你下面的表格，並請你幫他生成柱狀圖表，你會怎麼做？</em></strong></p><table><thead><tr><th align="center">18-24 歲</th><th align="center">25-29 歲</th><th align="center">30-34 歲</th><th align="center">35-39 歲</th></tr></thead><tbody><tr><td align="center">12 人</td><td align="center">18 人</td><td align="center">22 人</td><td align="center">25 人</td></tr></tbody></table><table><thead><tr><th align="center">40-44 歲</th><th align="center">45-49 歲</th><th align="center">50-54 歲</th><th align="center">55 歲+</th></tr></thead><tbody><tr><td align="center">32 人</td><td align="center">35 人</td><td align="center">26 人</td><td align="center">18 人</td></tr></tbody></table><p><del>其實你可以請他自己用 PowerPoint 做</del>，喂～不是啦，我們要幫這位人資利用 Highcharts 來將這些數據繪製成圖表並顯示在網頁上。</p><p>此時，你也可以試想一下要是沒有圖表的話，光看表格你能分析出這份資料的含義嗎？</p><hr><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><br/><p>如果你只是要一個簡單的圖表，沒有特別的設計與互動需求，那其實簡單幾個步驟 Highcharts 就能讓你的資料圖像化。</p><h4 id="1-引入-Highcharts"><a href="#1-引入-Highcharts" class="headerlink" title="1. 引入 Highcharts"></a>1. 引入 Highcharts</h4><p>你可以用 CDN 的方式將 Highcharts 的 js 檔引入，或是到 <a href="https://www.highcharts.com/blog/download/">官網</a> 下載放進專案裡。</p><pre><code class="html">&lt;script src=&quot;http://cdn.highcharts.com.cn/highcharts/highcharts.js&quot;&gt;&lt;/script&gt;</code></pre><br/><h4 id="2-新增圖表容器"><a href="#2-新增圖表容器" class="headerlink" title="2. 新增圖表容器"></a>2. 新增圖表容器</h4><p>然後你需要一個容器來放置你的圖表，你可以給它設定寬度以免圖表佔滿整個畫面。</p><pre><code class="html">&lt;div id=&quot;container&quot; style=&quot;max-width: 600px;&quot;&gt;&lt;/div&gt;</code></pre><br/><h4 id="3-準備好你的資料"><a href="#3-準備好你的資料" class="headerlink" title="3. 準備好你的資料"></a>3. 準備好你的資料</h4><p>根據我們的情境，我們可以先把表格資料先整理成物件：</p><pre><code class="javascript">const data = &#123;  &quot;18-24歲&quot;: 12,  &quot;25-29歲&quot;: 18,  &quot;30-34歲&quot;: 22,  &quot;35-39歲&quot;: 25,  &quot;40-44歲&quot;: 32,  &quot;45-49歲&quot;: 35,  &quot;50-54歲&quot;: 26,  &quot;55歲+&quot;: 18,&#125;;</code></pre><br/><h4 id="4-繪製表格"><a href="#4-繪製表格" class="headerlink" title="4. 繪製表格"></a>4. 繪製表格</h4><p>接下來我們只要根據 Highcharts 制定好的方法將資料帶入並設定，圖表就完成啦！<br>若你對下面的程式碼一知半解的話先不用太在意，我們明天會好好解釋的。</p><pre><code class="javascript">const container = document.querySelector(&quot;#container&quot;);const xAxisCate = Object.keys(data);const seriesData = xAxisCate.map((key) =&gt; data[key]);var myChart = Highcharts.chart(container, &#123;  chart: &#123; type: &quot;column&quot; &#125;,  title: &#123; text: &quot;公司員工年齡分佈&quot; &#125;,  xAxis: &#123; categories: xAxisCate &#125;,  yAxis: &#123;    title: &#123; text: &quot;人數&quot; &#125;,  &#125;,  series: [    &#123;      name: &quot;XX公司員工&quot;,      data: seriesData,    &#125;,  ],&#125;);</code></pre><img src="chart.png" style="max-width: 600px; margin: 24px auto;" /><h2 id="資料視覺化的意義"><a href="#資料視覺化的意義" class="headerlink" title="資料視覺化的意義"></a>資料視覺化的意義</h2><br/><p>這麼一來我們就完成資料視覺化的任務了，而仔細一看會發現這張柱狀圖的圖峰偏右，表示員工的平均年齡偏高，若隨著員工年老退休，公司可能會面臨技術或生產力的下降，所以這位人資應該要想辦法吸引年輕的求職者來公司應徵了。</p><p>想想，若光看數據表格的話你需要花多久時間看出員工年齡的趨勢，並作出上面這段結論呢？而這就是圖表存在的意義，讓我們能夠快速的看出資料背後的資訊。</p><br/><p>今日成果：<strong><a href="https://codepen.io/max-lee/pen/BaKwdyN">https://codepen.io/max-lee/pen/BaKwdyN</a></strong></p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10237584">iT 邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;資料視覺化是一門藝術也是一門科學，它藉由人類喜愛以視覺理解資訊的特性來增強我們資料處理的效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一篇文章裡已經知道資料視覺化大大影響現在網頁開發的趨勢，而今天就要正式使用 Highcharts 來將資料做</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>資視就是力量 - Highcharts / 資料視覺化</title>
    <link href="https://maxleebk.com/2020/09/15/highchart/highcharts-1/"/>
    <id>https://maxleebk.com/2020/09/15/highchart/highcharts-1/</id>
    <published>2020-09-15T02:33:00.000Z</published>
    <updated>2023-10-23T03:50:24.348Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>「資視」指的是資料視覺化，請原諒我使用諧音雙關的爛梗 <span class="emoji" alias="sweat_smile" style="" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8">&#x1f605;</span></p></blockquote><p>從第四次工業革命（工業4.0）開始，大數據成為產業發展的顯學，各種產業不斷在收集與歸納龐大的使用者資料，運用在行銷策略、製造生產等領域。不過數據在經過「機器」進行演算與整理後，最終要閱讀的仍然是「人類」，因此有效的資料視覺化能幫助用戶分析和推理。</p><p>也因為如此，現在越來越多網站運用所謂的「儀表板」來做數據監控、分析的應用，進而使得圖表繪製逐漸成為前端工程師的必備技能之一。</p><img src="data.png" style="max-width: 500px; margin: 16px auto 0;" /><p>當然，要是圖表一個個手刻，那網站還沒做好你可能都想轉職了，不過幸虧 JavaScript 的視覺化函式庫五花八門，像是龐大的 D3.js 或小巧簡單的 Chart.js，都可以幫助我們快速將資料轉換成易讀性高的圖表。</p><p>如果你感興趣的話，<a href="https://en.wikipedia.org/wiki/Comparison_of_JavaScript_charting_libraries">這裡</a> 可以看到所有知名的 JavaScript 圖表庫及它們之間的比較。</p><hr><h2 id="Highcharts"><a href="#Highcharts" class="headerlink" title="Highcharts"></a>Highcharts</h2><img src="highchart.png" style="max-width: 500px; margin: 24px auto;" /><p>而這次想跟大家介紹的是 Highcharts，它是一套純 JavaScript 的圖表庫，採用 SVG 渲染。</p><p>不過似乎是使用人數較少的關係，國內的相關文章寥寥可數，加上官方文件的中翻文本也是較舊的版號，所以這次希望能以一個使用過 Highcharts 的開發者角度來跟各位介紹它，希望以我的使用經驗可以讓大家認識 Highcharts 的強大功能與應用，那就先來看看它的優點與特性吧！</p><br/><h4 id="優點及特性"><a href="#優點及特性" class="headerlink" title="# 優點及特性"></a># 優點及特性</h4><ol><li>支援 iOS / Android 以及各家主流瀏覽器，甚至能兼容到 IE6</li><li>採用 SVG 的關係，可操作元素進行事件監聽及互動，並使用 CSS 修改樣式</li><li>SVG 不依賴解析度，在大畫面上圖表能避免失真</li><li>擁有豐富的圖表種類及 API 接口，可做到極具交互性的客製化圖表</li><li>在非商業使用上完全免費</li><li>文件完善好閱讀(<del>希望D3.js學習一下</del>)</li></ol><br/><h4 id="SVG-amp-Canvas"><a href="#SVG-amp-Canvas" class="headerlink" title="# SVG &amp; Canvas"></a># SVG &amp; Canvas</h4><p>SVG 與 Canvas 時常被拿來比較，而圖表庫也就很自然的分成兩大派，各自都有其優缺點。</p><p>部分說法是 Canvas 的效能較好，但其實這樣的說法是比較偏頗的，在效能部分其實要看使用情境，Canvas 的效能會因為畫布大小受影響，SVG 則是受到物件的數量受到影響。另外在小數據大畫布的情況下，SVG 所佔記憶體更小，畫面操作上更滑順，在行動裝置使用上會有較好的表現。</p><img src="svg-vs-canvas.png" style="max-width: 600px; margin: 20px auto;" /><p>所以到底要用 Canvas 還是 SVG 主要還是看情境，而一般基本的折線圖、長條圖為了有更好的可讀性，數據都不會太多，但點散圖、熱力圖這種觀看龐大數據分佈的圖形可能就更適合用 Canvas。</p><hr><h2 id="系列內容"><a href="#系列內容" class="headerlink" title="系列內容"></a>系列內容</h2><br/><p>這次的系列文章將會從頭介紹 Highcharts 的使用方式及功能，並且透夠簡單的範例來幫助大家加速理解 Highcharts 的應用，大致上會分成四個部分：</p><p><strong>1. 初次使用及基礎 API</strong><br>Highcharts 的圖表有多個元素區塊，我會跟各位介紹各區塊的用途以及屬性設定，未來才能運用它們繪製圖表。</p><p><strong>2. 事件交互及進階 API</strong><br>除了基本 API，還有更多的進階功能可以幫助我們設定或管理圖表，並且透過事件監聽做到更多的互動操作。</p><p><strong>3. 進階圖表與特殊技巧</strong><br>認識絕大多數的 API 後，我們要融會貫通並嘗試製作一些比較進階的圖表類型，同時會和大家分享一些我在實作上的小技巧。</p><p><strong>4. 框架的配合</strong><br>由於現在前端框架的盛行，所以在詳細認識 Highcharts 後，要跟大家分享如何在 Vue.js 的環境中使用 Highcharts 來作為系列的結尾。</p><p><br/><br/></p><p>這系列提到的都是網頁前端的技術，也有少部分的章節會提到 Vue.js，所以比較適合熟悉 JavaScript 的朋友閱讀，如果沒什麼問題的話…<br><strong>那就讓我們在接下來的 30 天裡好好認識 Highcharts 吧！</strong></p><hr><p>- 此篇文章為「iT邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10236987">iT邦幫忙</a> -</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;「資視」指的是資料視覺化，請原諒我使用諧音雙關的爛梗 &lt;span class=&quot;emoji&quot; alias=&quot;sweat_smile&quot; style=&quot;&quot; fallback-src=&quot;https://github.githubassets.com/im</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Highcharts" scheme="https://maxleebk.com/tags/Highcharts/"/>
    
    <category term="12th鐵人賽" scheme="https://maxleebk.com/tags/12th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>面試官最愛考的 JS 原型鏈</title>
    <link href="https://maxleebk.com/2020/07/25/prototype/"/>
    <id>https://maxleebk.com/2020/07/25/prototype/</id>
    <published>2020-07-25T08:55:00.000Z</published>
    <updated>2023-10-23T03:50:24.520Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JavaScript 是一種基於原型，而不是基於類的物件導向語言。由於這個根本的區別，使它在如何創建物件的層級結構，以及如何繼承屬性和它的值上，顯得有點模糊。 – <em>MDN</em></p></blockquote><p>JavaScript 的原型鏈一直都是大家比較懼怕的一部分，但其實並不是因為它過於艱深，而是因為它的概念很抽象，且初期的前端開發中也不是常常遇到，導致要學習起來會比較困難。</p><p>我自己也是花了不少時間在理解，而今天希望可以透過我的思考方式來和大家一起認識原型鏈。</p><hr><h2 id="背景觀念"><a href="#背景觀念" class="headerlink" title="背景觀念"></a>背景觀念</h2></br><p>在正式開始之前，想先問問大家有沒有聽過 <strong>物件導向(Object-oriented programming；OOP)</strong>？<br>物件導向是一種程式設計模式，在其概念中，軟體是由無數個物件交互合作所組成的，換句話說「物件」就是程式的基本單位。</p><p>可能不是每個人都能理解它的意思，但沒關係，我們今天不會深入這個主題，會提到物件導向是因為 JavaScript 是一個支援物件導向設計的程式語言，而能夠支援的秘密就藏在原型鏈裡面。</p><br/><p>雖然說 JavaScript 支援物件導向，但它的設計方式和一些常見的程式語言不太一樣，程式語言可以簡單分為下面兩種：</p><ul><li><strong>基於類別(Class-Based)</strong>：<br>擁有「類別」與「實例」的概念，類別定義了某種物件的屬性，而實例是由類別產生的物件。比如 Java 和 C++。</li><li><strong>基於原型(Prototype-Based)</strong>：<br>沒有類別與實體的概念，它只有物件，新物件在初始化時以原型物件為範本獲得屬性，比如 JavaScript。</li></ul><br/><p style="font-size:12px; line-height:1.5;">透過上面的描述我們知道了 JavaScript 並沒有類別與實體，但你可能聽過有人會在 JavaScript 的領域提到過類別，或是看過 ES6 的 Class，這是怎麼回事呢？這件事情其實常常被誤會，或許是因為基於類別的程式語言比較廣為使用，所以大家就以習慣的「類別」和「實例」來稱呼 JavaScript 的建構函式和物件了，而 ES6 的 Class，僅僅只是簡化原型鏈操作的語法糖。</p><hr><h2 id="何謂原型"><a href="#何謂原型" class="headerlink" title="何謂原型?"></a>何謂原型?</h2><br/><blockquote><p>指某種新技術在投入量產之前所作的模型，未來將以其作為核心並在此基礎上進行製作、改造或重組。</p></blockquote><p>舉個簡單的例子，貨車可以說是依照汽車的原型製造的，它和汽車有共通的屬性，像是有車門、車輪，需要燃料等等。若是用程式碼來體現這個概念呢？</p><p>下面是一個叫做 <code>Car</code> 的物件，若現在將它作為一個「原型」，並請你以此原型製作出 <strong>六輪雙門柴油貨卡</strong>，你會怎麼做呢？</p><pre><code class="javascript">const Car = &#123;  wheel: 2,  door: 4,  fuel: &quot;汽油&quot;&#125;;</code></pre><p>若你不曾接觸過原型鏈或建構函式，你可能會定義一個 <code>truck</code> 物件，然後調整一下屬性的值。<br>這個方法可以得到正確的結果，但它其實在意義上是錯的，因為你是「重新」製造了一個新的物件，而不是「基於」原型建立的。</p><pre><code class="javascript">const truck = &#123;  wheel: 6,  door: 2,  fuel: &quot;柴油&quot;&#125;;</code></pre><p>這時候你可能會改成將 <code>truck</code> 賦值為 <code>Car</code> 然後修改屬性的值。<br>但這個方法不只沒有新物件被建立，連 <code>Car</code> 的屬性都會一起被改掉，因為 <code>truck</code> 其實是指向了 <code>Car</code> 的參考。</p><pre><code class="javascript">const Truck = Car;Truck.wheel = 6;Truck.door = 2;Truck.fuel = &quot;柴油&quot;;console.log(Car.wheel);  // 6</code></pre><p>可見平時的基礎觀念沒辦法實現「原型」的概念，這會使物件導向沒辦法實踐，因此我們該來認識「建構函式」了。</p><hr><h2 id="建構函式與實例-Constructor-amp-Instance"><a href="#建構函式與實例-Constructor-amp-Instance" class="headerlink" title="建構函式與實例 Constructor &amp; Instance"></a>建構函式與實例 Constructor &amp; Instance</h2><br/><p>前面有提到 Java 是基於類別的程式語言，會利用類別來建立實例，而在類別裡會有個很特別的函式叫做「建構函式」，他會進行實例的初始化，用來設定一些實例的基礎屬性。</p><p>我們先來看看 Java 在建立實例時的語法：</p><pre><code class="java">Foo foo = new Foo();// 以Foo這個類別來建立一個實例foo</code></pre><p>在 Java、C++ 中都會使用 <code>new</code> 這個關鍵字來產生新的實例，而 JavaScript 就也把 <code>new</code> 拿來用了，不過 JavaScript 並沒有「類別」，<code>new</code> 後面該接什麼呢？ JavaScript 的設計者就想到了，既然類別裡都一定要有建構函式，那乾脆 <code>new</code> 後面就接一個函式吧。</p><pre><code class="javascript">function Car(wheel, door, fuel) &#123;  this.wheel = wheel,  this.door = door,  this.fuel = fuel&#125;;let truck = new Car(6, 2, &quot;柴油&quot;);</code></pre><p>可以看到 <code>Car</code> 其實只是一個普通的函式，但如果你用 <code>new</code> 運算子來呼叫它的話，JavaScript 就會將它視為建構函式。<br>而 <code>truck</code> 就是透過 <code>Car</code> 新建出來的實例，印出來會長這樣：</p><pre><code class="javascript">// console.log(truck)Car &#123;  door: 2  fuel: &quot;柴油&quot;  wheel: 6  __proto__: Object&#125;</code></pre><p>你會發現 <code>Car</code> 確實依據我們傳入的參數把 <code>truck</code> 的相關屬性給設定好了，而且在前面標註了 <code>Car</code>，以此說明 <code>truck</code> 是 <code>Car</code> 的實例。</p><hr><h2 id="原型與繼承-Prototype-amp-Inheritance"><a href="#原型與繼承-Prototype-amp-Inheritance" class="headerlink" title="原型與繼承 Prototype &amp; Inheritance"></a>原型與繼承 Prototype &amp; Inheritance</h2></br><p>當然實體與建構函式之間的連結不僅僅只是一個標記那麼簡單，它們各自有著特別的屬性，讓 JavaScript 能夠實踐所謂的「繼承」，而現在我們就要來深入認識這些屬性。</p><h4 id="prototype"><a href="#prototype" class="headerlink" title="# prototype"></a># prototype</h4><p>在 JavaScript 裡，每個函式都擁有 <code>prototype</code> 這個訪問器屬性，而建構函式也是函式，當然就也有 <code>prototype</code>。</p><p style="font-size:12px; line-height:1.5; margin-top: 4px">＊ 訪問器屬性 - 你可以把它當成一種隱藏的內建屬性，所以平常不會注意到。</p><pre><code class="javascript">// console.log(Car.prototype)&#123;  constructor: Car(wheel, door, fuel),  __proto__: Object&#125;</code></pre><p><code>Car.prototype</code> 我們可以稱之為 <code>Car</code> 的原型，在原型中會有兩個固定的訪問器屬性：</p><ul><li><strong>__proto__：</strong>後面會再介紹，這裡暫時先跳過。</li><li><strong>constructor：</strong>中文翻譯就是建構函式，有趣的是它的值就是原本的 <code>Car</code>，所以會造成一個很特別的現象。</li></ul><pre><code class="javascript">console.log(Car === Car.prototype.constructor); // trueconsole.log(Car === Car.prototype.constructor.prototype.constructor); // trueconsole.log(Car === Car.prototype.constructor.prototype.constructor.prototype.constructor); // true...</code></pre><p></br></br></p><h4 id="proto"><a href="#proto" class="headerlink" title="# __proto__"></a># __proto__</h4><p>在 JavaScript 裡，每個物件型別的變數都有 <code>__proto__</code> 這個訪問器屬性，而實例就是物件，當然就也有 <code>__proto__</code>。</p><p style="font-size:12px; line-height:1.5; margin-top: 4px">＊ 物件型別(Object) - 例如：物件、陣列、函式、日期等。</p><pre><code class="javascript">// console.log(truck.__proto__)&#123;  constructor: Car(wheel, door, fuel),  __proto__: Object&#125;</code></pre><p>把 <code>truck.__proto__</code> 印出來後就會發現它跟 <code>Car.prototype</code> 長得一模一樣，所以我們可以來做個大膽的假設：</p><blockquote><p>身為一個實例，<code>truck</code> 應該繼承 <code>Car</code> 類別的屬性，但 <code>Car</code> 只是建構函式而不是真的類別，所以 JavaScrip 為函式設計了 <code>prototype</code> 屬性，讓實例被創建時，可以繼承建構函式的原型。</p></blockquote><p>要證明這個假設也很簡單：</p><pre><code class="javascript">console.log(truck.__proto__ === Car.prototype); // true</code></pre><p><code>truck.__proto__</code> 和 <code>Car.prototype</code> 不只是長得一樣，它們指向的就是同一個物件，所以 <code>truck</code> 確實繼承了 <code>Car</code> 的屬性。</p><hr><h2 id="new-運算子"><a href="#new-運算子" class="headerlink" title="new 運算子"></a>new 運算子</h2><br/><p>現在知道當我們在創建實例時，主要會有兩件事情發生：</p><ul><li><strong>實例會被初始化，並透過建構函式新增屬性</strong></li><li><strong>實例的 <code>__proto__</code> 會被指向建構函式的 <code>prototype</code></strong></li></ul><p>但這些事情怎麼發生的？而且為什麼在 <code>Car</code> 裡面使用 <code>this</code> 會是幫實例加上屬性呢？<br>正常來說函式中的 <code>this</code> 指向的應該會是 <code>window</code>，所以要是你直接執行 <code>Car</code> 的話，應該是 <code>window</code> 會被設定屬性才對：</p><pre><code class="javascript">Car(1, 1, &quot;空氣&quot;);console.log(window.door); // 1</code></pre><p>其實一切的關鍵都在於 <code>new</code>，我們可以用函式來模擬 <code>new</code> 做的事情：</p><pre><code class="javascript">function newObject(Constructor, arguments) &#123;  var o = new Object();  // 1. 建立新物件  o.__proto__ = Constructor.prototype;  // 2. 重新指向原型  Constructor.apply(o, arguments);  // 3. 初始化物件  return o; // 4. 回傳新物件&#125;;let truck = newObject(Car, [6, 2, &quot;柴油&quot;]);</code></pre></br><ol><li><strong>建立新物件：</strong> 建立一個新物件，起初這個物件的 <code>__proto__</code> 指向的會是 <code>Object.prototype</code></li><li><strong>重新指向原型：</strong> 重新將 <code>__proto__</code> 指向建構函式的原型，使物件成為建構函式的實例</li><li><strong>初始化物件：</strong> 執行建構函式，但利用 <code>apply</code> 將 <code>this</code> 指定給實例，這樣才能為它新增屬性</li><li><strong>回傳新物件：</strong> 最後回傳這個處理完成的實例</li></ol><p><code>new</code> 背後做的事情不是很複雜但卻很重要，它將實例以及原型之間建立了連結。</p><hr><h2 id="原型鏈-prototype-chain"><a href="#原型鏈-prototype-chain" class="headerlink" title="原型鏈 prototype chain"></a>原型鏈 prototype chain</h2></br><p><code>new</code> 負責將實例的 <code>__proto__</code> 指向建構函式的原型，但 <code>Car.prototype</code> 中卻又看到另一個 <code>__proto__</code>，它會指向誰呢？</p><pre><code class="javascript">// console.log(Car.prototype.__proto__)&#123;  constructor: Object(),  // ...其餘省略&#125;</code></pre><p>我們把 <code>Car.prototype.__proto__</code> 印出來後發現裡面一樣有 <code>constructor</code>，指向的是 <code>Object</code> 這個建構函式。<br>而這個線索告訴了我們，原來 <code>Car.prototype.__proto__</code> 指向的是 <code>Object</code> 的原型，驗證了一下也確實如此：</p><pre><code class="javascript">console.log(Car.prototype.__proto__ === Object.prototype); // true</code></pre><p>更重要的是物件之間的繼承關係，原來是一個接著一個不斷延續的，看起來就像條鎖鏈一樣。</p><pre><code class="javascript">truck.__proto__ // Car.prototypetruck.__proto__.__proto__ // Object.prototypetruck.__proto__.__proto__.__proto__  // null</code></pre><p>不過原型鏈也是有終點的，<code>Object.prototype.__proto__</code> 指向的是 <code>null</code>，代表 <code>Object</code> 是原型鏈的最頂端，這也是為什麼會說 <strong>JavaScript 中一切都是物件</strong>的原因了。用圖像表示應該可以更容易理解：<br><img src="chain.png" alt=""></p><hr><h2 id="原理的實際體現"><a href="#原理的實際體現" class="headerlink" title="原理的實際體現"></a>原理的實際體現</h2></br><p>到目前為止似乎還沒有感受到 <code>prototype</code> 帶來什麼特別的益處，因為我們還沒有開始利用它，這也是為什麼 <code>Car.prototype</code> 裡面除了訪問器屬性外什麼都沒有的原因。</p><pre><code class="javascript">// console.log(Car.prototype)&#123;  constructor: Car(wheel, door, fuel),  __proto__: Object&#125;</code></pre></br><p>假設要為 <code>Car</code> 的實例加上一個 <code>drive</code> 的函式，我們已經知道在建構函式裡多寫行程式碼就可以辦到：</p><pre><code class="javascript">function Car(wheel, door, fuel) &#123;  this.wheel = wheel,  this.door = door,  this.fuel = fuel  this.drive = function() &#123;    console.log(`消耗$&#123;this.fuel&#125;前進`)  &#125;&#125;;let truck = new Car(6, 2, &quot;柴油&quot;);let gogoro = new Car(2, 0, &quot;電力&quot;);truck.drive(); // 消耗柴油前進gogoro.drive(); // 消耗電力前進</code></pre><p>不過 <code>drive</code> 其實在每個實例中都是做同樣的事情，應該是可以抽出來共享的，如果用上面這種方式寫的話，反而會造成記憶體空間的浪費：</p><pre><code class="javascript">console.log(truck.drive === gogoro.drive); // false</code></pre><p>上面的等式不成立表示兩個實例中的 <code>drive</code> 雖然長得一樣，卻是兩個不同的函式，為了解決這個缺點可以這樣做：</p><pre><code class="javascript">function Car(wheel, door, fuel) &#123;  this.wheel = wheel,  this.door = door,  this.fuel = fuel&#125;;Car.prototype.drive = function() &#123;  console.log(`消耗$&#123;this.fuel&#125;前進`);&#125;;let truck = new Car(6, 2, &quot;柴油&quot;);let gogoro = new Car(2, 0, &quot;電力&quot;);truck.drive(); // 消耗柴油前進gogoro.drive(); // 消耗電力前進console.log(truck.drive === gogoro.drive); // true</code></pre><p>我們把 <code>drive</code> 抽出來放進 <code>Car</code> 的原型裡，這樣就算是不同的實體，操作的還是同一個函式，因為它們呼叫的都是 <code>Car.prototype.drive</code>。</p><p>不過你可能會驚訝 <code>drive</code> 其實不是 <code>truck</code> 的屬性之一，而你能夠呼叫它是因為 JavaScript 如果在物件中找不到某個屬性時就會去 <code>__proto__</code> 裡面找，一路找到 <code>Object.prototype</code>。</p><pre><code class="javascript">truck.hasOwnProperty(&quot;drive&quot;); // trueconsole.log(truck.drive === truck.__proto__.drive); // true</code></pre><p>而這也是為什麼當你在 <code>let today = new Date()</code> 後可以使用 <code>getMonth()</code> 或 <code>getDate()</code> 等方法的原因，這些 methods 實際上是在 <code>Date.prototype</code> 裡，甚至下面這些你平常在寫語法背後也是同樣的道理：</p><pre><code class="javascript">let obj = &#123;&#125;; // new Object()let arr = []; // new Array()let fn = function()&#123;&#125;; // new Function()</code></pre><hr><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2></br><p>過了今天會發現其實平常我們就已經在「原型鏈」的架構下撰寫 JavaScript 了，或許目前還用不到 JavaScript 的類別(當然不是真的類別)，不過你現在已經知道箇中玄機了，所以假使未來有使用的需要或甚至在面試時被面試官問到，相信你已經可以應付得宜了。</p><p>參考資料：</p><ul><li><a href="https://blog.techbridge.cc/2017/04/22/javascript-prototype/">該來理解 JavaScript 的原型鏈了 - huli</a></li><li><a href="https://cythilya.github.io/2018/10/26/prototype/">你懂 JavaScript 嗎？#19 原型（Prototype）- Summer</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;JavaScript 是一種基於原型，而不是基於類的物件導向語言。由於這個根本的區別，使它在如何創建物件的層級結構，以及如何繼承屬性和它的值上，顯得有點模糊。 – &lt;em&gt;MDN&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JavaScri</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="原型鏈" scheme="https://maxleebk.com/tags/%E5%8E%9F%E5%9E%8B%E9%8F%88/"/>
    
  </entry>
  
  <entry>
    <title>透過 CancelToken 解析 Axios 原始碼</title>
    <link href="https://maxleebk.com/2020/07/07/axios-cancelToken/"/>
    <id>https://maxleebk.com/2020/07/07/axios-cancelToken/</id>
    <published>2020-07-07T07:23:00.000Z</published>
    <updated>2023-10-23T03:50:24.348Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇會藉由設計「取消重複請求機制」來解析 axios 的原始碼，篇幅較長請耐心閱讀，如果要直接看實作可以點 <a href="#實際運用">這裡</a></p></blockquote><p>其實要實踐取消請求的功能並不會很難，官方也有一目瞭然的 <a href="https://github.com/axios/axios#cancellation">教學</a>，不過我自己在實作後一直對於 <code>cancelToken</code> 的原理耿耿於懷，就去研究了一下原始碼，所以在實際撰寫之前，想先分享一下我的理解。</p><p>接下來我們會直接看打包過的檔案： <code>axios/dist/axios.js</code>，所有 axios 的程式碼都在這。<br>你也可以一邊看 <a href="https://github.com/axios/axios/blob/master/dist/axios.js">github</a> 一邊看文章。</p><hr><h2 id="為什麼需要取消請求"><a href="#為什麼需要取消請求" class="headerlink" title="為什麼需要取消請求"></a>為什麼需要取消請求</h2><p><code>cancelToken</code> 可以為我們取消多餘或不必要的 <code>http請求</code>，雖然在一般情況下可能感覺不到有取消請求的必要，不過在一些特殊情況中沒有好好處理的話，可能會導致一些問題發生。像是…</p><ul><li>快速的頁面切換，使得上個頁面的請求在新頁面完成。</li><li><code>Pending</code> 時間較久的 <code>API</code> 若短時間內重複請求，會有舊蓋新的情況。</li><li>重復的 <code>post</code> 請求，有可能導致多次的資料操作，例如表單發送兩次。</li></ul><hr><h2 id="發送請求與攔截器"><a href="#發送請求與攔截器" class="headerlink" title="發送請求與攔截器"></a>發送請求與攔截器</h2><br/><h4 id="Class-Axios"><a href="#Class-Axios" class="headerlink" title="# Class Axios"></a># Class Axios</h4><p>先從最主要的 <code>Axios類別</code> 看起，每一個 axios 應用都會創建一個 <code>Axios類別</code>，而當中最核心的就是 <code>request</code> 方法，不過我們先暫時跳過。<br>後面兩段則是在類別上又新增了好幾個方法，讓我們可以發起不同的http請求： <code>axios.get()</code>、<code>axios.post()</code>。<br>不過仔細一看會發現，最終我們呼叫的還是 <code>request</code>，所以才會說 <code>request</code> 是 axios 的核心。</p><pre><code class="javascript">function Axios(instanceConfig) &#123;  this.defaults = instanceConfig;  this.interceptors = &#123;    request: new InterceptorManager(),    response: new InterceptorManager()  &#125;;&#125;Axios.prototype.request = function request(config) &#123;  // ...先跳過&#125;;// 幫不同的請求方法創建別名，最終都是呼叫requestutils.forEach([&#39;delete&#39;, &#39;get&#39;, &#39;head&#39;, &#39;options&#39;], function forEachMethodNoData(method) &#123;  Axios.prototype[method] = function(url, config) &#123;    return this.request(utils.merge(config || &#123;&#125;, &#123;      method: method,      url: url    &#125;));  &#125;;&#125;);utils.forEach([&#39;post&#39;, &#39;put&#39;, &#39;patch&#39;], function forEachMethodWithData(method) &#123;  Axios.prototype[method] = function(url, data, config) &#123;    return this.request(utils.merge(config || &#123;&#125;, &#123;      method: method,      url: url,      data: data    &#125;));  &#125;;&#125;);</code></pre><p></br></br></p><h4 id="Class-InterceptorManager"><a href="#Class-InterceptorManager" class="headerlink" title="# Class InterceptorManager"></a># Class InterceptorManager</h4><p>在前面我們有看到，<code>Axios類別</code> 中有個 <code>interceptors</code> 屬性，其值為物件，並且有 <code>request</code> 和 <code>response</code> 的屬性。<br>這兩個屬性都是 <code>InterceptorManager類別</code>，而這個類別是用來管理攔截器的，我在 <a href="https://f820602h.github.io/Max-Blog/2020/05/27/axios-instance/">上一篇</a> 有介紹過攔截器是什麼，忘記的人快去複習一下。</p><p>而今天我們就是要用Axios的攔截器來達到取消重複請求的功能，所以來看看 <code>InterceptorManager</code> 吧。</p><pre><code class="javascript">function InterceptorManager() &#123;  // 儲存攔截器的方法，未來陣列裡會放入物件，每個物件會有兩個屬性分別對應成功和失敗後的函式  this.handlers = [];&#125;// 在攔截器裡新增一組函式，我們在上一篇有用過InterceptorManager.prototype.use = function use(fulfilled, rejected) &#123;  this.handlers.push(&#123;    fulfilled: fulfilled,    rejected: rejected  &#125;);  return this.handlers.length - 1;&#125;;// 註銷攔截器裡的某一組函式InterceptorManager.prototype.eject = function eject(id) &#123;  if (this.handlers[id]) &#123;    this.handlers[id] = null;  &#125;&#125;;// 原碼的寫法我覺得很容易看不懂，所以我改寫了一下// 簡單來說就是拿handlers跑迴圈，把裡面的物件當作參數來給fn執行InterceptorManager.prototype.forEach = function(fn) &#123;  this.handlers.forEach(obj =&gt; &#123;    fn(h);  &#125;);&#125;;</code></pre><p>基本上這個類別還蠻單純的，主要就是三個操作 <code>handlers</code> 的方法，我們之前就是透過 <code>axios.interceptors.request.use</code> 和 <code>axios.interceptors.response.use</code> 來添加攔截器的。</p><p>但現在我們要再更深入了解Axios是怎麼在請求前後透過攔截器處理 <code>request</code> 和 <code>response</code> 的，這時候就要回去看 <code>Axios.prototype.request</code> 了。<br></br></br></p><h4 id="Axios-prototype-request"><a href="#Axios-prototype-request" class="headerlink" title="# Axios.prototype.request"></a># Axios.prototype.request</h4><p>可以發現，每當我們發送請求 <code>Axios.prototype.request</code> 會宣告一個陣列以及一個Promise物件。<br>並且利用 <code>InterceptorManager.prototype.forEach</code> 把我們攔截器中新增的函式一一放進 <code>chain</code> 中。<br>至於 <code>dispatchRequest</code> 就是Axios主要發送 <code>XMLHttpRequest</code> 的函式，我們等等會提到。</p><p>當所有函式都放進 <code>chain</code> 後再兩兩一組拿出來作為 <code>promise.then()</code> 的參數，而且利用Promise的鏈式呼叫來串接。<br>最後我們的請求就可以依照 <code>request攔截器 -&gt; dispatchRequest -&gt; response攔截器</code> 的順序進行處理。</p><pre><code class="javascript">Axios.prototype.request = function request(config) &#123;  //..省略  var chain = [dispatchRequest, undefined];  // 定義一個狀態是resolve的Promise; config是發出請求時帶的設定  var promise = Promise.resolve(config);  // InterceptorManager.prototype.forEach，把request攔截器的每一組函式「往前」加進chain裡  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) &#123;    chain.unshift(interceptor.fulfilled, interceptor.rejected);  &#125;);  // InterceptorManager.prototype.forEach，把response攔截器的每一組函式「往後」加進chain裡  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) &#123;    chain.push(interceptor.fulfilled, interceptor.rejected);  &#125;);  // 全部加進去後，chain會長的像是這樣: [  //   request.handlers[0].fulfilled, request.handlers[0].rejected, ...,   //   dispatchRequest, undefined,  //   response.handlers[0].fulfilled, response.handlers[0].rejected, ...,  // ]  // 只要chain裡還有項目，就繼續執行  while (chain.length) &#123;    promise = promise.then(chain.shift(), chain.shift());  &#125;  return promise;&#125;;</code></pre><p>最後把所有的函數串接起來後，<code>promise</code> 會像是下面這樣，並且 <code>Axios.prototype.request</code> 會把這個 <code>promise</code> 返回出來，所以我們才可以在呼叫 <code>axios.get()</code> 之後直接用 <code>then()</code>。</p><pre><code class="javascript">Promise.resolve(config)  .then(requestFulfilled, requestRejected)  .then(dispatchRequest, undefined)  .then(responseFulfilled, responseRejected)</code></pre></br><ul><li>這個 <code>Promise</code> 已經是 <code>resolve</code> 狀態，所以請求攔截器會拿到 <code>config</code> 來做前置處理。</li><li>官方文件有規定，添加請求攔截器的時候，fulfilled函式最後要返回 <code>config</code>，所以 <code>dispatchRequest</code> 才能拿到 <code>config</code> 來發送請求。</li><li><code>dispatchRequest</code> 在完成 <code>XMLHttpRequest</code> 後會返回請求的 <code>response</code> 給回應攔截器。</li><li>官方文件一樣有規定回應攔截器的fulfilled函式最後要返回 <code>response</code>，所以你最後才可以拿到API資料。</li></ul><p></br></br></p><h4 id="Function-dispatchRequest"><a href="#Function-dispatchRequest" class="headerlink" title="# Function dispatchRequest"></a># Function dispatchRequest</h4><p>現在知道了攔截器是如何串接的了，那 <code>dispatchRequest</code> 是如何發送http請求的呢？<br>我們只看重點部分，當中 <code>adapter</code> 會根據發送請求的環境對應到不同的適配器(建立請求的函式)，而 <code>dispatchRequest</code> 會再以 <code>then()</code> 串接，由http請求的成功或失敗來決定要進入回應攔截器的 <code>fulfilled</code> 函式或 <code>rejected</code> 函式。</p><pre><code class="javascript">module.exports = function dispatchRequest(config) &#123;  // 檢查請求是否被取消的函式  throwIfCancellationRequested(config);  // axios會使用預設的http請求適配器，除非你有特別設定  // 以瀏覽器發送請求會使用xhrAdapter，node環境則使用httpAdapter  var adapter = config.adapter || defaults.adapter;  // 適配器會把http請求包裝成Promise並返回，dispatchRequest再以then()串接  return adapter(config).then(    // 若請求成功dispatchRequest會返回response給回應攔截器的fulfilled函式    function onAdapterResolution(response) &#123;      throwIfCancellationRequested(config);      return response;    &#125;,    // 反之則將錯誤拋給回應攔截器的rejected函式    function onAdapterRejection(reason) &#123;      if (!isCancel(reason)) throwIfCancellationRequested(config);      return Promise.reject(reason);    &#125;  );&#125;</code></pre><p>另外可以看到 <code>throwIfCancellationRequested</code> 不斷的出現，這個函式會檢查請求是否已經被「要求」取消，等我們進入到 CancelToken 時會再提到它。<br></br></br></p><h4 id="Function-xhrAdapter"><a href="#Function-xhrAdapter" class="headerlink" title="# Function xhrAdapter"></a># Function xhrAdapter</h4><p>由於我們是以瀏覽器發送請求，所以這邊以 <code>xhrAdapter</code> 適配器為主，<a href="https://github.com/axios/axios/blob/master/dist/axios.js#L977-L1146">完整程式碼</a>。<br><code>xhrAdapter</code> 整段很長，但如果只看重點，其實就是在發送 <code>XMLHttpRequest</code>，並在過程中做一些判斷來決定要 <code>resolve</code> 或 <code>reject</code> 這個 <code>Promise</code>。</p><pre><code class="javascript">module.exports = function xhrAdapter(config) &#123;  return new Promise(function dispatchXhrRequest(resolve, reject) &#123;    // 建立一個新的XMLHttpRequest    var request = new XMLHttpRequest();    // 監聽readyState的變化    request.onreadystatechange = function handleLoad() &#123;      // readyState === 4 代表請求完成      if (!request || request.readyState !== 4) return;      // 若請求完成，準備好回應的response      var responseHeaders = &#39;getAllResponseHeaders&#39; in request ? parseHeaders(request.getAllResponseHeaders()) : null;      var responseData = !config.responseType || config.responseType === &#39;text&#39; ? request.responseText : request.response;      var response = &#123;        data: responseData,        status: request.status,        statusText: request.statusText,        headers: responseHeaders,        config: config,        request: request      &#125;;      // settle內部會做一些驗證，成功則resolve(response)，反之reject(error)      settle(resolve, reject, response);      request = null;    &#125;;    // 發送XMLHttpRequest    request.send(requestData);  &#125;);&#125;;</code></pre><p>到目前為止我們已經知道 axios 處理請求的流程，接下來就進入本文的重點 - CancelToken。</p><p><img src="flow.png" alt="我把整個架構圖像化，希望對各位有幫助。"></p><hr><h2 id="CancelToken"><a href="#CancelToken" class="headerlink" title="CancelToken"></a>CancelToken</h2><br/><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="# 基本用法"></a># 基本用法</h4><p>在看原始碼前，我們先看看 <code>CancelToken</code> 是怎麼使用的。<br>這段程式做了什麼可以先不管，我們只要知道，如果要使用 <code>CancelToken</code> 就必須在 <code>request</code> 的 <code>config</code> 中新增一個 <code>cancelToken</code> 屬性。</p><pre><code class="javascript">let cancelaxios.get(&#39;/user/12345&#39;, &#123;  cancelToken: new axios.CancelToken(c =&gt; &#123; cancel = c; &#125;)&#125;);cancel()</code></pre><p><br/><br/></p><h4 id="Class-CancelToken"><a href="#Class-CancelToken" class="headerlink" title="# Class CancelToken"></a># Class CancelToken</h4><p>再來就該看看我們在 <code>cancelToken</code> 屬性中建構的 <code>CancelToken類別</code> 是什麼。</p><ul><li>首先，每一個 <code>CancelToken</code> 都會建立一個 <code>Promise</code>，並且將 <code>resolve</code> 主動權給拿了出來，定義給<code>resolvePromise</code>。</li><li>再者，當我們要建構一個 <code>CancelToken</code> 的時候必須傳入一個 <code>function</code>，它會直接被呼叫並且得到一個名為 <code>cancel</code> 的函式作為參數。</li></ul><p>當要取消請求就是呼叫 <code>cancel</code>，而它做了兩件事情： 1. 賦值給屬性 <code>reason</code>　2. 將屬性 <code>promise</code> 給 <code>resolve</code></p><pre><code class="javascript">function CancelToken(executor) &#123;  // 判斷executor是否為function  if (typeof executor !== &#39;function&#39;) &#123;    throw new TypeError(&#39;executor must be a function.&#39;);  &#125;  // 建立一個新的Promise物件，並將其resolve函式賦予給變數resolvePromise  // 此時Promise會是pending狀態，還未被resolve  var resolvePromise;  this.promise = new Promise(function promiseExecutor(resolve) &#123;    resolvePromise = resolve;  &#125;);  // 執行executor，並以函式「cancel」作為參數帶入  var token = this;  executor(function cancel(message) &#123;    // 確認reason是否存在，若存在代表cancel已被執行過    if (token.reason) return;    // 將reason賦值為一個Cancel類別    token.reason = new Cancel(message);    // resolve Promise    resolvePromise(token.reason);  &#125;);&#125;// 確認reason是否存在，若存在代表此CancelToken的cancel已被執行過，便拋出錯誤CancelToken.prototype.throwIfRequested = function throwIfRequested() &#123;  if (this.reason) throw this.reason;&#125;;</code></pre><p>所以 axios 只要根據這兩個屬性，就能判斷此次請求是否已經被取消，而 <code>throwIfRequested</code> 就是利用 <code>reason</code> 來判斷是否要拋出錯誤。<br><br/><br/></p><h4 id="throwIfCancellationRequested"><a href="#throwIfCancellationRequested" class="headerlink" title="# throwIfCancellationRequested"></a># throwIfCancellationRequested</h4><p>還記得我們在 <code>dispatchRequest</code> 裡有看到 <code>throwIfCancellationRequested</code> 不斷的被呼叫嗎？<a href="#Function-dispatchRequest">這裡</a><br>它的作用就是判斷 <code>config</code> 是否有被加上 <code>cancelToken</code> 屬性，有的話就會呼叫 <code>CancelToken.prototype.throwIfRequested</code>，以此來判斷請求是否已被取消。</p><pre><code class="javascript">function throwIfCancellationRequested(config) &#123;  if (config.cancelToken) config.cancelToken.throwIfRequested();&#125;</code></pre><p><br/><br/></p><h4 id="Function-xhrAdapter-1"><a href="#Function-xhrAdapter-1" class="headerlink" title="# Function xhrAdapter"></a># Function xhrAdapter</h4><p>沒錯，又再次看到了 <code>xhrAdapter</code>，因為在前面我暫時省略了 <code>xhrAdapter</code> 內部的一個判斷。<br>當它發現 <code>config.cancelToken</code> 存在，便會為 <code>CancelToken.promise</code> 接上一個 <code>then()</code>，意味著當 <code>promise</code> 被 <code>resolve</code> 的那一刻，請求就會被 <code>abort</code>。</p><pre><code class="javascript">module.exports = function xhrAdapter(config) &#123;  return new Promise(function dispatchXhrRequest(resolve, reject) &#123;    var request = new XMLHttpRequest();    // ...省略....    if (config.cancelToken) &#123;      // cancelToken.promise要被resolve才會執行then      // onCanceled(cancel)中的cancel會是cancelToken.reason      config.cancelToken.promise.then(function onCanceled(cancel) &#123;        if (!request) return;        // 取消XMLHttpRequest        request.abort();        reject(cancel);        request = null;      &#125;);    &#125;    request.send(requestData);  &#125;);&#125;;</code></pre><p><br/><br/></p><h4 id="重點整理"><a href="#重點整理" class="headerlink" title="# 重點整理"></a># 重點整理</h4><p>首先我們可以知道 CancelToken 的原理就是在 <code>request config</code> 中加上一個 <code>CancelToken類別</code>，並且利用其類別屬性來判斷 <code>cancel</code> 函式是否被呼叫執行，若已執行代表該請求被「要求」取消。</p><p>另外可以發現 axios 在以下三個時機點都有檢查請求的取消與否：</p><ul><li>請求發送前 - <a href="#Function-dispatchRequest">dispatchRequest開頭</a></li><li>請求發送中 - <a href="#Function-xhrAdapter-1">xhrAdapterq</a></li><li>請求發送後 - <a href="#Function-dispatchRequest">dispatchRequest.then</a></li></ul><hr><h2 id="實際運用"><a href="#實際運用" class="headerlink" title="實際運用"></a>實際運用</h2></br><p>了解整個 axios 架構以及 CancelToken 後，終於可以來實踐取消請求的功能了，先來釐清我們的需求。</p><blockquote><p>每次發送請求要判斷是否已經存在相同的請求，若存在就取消前一次請求，只保留最新的</p></blockquote><p>根據這樣的需求我們歸納出幾個必要的關鍵，然後準備以下程式碼</p><ol><li>為了要能取消請求，必須設定 <code>config.cancelToken</code></li><li>為了要判斷重複的請求，要把每次請求記錄在暫存中</li><li>在請求完成或被取消時從暫存中移除</li></ol><pre><code class="javascript">// 暫存：紀錄執行中的請求const pending = new Map();const addPending = config =&gt; &#123;  // 利用method和url來當作這次請求的key，一樣的請求就會有相同的key  const key = [config.method, config.url].join(&quot;&amp;&quot;);  // 為config添加cancelToken屬性  config.cancelToken = new axios.CancelToken(cancel =&gt; &#123;    // 確認暫存中沒有相同的key後，把這次請求的cancel函式存起來    if (!pending.has(key)) pending.set(key, cancel);  &#125;);&#125;;const removePending = config =&gt; &#123;  // 利用method和url來當作這次請求的key，一樣的請求就會有相同的key  const key = [config.method, config.url].join(&quot;&amp;&quot;);  // 如果暫存中有相同的key，把先前存起來的cancel函式拿出來執行，並且從暫存中移除  if (pending.has(key)) &#123;    const cancel = pending.get(key);    cancel(key);    pending.delete(key);  &#125;&#125;;</code></pre><p>準備就緒後，只要在請求攔截與回應攔截器中呼叫它們即可…</p><pre><code class="javascript">// request 攔截器instance.interceptors.request.use(  config =&gt; &#123;    // 先判斷是否有重複的請求要取消    removePending(config);    // 把這次請求加入暫存    addPending(config);    return config;  &#125;,  error =&gt; &#123;    return Promise.reject(error);  &#125;);// response 攔截器instance.interceptors.response.use(  response =&gt; &#123;    // 請求被完成，從暫存中移除    removePending(response);    return response;  &#125;,  error =&gt; &#123;    return Promise.reject(error);  &#125;);</code></pre><p>從此我們不必再擔心 API 在回應前被重複觸發導致錯誤，因為我們永遠只會保留最新一次的請求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇會藉由設計「取消重複請求機制」來解析 axios 的原始碼，篇幅較長請耐心閱讀，如果要直接看實作可以點 &lt;a href=&quot;#實際運用&quot;&gt;這裡&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其實要實踐取消請求的功能並不會很難，官方也有一目瞭然</summary>
      
    
    
    
    
    <category term="Vus.js" scheme="https://maxleebk.com/tags/Vus-js/"/>
    
    <category term="Axios" scheme="https://maxleebk.com/tags/Axios/"/>
    
  </entry>
  
  <entry>
    <title>用 Axios Instance 管理 API</title>
    <link href="https://maxleebk.com/2020/05/27/axios-instance/"/>
    <id>https://maxleebk.com/2020/05/27/axios-instance/</id>
    <published>2020-05-27T12:46:25.000Z</published>
    <updated>2023-10-23T03:50:24.348Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自從用前端框架開始開發後，就沒在用 JQuery Ajax 了，取而代之的是 Axios</p></blockquote><p> Axios 不僅輕量，而且直接幫我們把非同步操作包裝成 Promise 物件，所以我們可以直接使用 Promise API 像 <code>then()</code>、<code>catch()</code>。</p><p>雖然自己在用 Axios 的時候，都是直接 <code>improt</code> 進來就開始 <code>axios.get</code>、<code>axios.post</code>，不過後來在工作中接觸到了更好管理 API 的方式 Axios - Instance （Axios實體）。</p><hr><h2 id="為什麼要用-Axios-Instance"><a href="#為什麼要用-Axios-Instance" class="headerlink" title="為什麼要用 Axios Instance ?"></a>為什麼要用 Axios Instance ?</h2><ul><li>集中設定 Request Config</li><li>支援攔截器，可在 then/catch 前做額外處理</li><li>封裝 API 易於管理</li></ul><hr><h2 id="建立實體"><a href="#建立實體" class="headerlink" title="建立實體"></a>建立實體</h2></br><h4 id="Custom-Config"><a href="#Custom-Config" class="headerlink" title="# Custom Config"></a># Custom Config</h4><p>我們可以建立一支檔案 api.js ，先用 axios.create 創造一個實體，裡面放進 Request 的相關設定屬性。</p><pre><code class="javascript">// api.jsimport axios from &quot;axios&quot;;// baseURL是你API的主要Domain，只後發請求時只要填相對路徑就可以了const instance = axios.create(&#123;  baseURL: &#39;https://your.api.domain.tw/&#39;,  headers: &#123; &#39;Content-Type&#39;: &#39;application/json&#39; &#125;,  timeout: 20000&#125;);</code></pre><p>Request Config 其實有不少屬性可以設定，但一般常見的是上面這些，詳細的說明 <a href="https://github.com/axios/axios#request-config">官方</a> 都有介紹，這邊就不再贅述。</p><p></br></br></p><h4 id="攔截器"><a href="#攔截器" class="headerlink" title="# 攔截器"></a># 攔截器</h4><p>攔截器的設置可以讓我們在發出 <code>request</code> 或接到 <code>response</code> 之前做一些事情，例如改變 <code>response</code> 回來的資料格式，或是根據不同 <code>request</code> 來添加不同的 config 等等。</p><ul><li>Request Interceptors<br>用 <code>axios.interceptors.request.use()</code> 就可以設置 <code>request</code> 的攔截器，放入兩個函式做為參數。<ul><li>Fulfilled Function: 第一個函式會在 request 送出前攔截到此次的 config，讓你可以做一些前置處理。</li><li>Rejected Function: 第二個函式可以讓你在 request 發生錯誤時做一些額外的處理。</li></ul></li></ul><pre><code class="javascript">// 此處的instance為我們create的實體instance.interceptors.request.use(  function (config) &#123;    // Do something before request is sent    return config;  &#125;,  function (error) &#123;    // Do something with request error    return Promise.reject(error);  &#125;);</code></pre></br><ul><li>Response Interceptors<br><code>response</code> 攔截器大同小異，用 <code>axios.interceptors.response.use()</code> 就可以設置。<br>而這邊要著墨的部分就在於攔截到 <code>response</code> 發生錯誤時的 <code>error</code> 處理。</li></ul><pre><code class="javascript">// 此處的instance為我們create的實體instance.interceptors.response.use(  function (response) &#123;    // Do something with response data    return response;  &#125;,  function (error) &#123;    if (error.response)&#123;      switch (error.response.status) &#123;        case 404:          console.log(&quot;你要找的頁面不存在&quot;)          break;        case 500:          console.log(&quot;程式發生問題&quot;)          break;        default          console.log(error.message)      &#125;    &#125;     if (!window.navigator.onLine) &#123;      alert(&quot;網路出了點問題，請重新連線後重整網頁&quot;);      return;    &#125;    return Promise.reject(error);  &#125;);</code></pre><p>這樣設定後，就可以在 <code>response</code> 回應錯誤時做相關的處理，例如導頁就是常見的處理方式。<br>以上就是攔截器的主要用途和應用，預計之後會再寫一篇說明該如何用攔截器來取消 <code>request</code>。</p><p></br></br></p><h4 id="封裝請求"><a href="#封裝請求" class="headerlink" title="# 封裝請求"></a># 封裝請求</h4><p>有了主設定以及攔截器，<code>axios instance</code> 就設計得差不多了，一般來說你已經可以把實體 <code>export</code> 出去使用了，但為了更有系統性的管理後端提供的 API，我們可以設計成 <code>function</code> 再 <code>export</code> 出去。</p><pre><code class="javascript">// 此處的instance為我們create的實體export default function(method, url, data = null, config) &#123;  method = method.toLowerCase();  switch (method) &#123;    case &quot;post&quot;:      return instance.post(url, data, config);    case &quot;get&quot;:      return instance.get(url, &#123; params: data &#125;);    case &quot;delete&quot;:      return instance.delete(url, &#123; params: data &#125;);    case &quot;put&quot;:      return instance.put(url, data);    case &quot;patch&quot;:      return instance.patch(url, data);    default:      console.log(`未知的 method: $&#123;method&#125;`);      return false;  &#125;&#125;</code></pre><p>這樣就可以透過判斷參數來回傳相對應的 <code>method</code>，而且我們也已經把發送請求的格式寫好了。<br>今天假設我們有一些與使用者相關的 API 好了，我們就可以把這個函式 <code>import</code> 進來，把 API 一支支地列出。</p><pre><code class="javascript">// user.jsimport req from &quot;./api&quot;;export const userSignUp = (signUpData) =&gt; &#123;  return req(&quot;post&quot;, &quot;/user/sign-in&quot;, signUpData)&#125;export const userLogIn = (logInData) =&gt; &#123;  return req(&quot;post&quot;, &quot;/user/log-in&quot;, logInData)&#125;export const userLogOut = () =&gt; &#123;  return req(&quot;get&quot;, &quot;/user/log-out&quot;)&#125;export const userDelete = (userNo) =&gt; &#123;  return req(&quot;delete&quot;, &quot;/user/delete&quot;, userNo)&#125;</code></pre><p>而實際要呼叫API的時候，只要把它 <code>import</code> 進來就可以用囉～</p><pre><code class="javascript">import &#123; userLogIn &#125; from &quot;./user&quot;;userLogIn()  .than(res =&gt; &#123;    console.log(&quot;登入成功&quot;);  &#125;)  .catch(error =&gt; &#123;    // response攔截器會先執行，除非你漏接了，才會進到catch  &#125;)</code></pre><p>這樣統一、集中且有條理地管理API是不是很清爽呢！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;自從用前端框架開始開發後，就沒在用 JQuery Ajax 了，取而代之的是 Axios&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; Axios 不僅輕量，而且直接幫我們把非同步操作包裝成 Promise 物件，所以我們可以直接使用 Promise</summary>
      
    
    
    
    
    <category term="Vus.js" scheme="https://maxleebk.com/tags/Vus-js/"/>
    
    <category term="Axios" scheme="https://maxleebk.com/tags/Axios/"/>
    
  </entry>
  
  <entry>
    <title>在 Vue 聰明使用 SVG-Icon</title>
    <link href="https://maxleebk.com/2020/05/18/vue-svg/"/>
    <id>https://maxleebk.com/2020/05/18/vue-svg/</id>
    <published>2020-05-18T12:46:25.000Z</published>
    <updated>2023-10-23T03:50:24.536Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一般來說我們在Vue的專案裡使用SVG，會有兩種比較簡單的方式。</p></blockquote></br><h4 id="第一種：Using-SVG-as-an-＜img＞"><a href="#第一種：Using-SVG-as-an-＜img＞" class="headerlink" title="第一種：Using SVG as an ＜img＞"></a>第一種：Using SVG as an ＜img＞</h4><p>利用 <code>&lt;img&gt;</code> 標籤來引入，此時 SVG 被視為一個圖檔載入，最大的缺點就是無法利用 CSS 來改變 SVG 的樣式。<br>但不幸的是如果你的 icon 會有改變顏色的需求，你就需要兩張不同顏色的圖檔，兩個 <code>&lt;img&gt;</code> 標籤，然後用 <code>display</code> 來控制，非常繁瑣。</p><pre><code class="html">&lt;img src=&quot;icon.svg&quot; /&gt;</code></pre></br><h4 id="第二種：Inline-SVG"><a href="#第二種：Inline-SVG" class="headerlink" title="第二種：Inline SVG"></a>第二種：Inline SVG</h4><p>直接將 <code>&lt;svg&gt;</code> 標籤放進 Html 結構中，這種方法雖然解決了改變顏色的問題，但卻讓程式碼看起來非常雜亂。</p><pre><code class="html">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;16&quot; height=&quot;16&quot; viewBox=&quot;0 0 16 16&quot;&gt;  &lt;g fill-rule=&quot;evenodd&quot; stroke=&quot;#EA475B&quot; stroke-linecap=&quot;round&quot;&gt;    &lt;path d=&quot;M8 3.5v9M4.5 9.5l3.5 4 3.5-4&quot;/&gt;  &lt;/g&gt;&lt;/svg&gt;</code></pre><hr><h2 id="SVG-Sprites"><a href="#SVG-Sprites" class="headerlink" title="SVG Sprites"></a>SVG Sprites</h2></br><p>SVG Sprites 是一種對於 SVG 中 <code>use</code> 元素的應用，可以像是蓋印章一樣，不斷復用已經定義好的 SVG 圖形，而在 Vue 專案中，我們可以透過 <code>webpack</code> 的 <code>loader</code> 以及一些設定來達到同樣的效果。</p><p>首先建立資料夾路徑 <code>src/assets/icon</code>，之後的 <code>.svg</code> 檔都會放在這裡。<br>再來要安裝今天的主角 <code>svg-sprite-loader</code>，他就是這次要使用的 Webpack Loader。</p><pre><code>$ npm install svg-sprite-loader -D$ yarn add svg-sprite-loader -D</code></pre><p>安裝好後要調整一下 <code>webpack</code> 設定，在 <a href="https://github.com/JetBrains/svg-sprite-loader">官方文件</a> 中有詳細說明如何配置。但剛好 vue-cli 支援 <code>webpack-chain</code> ，我們就用它來設定吧！<br>在 <code>vue.config.js</code> 中撰寫以下程式碼：</p><pre><code class="javascript">module.exports = &#123;  chainWebpack: config =&gt; &#123;    // 先刪除預設的svg配置    config.module.rules.delete(&quot;svg&quot;)    // 新增 svg-sprite-loader 設定    config.module      .rule(&quot;svg-sprite-loader&quot;)       .test(/\.svg$/)      .include      .add(resolve(&quot;src/assets/icon&quot;)）      .end()      .use(&quot;svg-sprite-loader&quot;)      .loader(&quot;svg-sprite-loader&quot;)      .options(&#123; symbolId: &quot;[name]&quot; &#125;)    // 修改 images-loader 配置    config.module      .rule(&quot;images&quot;)      .exclude.add(resolve(&quot;src/assets/icon&quot;))  &#125;&#125;</code></pre><ul><li>記得把 SVG 的路徑 <code>src/assets/icon</code> 給 <code>add</code> 進來。</li><li>使用 <code>options</code> 設定 <code>symbolId</code> 屬性，用來決定 SVG 的 <code>symbolId</code> 該以什麼方式命名，這次用的是 <code>&quot;[name]&quot;</code>，指定以檔名來命名。</li><li>另外把原本的 images-loader 排除 <code>icon</code> 資料夾，這樣只要放在 <code>src/assets/icon</code> 的 SVG 就不能用 <code>&lt;img&gt;</code> 引入了。</li></ul></br><p>大功告成，這樣之後就可以在 vue 元件中引入 <code>.svg</code> 檔。</p><pre><code class="javascript">import &quot;@/src/assets/icon/target.svg&quot;;</code></pre><p>然後在 <code>template</code> 裡使用下面這樣簡便的寫法，就可以清爽的使用 svg-icon 了，而且還可以隨心所欲的改變顏色！</p><pre><code class="html">&lt;svg&gt;&lt;use xlink:href=&quot;#target&quot; /&gt;&lt;/svg&gt;&lt;!-- #target 改成svg的檔名就好囉，記得加井字號 --&gt;</code></pre><hr><h2 id="全域引入與全域元件"><a href="#全域引入與全域元件" class="headerlink" title="全域引入與全域元件"></a>全域引入與全域元件</h2></br><p>雖然已經解決了改變icon顏色以及程式碼雜亂的問題，但每當要使用icon時，都必須在元件中引入對應的 <code>.svg</code> 檔，也是增添不少管理上的麻煩，這時候一樣可以透過 <code>webpack</code> 幫我們處理。</p><p>在 <code>main.js</code> 中，利用 <code>webpack</code> 的 <code>require.context</code> 可以一次性的引入檔案。 <a href="https://webpack.js.org/guides/dependency-management/#require-context">官方說明</a><br>這樣 <code>.svg</code> 檔就會全域性的引入，之後就不用一個個 <code>import</code> 了，而且未來如果要新增圖示，只要把檔案丟進資料夾就好，導入的部分 <code>webpack</code> 會自動幫你處理，真的幫我們省下不少功夫。</p><pre><code class="javascript">const requireAll = requireContext =&gt; requireContext.keys().map(requireContext)const req = require.context(&quot;@/src/assets/icon&quot;, true, /\.svg$/)requireAll(req)</code></pre></br><p>再者，我們還可以新增一個元件來包裝 SVG Sprites，並且全域註冊這個元件。</p><pre><code class="javascript">import SvgIcon from &quot;@/components/common/SvgIcon&quot;Vue.component(&quot;icon&quot;, SvgIcon)</code></pre><pre><code class="vue">&lt;template&gt;  &lt;svg :class=&quot;svgClass&quot; aria-hidden=&quot;true&quot;&gt;    &lt;use :xlink:href=&quot;`#$&#123;iconName&#125;`&quot; /&gt;  &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;SvgIcon&quot;,  props: &#123;    iconName: &#123;      type: String,      required: true    &#125;  &#125;&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.svg-icon &#123;  width: 16px;  height: 16px;  vertical-align: -0.15em;  fill: currentColor !important;  overflow: hidden;&#125;&lt;/style&gt;</code></pre><p>這樣就可以直接用元件的方式使用 SVG 囉！</p><pre><code class="html">&lt;icon iconName=&quot;target&quot; /&gt;&lt;!-- 就像是在用 FontAwesome 一樣舒服 --&gt;</code></pre><hr><h3 id="補充"><a href="#補充" class="headerlink" title="補充"></a>補充</h3><p>icon 的顏色是吃父層的 css:color ，如果發現 icon 顏色改不了，記得把 SVG 檔裡的 fill 或 stroke 改成 currentColor ，或是請設計師幫你設定一下輸出的檔案配置喔！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一般來說我們在Vue的專案裡使用SVG，會有兩種比較簡單的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/br&gt;

&lt;h4 id=&quot;第一種：Using-SVG-as-an-＜img＞&quot;&gt;&lt;a href=&quot;#第一種：Using-SVG-as-an-＜</summary>
      
    
    
    
    
    <category term="Vus.js" scheme="https://maxleebk.com/tags/Vus-js/"/>
    
    <category term="SVG" scheme="https://maxleebk.com/tags/SVG/"/>
    
    <category term="Webpack" scheme="https://maxleebk.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>JS地下城 - 幸運輪盤</title>
    <link href="https://maxleebk.com/2020/01/14/js-underground-9/"/>
    <id>https://maxleebk.com/2020/01/14/js-underground-9/</id>
    <published>2020-01-14T12:46:25.000Z</published>
    <updated>2023-10-23T03:50:24.520Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇為六角學院 - JS地下城攻略文　<a href="https://github.com/f820602h/Lucky-Wheel/">Github</a>｜<a href="https://f820602h.github.io/Lucky-Wheel/">Demo</a></p></blockquote></br><h2 id="確認需求"><a href="#確認需求" class="headerlink" title="確認需求"></a>確認需求</h2><ul><li>根據資料產生畫面</li><li>抽獎機率需考慮獎項數量而非種類</li><li>輪盤指針的旋轉角度</li><li>抽中的獎品減少並不再被抽到</li></ul><p><strong>這次比較需要思考的應該會是機率的計算以及指針旋轉的度數計算。</strong></p><hr><h2 id="解題攻略"><a href="#解題攻略" class="headerlink" title="解題攻略"></a>解題攻略</h2></br><h4 id="扇形切版"><a href="#扇形切版" class="headerlink" title="# 扇形切版"></a># 扇形切版</h4><p>純 CSS 要做出扇型一直都是蠻麻煩的，網上其實都查得到很多作法，這邊提供我的結構以及樣式。</p><pre><code class="html">&lt;div class=&quot;fan&quot;&gt;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.fan &#123;  width: 100%;  height: 100%;  border-radius: 50%;  overflow: hidden;  clip-path: polygon(50% 0%, 100% 0%, 100% 100%, 50% 100%)&#125;.inner &#123;  width: 50%;  height: 100%;  background: #5858B9;  transform-origin: right center;  transform: rotate(60deg);&#125;</code></pre><p><img src="https://cdn-images-1.medium.com/max/2598/1*Ax_ixX4Hrwu2373gUrTgAw.jpeg" alt=""></p><p>我是使用 <code>clip-path</code> 搭配 <code>rotate</code> 來做到這樣的效果，旋轉幾度這個扇形就會是幾度，最後只要根據需求來跑相對應的迴圈次數，為 <code>.fan</code> 也加上 <code>rotate</code> 就可以將扇形拼成一個圓了。</p><p></br></br></p><h4 id="資料管理"><a href="#資料管理" class="headerlink" title="# 資料管理"></a># 資料管理</h4><p>網站其實就是一堆的資料的顯示與互動。以本題目為例，每年老闆都會提供一份「尾牙獎品清單」這樣的資料，而我們的工作便是確保畫面與資料的一致性，所以每當有獎品增減，我們都要去改動畫面並且確認功能沒有因此而壞掉，這樣其實是非常繁複沒有效率的，所以我們要設計成由「資料驅動畫面」，未來就算資料更動了，我們也不用特地去調整畫面。</p><p>首先要做的第一步就是資料管理，而一般網頁上最常見的資料格式就是 <code>JSON</code>，我們可以把獎品清單整理成以下格式：</p><pre><code class="json">[  &#123;    &quot;text&quot;: &quot;Movie&quot;,    &quot;icon&quot;: &quot;&lt;i class=&#39;material.icons&#39;&gt;movie_filter&lt;/i&gt;&quot;,    &quot;num&quot;: 0  &#125;,  &#123;    &quot;text&quot;: &quot;Wish&quot;,    &quot;icon&quot;: &quot;&lt;i class=&#39;material.icons&#39;&gt;cake&lt;/i&gt;&quot;,    &quot;num&quot;: 5  &#125;,  &#123;    &quot;text&quot;: &quot;Anything&quot;,    &quot;icon&quot;: &quot;&lt;i class=&#39;material.icons&#39;&gt;star&lt;/i&gt;&quot;,    &quot;num&quot;: 5  &#125;,  &#123;    &quot;text&quot;: &quot;Child&quot;,    &quot;icon&quot;: &quot;&lt;i class=&#39;material.icons&#39;&gt;child_care&lt;/i&gt;&quot;,    &quot;num&quot;: 4  &#125;,  &#123;    &quot;text&quot;: &quot;Flight&quot;,    &quot;icon&quot;: &quot;&lt;i class=&#39;material.icons&#39;&gt;flight&lt;/i&gt;&quot;,    &quot;num&quot;: 1  &#125;,  &#123;    &quot;text&quot;: &quot;wifi&quot;,    &quot;icon&quot;: &quot;&lt;i class=&#39;material.icons&#39;&gt;wifi&lt;/i&gt;&quot;,    &quot;num&quot;: 5  &#125;,]</code></pre><p>接著把 <code>JSON</code> 資料存成 <code>.json</code> 檔，然後再用 <code>AJAX</code> 去取得資料。</p><pre><code class="javascript">let data;$.get(&#39;db.json&#39;, function(res) &#123;   data = res &#125;;</code></pre><p><code>JSON</code> 資料會是一個陣列，所以我們可以使用一些陣列的方法來處理它，像是用 <code>forEach</code> 迴圈來新增元素：</p><pre><code class="javascript">// 根據資料長度計算每個扇型要占多少度數let preAngle = 360 / data.length;let wheel = $(&#39;.wheel&#39;);// 跑forEach迴圈data.forEach((item, index) =&gt; &#123;  let fan = $(&#39;&lt;div class=&quot;fan&quot;&gt;&lt;/div&gt;&#39;);  let inner = $(&#39;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&#39;);  fan.css(&#39;transform&#39;, `rotate($&#123;preAngle * index&#125;deg)`);  inner.css(&#39;transform&#39;, `rotate($&#123;preAngle&#125;deg)`);  fan.append(inner);  wheel.append(fan);&#125;);</code></pre><p>現在程式就會根據資料來製作輪盤了，不管資料是多是少都能自動計算並產生畫面，當然我裡面省略的很多，例如文字和圖示的顯示以及扇型起始角度的調整，不過相信各位勇者都能舉一反三的 !</p><p></br></br></p><h4 id="機率處理"><a href="#機率處理" class="headerlink" title="# 機率處理"></a># 機率處理</h4><p>再來是處理機率的問題，我們要先知道「抽獎機率需考慮獎項數量而非種類」是甚麼意思，假設獎項種共有 6 種，但是數量是 25 個，那每個獎品被抽到的機率應該是 1/25 而不是 1/6，所以數量越多的獎品應該要越容易被抽中。</p><p>為了有一個符合自然機率的抽獎系統，我們需要製作一個虛擬的抽獎箱，把所有的獎項給放進去。</p><pre><code class="javascript">let preAngle = 360 / data.length;let wheel = $(&#39;.wheel&#39;);// 宣告一個陣列let giftBox = []data.forEach((item, index) =&gt; &#123;  // 在forEach中加上迴圈，讓每個獎品根據其數量往giftBox添加  for (let i = 0; i &lt; item.num; i++) &#123;  　giftBox.push(index)  &#125;  let fan = $(&#39;&lt;div class=&quot;fan&quot;&gt;&lt;/div&gt;&#39;);  let inner = $(&#39;&lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&#39;);  fan.css(&#39;transform&#39;, `rotate($&#123;preAngle * index&#125;deg)`);  inner.css(&#39;transform&#39;, `rotate($&#123;preAngle&#125;deg)`);  fan.append(inner);  wheel.append(fan);&#125;);</code></pre><p>迴圈跑完後的 <code>giftBox</code> 應該會長這個樣子…</p><pre><code class="javascript">console.log(giftBox)// [1,1,1,1,1,2,2,2,2,2,3,3,3,3,4,5,5,5,5,5]</code></pre><p>之後我們可以設計成，按下按鈕後就從陣列 <code>pop</code> 出一個獎品就可以了。<br>不過現在的獎項排列太整齊了，沒有隨機性，所以我們可以在每次抽獎前先打亂順序，就像是把抽獎箱搖一搖：</p><pre><code class="javascript">let shuffle = function(a, b) &#123;  return Math.random() &gt; 0.5 ? -1 : 1;&#125;;$(&quot;button&quot;).click(function()&#123;  let giftIndex = giftBox.sort(shuffle).pop();&#125;);</code></pre><p>這樣抽獎功能就符合自然機率了，而且因為 <code>pop</code> 會實際改動陣列本身，所以被抽走的獎品自然就從陣列裡移除不會再被抽到囉。</p><p></br></br></p><h4 id="指針旋轉"><a href="#指針旋轉" class="headerlink" title="# 指針旋轉"></a># 指針旋轉</h4><p>抽出獎項後我們要讓指針轉動，沒錯，先抽獎再轉指針，畫面只是一種氣氛啦！</p><p>還記得我們剛剛亂數抽出的 <code>giftIndex</code> 嗎？它代表的是 <code>JSON</code> 資料裡的索引，只要拿去陣列裡查詢就可以知道抽到的是什麼獎品，而且 <code>giftIndex</code> 乘以先前計算的 <code>preAngle</code> 就可以知道指針要轉多少角度了。</p><pre><code class="javascript">let gift;let startAngle;$(&quot;button&quot;).click(function()&#123;  // 舉個例子:假如我們亂數抽出的gift是2  // 那可以知道抽出的是data[2]的獎品，也就是Anything  let giftIndex = giftBox.sort(shuffle).pop();  gift = data[giftIndex];  // 計算指針要旋轉多少角度才會指到Anything  let goAngle = giftIndex * preAngle;  // 為了讓使用者有臨場感，刻意多加幾圈  goAngle = goAngle + 360 * 5;  // 為了讓指針不必每次都歸零才旋轉，所以我們加上前一次旋轉的度數  goAngle = goAngle + startAngle  // 把這次的角度給記下來，  startAngle = giftIndex * preAngle;  // 最後為指針設定樣式  $(&#39;.hand&#39;).css(&#123;transform: `rotate($&#123;goAngle&#125;deg)`&#125;)&#125;);</code></pre><p>這樣主要的幾個重點需求就都完成了，過程中我有省略了一些部分，如果有問題的話再可以看看完整的 <a href="https://github.com/f820602h/Lucky-Wheel/">程式碼</a>。<br>相信各位勇者都是非常聰慧的！加油！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇為六角學院 - JS地下城攻略文　&lt;a href=&quot;https://github.com/f820602h/Lucky-Wheel/&quot;&gt;Github&lt;/a&gt;｜&lt;a href=&quot;https://f820602h.github.io/Lucky-W</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="JS地下城" scheme="https://maxleebk.com/tags/JS%E5%9C%B0%E4%B8%8B%E5%9F%8E/"/>
    
  </entry>
  
  <entry>
    <title>JS地下城 - 井字遊戲</title>
    <link href="https://maxleebk.com/2019/12/01/js-underground-8/"/>
    <id>https://maxleebk.com/2019/12/01/js-underground-8/</id>
    <published>2019-12-01T12:46:25.000Z</published>
    <updated>2023-10-23T03:50:24.516Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇為六角學院 - JS地下城攻略文　<a href="https://github.com/f820602h/OXGame/">Github</a>｜<a href="https://f820602h.github.io/OXGame/">Demo</a></p></blockquote></br><h2 id="確認需求"><a href="#確認需求" class="headerlink" title="確認需求"></a>確認需求</h2><ul><li>先手為 O，後手為 X，某方獲勝時，上方會紀錄各方的獲勝戰績</li><li>每回合結束後，會判定結果頁(平手、Ｏ 獲勝、X 獲勝)</li><li>需符合 RWD，能在低螢幕解析度也能遊玩，介面不能超出 x 軸。</li><li>請使用瀏覽器離線儲存技術，將戰績保留起來，重新打開遊戲也仍可觀看到歷史戰績。技術請任選以下幾種</li></ul><p><strong>基本上都不是太複雜的需求，唯有判斷勝負可能需要花點時間來思考。</strong></p><hr><h2 id="解題攻略"><a href="#解題攻略" class="headerlink" title="解題攻略"></a>解題攻略</h2></br><h4 id="畫面處理"><a href="#畫面處理" class="headerlink" title="# 畫面處理"></a># 畫面處理</h4><p>秉持專業原則：「設計稿給什麼，畫面就出什麼」，叉叉中間可以利用偽元素蓋掉多餘的線條，製造出中空的效果。<br>文字部分用 text-shadow 或 -webkit-text-stroke 就可以搞定。</p><pre><code class="css">.text&#123;  text-shadow: 2px 2px white, -2px -2px white, 2px -2px white, -2px 2px white;  -webkit-text-stroke: 2px white;&#125;</code></pre><p><img src="https://cdn-images-1.medium.com/max/5208/1*3uprjW3Qc2fTBbzFDeH3KA.png" alt=""> <img src="https://cdn-images-1.medium.com/max/4268/1*JlxlNuoF5OPvRfsv7Rpr2g.png" alt=""></p><p></br></br></p><h4 id="初始化遊戲"><a href="#初始化遊戲" class="headerlink" title="# 初始化遊戲"></a># 初始化遊戲</h4><p>畫面完成後，來處理遊戲流程吧，我們可以使用陣列來儲存每個格子中的圈叉。</p><ul><li>事先為每個格子加一個 <code>data-num</code> 屬性，<code>value</code> 從 <code>0~8</code> 剛好對應九宮格位置，也對應陣列 <code>gamePlay</code> 的 <code>index</code>。</li><li><code>circleTurn</code> 是表示玩家回合的變數，如果為 <code>true</code> 就是圈圈的回合，反之為叉叉的回合。</li><li>每次點擊空格都會由 <code>circleTurn</code> 告訴我們該將 <code>1 (圈)</code> 或 <code>-1 (叉)</code> 加入 <code>gamePlay</code> 陣列中，並且切換回合。</li></ul><p>陣列成功存進資料後，剩下就是判定啦！</p><pre><code class="javascript">let gamePlay = [];let circleTurn = true;let boxes = document.querySelectorAll(&quot;.box&quot;);boxes.forEach( box =&gt; &#123;  box.addEventListener(&quot;click&quot;, function() &#123;    let index = this.getAttribute(&quot;data-num&quot;);    // 如果格子已經被佔領過，不作動    if (gamePlay[index] != undefined) return;    // 反之根據回合填入1或-1    gamePlay[index] = circleTurn ? 1 : -1;    // 切換回合    circleTurn = !circleTurn;  &#125;);&#125;);</code></pre><p></br></br></p><h4 id="勝負判斷"><a href="#勝負判斷" class="headerlink" title="# 勝負判斷"></a># 勝負判斷</h4><p><img src="ooxx.png" alt=""></p><p>我們前面已經利用 <code>data-num</code> 屬性爲格子加上編號了，現在來看看成功連線有什麼規律：</p><ol><li><strong>橫排：012、345、678 - 可以歸類為 3n、3n+1、3n+2。</strong></li><li><strong>直排：036、147、258 - 可以歸類為 n、n+3、n+6。</strong></li><li><strong>斜角：048、246</strong></li></ol><p>我們按照找到的規律去把格子裡的 <code>±1</code> 給相加，如果絕對值等於 <code>3</code>，就代表分出勝負了，那我們就返回其中一個格子的值 <code>(1 或 -1)</code>。<br>如果是 <code>1</code> 代表圈圈獲勝，如果是 <code>-1</code> 代表叉叉獲勝，知道誰獲勝後就可以處理勝負的畫面跟計分了。</p><pre><code class="javascript">let whoWin = function() &#123;  // 左上至右下的斜角  let lrCross = Math.abs(gamePlay[0] + gamePlay[4] + gamePlay[8]);   if (lrCross === 3) return gamePlay[0]  // 右上至左下的斜角  let rlCross = Math.abs(gamePlay[2] + gamePlay[4] + gamePlay[6]);   if (rlCross === 3) return gamePlay[2]  // 橫排  for (let i =0; i &lt; 3; i++) &#123;    let row = Math.abs(gamePlay[3*i] + gamePlay[3*i+1] + gamePlay[3*i+2]);    if (row === 3) return gamePlay[3*i]  &#125;  // 直排  for (let i =0; i &lt; 3; i++) &#123;    let row = Math.abs(gamePlay[i] + gamePlay[i+3] + gamePlay[i+6]);    if (row === 3) return gamePlay[i]  &#125;  // 平手  return null&#125;;</code></pre><p></br></br></p><h4 id="平手狀況"><a href="#平手狀況" class="headerlink" title="# 平手狀況"></a># 平手狀況</h4><p>不過我們還有平手的狀況要處理，先利用變數幫我們紀錄目前的回合數，如果已經達到 <code>9</code>，<code>whoWin()</code> 回傳的卻還是 <code>null</code> 那就表示沒有分出勝負。</p><pre><code class="javascript">let step = 1let gameover = function()&#123;  step++  if (whoWin() === null &amp;&amp; step === 9) &#123;    // 平手要做的事情  &#125; else if (whoWin() === 1) &#123;    // 圈圈贏了要做的事  &#125; else if (whoWin() === -1) &#123;    // 叉叉贏了要做的事  &#125; else &#123;    // 還沒結束的話，切換回合    circleTurn = !circleTurn;  &#125;&#125;</code></pre><p>這樣遊戲架構就完成了，畫面的切換以及分數的顯示再稍微處理一下就可以開始和朋友來場圈叉遊戲了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇為六角學院 - JS地下城攻略文　&lt;a href=&quot;https://github.com/f820602h/OXGame/&quot;&gt;Github&lt;/a&gt;｜&lt;a href=&quot;https://f820602h.github.io/OXGame/&quot;&gt;Dem</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="JS地下城" scheme="https://maxleebk.com/tags/JS%E5%9C%B0%E4%B8%8B%E5%9F%8E/"/>
    
  </entry>
  
  <entry>
    <title>JS地下城 - Canvas</title>
    <link href="https://maxleebk.com/2019/11/01/js-underground-7/"/>
    <id>https://maxleebk.com/2019/11/01/js-underground-7/</id>
    <published>2019-11-01T12:46:25.000Z</published>
    <updated>2023-10-23T03:50:24.516Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇為六角學院 - JS地下城攻略文　<a href="https://github.com/f820602h/Canvas">Github</a>｜<a href="https://f820602h.github.io/Canvas/">Demo</a></p></blockquote></br><h2 id="確認需求"><a href="#確認需求" class="headerlink" title="確認需求"></a>確認需求</h2><ul><li>讓使用者可以使用滑鼠在畫布上繪圖</li><li>畫筆要可以進行基本設定(粗細、顏色)</li><li>一些畫布的基本功能(清空、復原、重做)</li><li>能夠將畫作下載為圖檔</li></ul><p><strong>另外還可以設計一些額外功能作為加分項目</strong></p><hr><h2 id="解題攻略"><a href="#解題攻略" class="headerlink" title="解題攻略"></a>解題攻略</h2></br><h4 id="準備畫布"><a href="#準備畫布" class="headerlink" title="# 準備畫布"></a># 準備畫布</h4><p>先查查 MDN，發現原來要先建構 <code>&lt;canvas&gt;</code> 的渲染環境，用 <code>getContext(&#39;2d&#39;)</code> 來取得2D的繪圖環境，這樣後面才能使用相關的繪圖方法。</p><pre><code class="html">&lt;canvas id=&quot;draw&quot;&gt;&lt;/canvas&gt;</code></pre><pre><code class="javascript">let canvas = document.querySelector(&quot;#draw&quot;);let ctx = canvas.getContext(&quot;2d&quot;);</code></pre><p>在來要決定畫布的大小，以供我們畫圖，官方建議用 <code>&lt;canvas&gt;</code> 的 <code>width</code> <code>height</code> 的屬性設定，避免用css修改，不然會有繪圖比例的問題。<br>這次的需求剛好是滿版的畫布，所以就這麼設定吧！</p><pre><code class="javascript">function setSize() &#123;  let canvasWidth = window.innerWidth();  let canvasHeight = window.innerHeight();  canvas.setAttribute(&quot;width&quot;, canvasWidth);  canvas.setAttribute(&quot;height&quot;, canvasHeight);&#125;</code></pre><p>準備好畫布後，就來簡單畫幾筆吧。</p><pre><code class="javascript">// 開始繪圖ctx.beginPath();// 設定起始座標ctx.mobeTo(x, y);// 設定終點座標ctx.lineTo(x, y);// 繪製ctx.stroke();</code></pre><p>藉由上面四個步驟就可以兩點連唯一線，畫出一條直線囉。</p><p><img src="https://cdn-images-1.medium.com/max/6240/1*Os7N1DpSdK-2o7IxTLERww.png" alt=""></p><p></br></br></p><h4 id="畫筆設定"><a href="#畫筆設定" class="headerlink" title="# 畫筆設定"></a># 畫筆設定</h4><p>成功畫出第一筆後卻發現只有一條細細醜醜的黑線，來試著改變畫筆的顏色粗細吧。</p><pre><code class="javascript">ctx.strokeStyle = &quot;#FFA500&quot;;ctx.lineWidth = 10;ctx.lineCap = &quot;round&quot;;</code></pre></br><p><img src="https://cdn-images-1.medium.com/max/6288/1*Mtx3i8B45xDlW3cqikDc2A.png" alt=""></p><p></br></br></p><h4 id="繪畫互動"><a href="#繪畫互動" class="headerlink" title="# 繪畫互動"></a># 繪畫互動</h4><p>畫筆、畫布都有了，但為了讓使用者可以利用滑鼠來繪圖，必須要把上面的畫直線方法來跟滑鼠事件連動。</p><pre><code class="javascript">let lastPointX, lastPointY;let downHandler = function(e)&#123;  // 滑鼠按下去時得到座標存在變數中作為等等畫圖的起點  lastPointX = e.offsetX;  lastPointY = e.offsetY;  // 並且為Canvas綁定mousemove和mouseup的事件  draw.addEventListener(&quot;mousemove&quot;, moveHandler);  draw.addEventListener(&quot;mouseup&quot;, upHandler);&#125;;let moveHandler = function(e) &#123;  // 滑鼠在移動時我們把新的座標存下來作為終點  let newPointX = e.offsetX;  let newPointY = e.offsetY;  // 畫圖四步驟  ctx.beginPath();  ctx.moveTo(lastPointX, lastPointY);  ctx.lineTo(newPointX, newPointY);  ctx.stroke();  // 把終點改為新的起點  lastPointX = newPointX;  lastPointY = newPointY;&#125;;let upHandler = function()&#123;  // 滑鼠釋放後把剛剛綁定的事件移除  draw.removeEventListener(&quot;mousemove&quot;, moveHandler);  draw.removeEventListener(&quot;mouseup&quot;, upHandler);&#125;;draw.addEventListener(&quot;mousedown&quot;, downHandler)</code></pre><p>透過鼠標的事件綁定，就可以做到類似小畫家的繪圖功能，而實際上畫出來的線條，其實是無數條 <code>１pixel</code> 的直線所串連起來的。<br>簡單來說就是利用滑鼠移動的事件來不斷取得新座標，並且把座標丟進 moveTo() 和 lineTo() 之中，而滑鼠按下和放開只是啟動和關閉的作用。</p></br><p><img src="https://cdn-images-1.medium.com/max/5876/1*nh08sP6qPOrNvnRh-23sNg.png" alt=""></p><p></br></br></p><h4 id="進階功能"><a href="#進階功能" class="headerlink" title="# 進階功能"></a># 進階功能</h4><p>有了基本的繪圖功能，來思考該如何達到「復原」和「重做」吧。<br>看了看文件，發現 <code>Path2D Object</code> 和 <code>save()</code> <code>restore()</code> 好像蠻符合我們要的概念的。</p></br><p><strong>不過仔細研究會發現：</strong></p><ul><li>Path2D Object 是利用 <code>MyPath = new Path2D()</code> 來建立一個路徑物件，可以事先存取路徑再利用 <code>ctx.stroke(MyPath)</code> 畫出來，但這個物件只能存取路徑卻無法存取畫筆顏色和樣式。</li><li>而 <code>save()</code> <code>restore()</code> 可以存取畫布狀態並重新呼叫，但一次只能存取一個狀態到 stack 中，看來也不是我們需要的。</li></ul></br><p>後來找到 <code>toDataURL()</code>，它可以幫我們把畫布狀態編碼為 <code>base64</code> 的字串，這樣就可以存取了。<br>先來定義兩個變數 step 用來紀錄步數 history 用來紀錄每一步的筆畫。每畫一筆步數就 +1，並且把base64 存進 history 中。</p><pre><code class="javascript">let step = -1;let history = [];let push = function()&#123;  step++;  if (step &lt;= history.length - 1) history.length = step  history.push(canvas.toDataURL())&#125;// 記得將push()加入upHandler中</code></pre><p>但為何中間要有一個判斷式呢？我們來思考一下，下面是我們畫圖時的步驟：</p><pre><code class="javascript">A -&gt; B -&gt; C -&gt; D   step = 3// 我們總共畫了四筆，分別都存進 history[A,B,C,D]A -&gt; B -&gt; C   [D]  step = 2// 我們發現Ｄ畫錯了，所以復原到Ｃ，但Ｄ仍然是 history 裡的第[3]步A -&gt; B -&gt; C -&gt; E  [D̶] step = 3// 這時候我們重畫了一個Ｅ，它是新的第[3]步，而舊的Ｄ必須被我們覆蓋掉// history[A,B,C,E]</code></pre><p>這樣應該就很好理解了，而現在每一筆都被記錄下來了，那該怎麼把紀錄給呼叫回來呢？</p><pre><code class="javascript">let undo = function()&#123;  // 創建一個新的圖像物件  let lastDraw = new Image;  // 確定有上一步我們才回到上一步  if(step &gt; 0) step--;  // 把上一部的base64設定給圖像物件  lastDraw.src = history[step];  // 把圖片載入後用畫布渲染出來  lastDraw.onload = function()&#123;    ctx.clearRect(0, 0, canvasWidth, canvasHeight);    ctx.drawImage(lastDraw, 0, 0);  &#125;;&#125;;</code></pre><p>這樣復原就完成了，而重做的概念剛好就是相反的囉。而其實裡面也藏了清除畫布的方法 <code>ctx.clearRect(0,0,canvasWidth,canvasHeight)</code>，這樣清除畫布的功能也一起做好了。</p><p></br></br></p><h4 id="保存作品"><a href="#保存作品" class="headerlink" title="# 保存作品"></a># 保存作品</h4><p>實現復原重做後，保存其實也是一樣道理。</p><pre><code class="javascript">let save = document.querySelector(&quot;#save&quot;);save.addEventListener(&quot;click&quot;, function() &#123;  let link = canvas.toDataURL(&quot;image/png&quot;);  this.setAttribute(&quot;href&quot;, link);  this.setAttribute(&quot;download&quot;, &quot;canvas.png&quot;);&#125;)</code></pre><p>在按下保存後，把畫布狀態利用 <code>toDataURL()</code> 編碼並設定在連結中，這樣可以下載了。</p><hr><h2 id="加分功能"><a href="#加分功能" class="headerlink" title="加分功能"></a>加分功能</h2></br><p>另外也可以增加替換顏色的功能，先用陣列來管理顏色再利用 <code>forEach()</code> 來生成元素。</p><pre><code class="javascript">let brushColor = [&quot;#ffffff&quot;,&quot;#000000&quot;,&quot;#9BFFCD&quot;,&quot;#00CC99&quot;,&quot;#01936F&quot;];</code></pre><p><img src="color1.png" alt=""></p><p>不過顏色有深有淺，若打勾圖示固定是黑色的，那在較深的顏色上就會不清楚，所以我們要來判斷目前所選的顏色是深是淺。</p><pre><code class="javascript">let isDark = function(color) &#123;  let rgbArray = [color.substr(1,2), color.substr(3,2), color.substr(5,2)];  let brightness =  parseInt(`0x$&#123;rgbArray[0]&#125;`) * 0.213 +  parseInt(`0x$&#123;rgbArray[1]&#125;`) * 0.715 +  parseInt(`0x$&#123;rgbArray[2]&#125;`) * 0.072  return brightness &lt; 255 / 2&#125;</code></pre><p>先把16進位色碼拆開並轉為10進位數字，然後透過公式就能知道這個顏色是深是淺，也就能給予對應顏色的打勾圖示了。</p><p><img src="color2.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇為六角學院 - JS地下城攻略文　&lt;a href=&quot;https://github.com/f820602h/Canvas&quot;&gt;Github&lt;/a&gt;｜&lt;a href=&quot;https://f820602h.github.io/Canvas/&quot;&gt;Demo</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
    <category term="Canvas" scheme="https://maxleebk.com/tags/Canvas/"/>
    
    <category term="JS地下城" scheme="https://maxleebk.com/tags/JS%E5%9C%B0%E4%B8%8B%E5%9F%8E/"/>
    
  </entry>
  
</feed>
