<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Max&#39;s Blog</title>
  
  <subtitle>Max Your Mind</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://maxleebk.com/"/>
  <updated>2023-01-12T00:54:38.887Z</updated>
  <id>https://maxleebk.com/</id>
  
  <author>
    <name>Max Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>開始點敏捷的工程師</title>
    <link href="https://maxleebk.com/2022/12/27/scrum-master/"/>
    <id>https://maxleebk.com/2022/12/27/scrum-master/</id>
    <published>2022-12-27T04:00:00.000Z</published>
    <updated>2023-01-12T00:54:38.887Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因緣際會下接下了公司團隊的 Scrum Master 角色，從 2022 六月開始至今已經擔任了六個月的時間，希望用此篇記錄一下我在這個職務下所見所得，希望可以幫助跟我一樣是第一次接觸或承接這樣職務的人。</p></blockquote><br/><h2 id="前言與背景"><a href="#前言與背景" class="headerlink" title="前言與背景"></a>前言與背景</h2><br/><p>因為此篇重點會是講述我擔任 Scrum Master 的經驗與歷程，所以會以「認為讀者都對 Scrum 有一定認知」的前提下寫這篇文章，如果對於我文中提到的相關名詞有疑問，透過 Google 應該都可以找到解答，謝謝見諒！</p><br/><h4 id="成為-Scrum-Master-的契機"><a href="#成為-Scrum-Master-的契機" class="headerlink" title="# 成為 Scrum Master 的契機"></a># 成為 Scrum Master 的契機</h4><p>我在目前的公司已經任職「前端工程師」三年多時間，我們公司除了一些真的很大型的產品團隊之外，大部分團隊的 Scrum Master 都是由 PO/PM 兼任，但剛好我所屬的產品團隊近期進入了產品快速發展時期，大量的專案開發加上產品的運營和維護，讓我們的 PM 實在沒有辦法額外負荷 SM 的工作，所以在主管的考量下，希望由我來兼任 SM 角色，好減輕 PM 的負擔。</p><p>再加上由於工程的人力相對來說比較充裕，以及主管的信任等因素，我就這麼接下這個職務了。</p><hr><h2 id="旅程開始"><a href="#旅程開始" class="headerlink" title="旅程開始"></a>旅程開始</h2><br/><h4 id="成長曲線"><a href="#成長曲線" class="headerlink" title="# 成長曲線"></a># 成長曲線</h4><p>首先我想用一張簡單的曲線圖來說明一下我這六個月的成長階段，透過這張圖可以看出，我經歷了三個階段，而這三個階段的轉變時機則是透過「Scrum 讀書會」促成的，後面我便會從這三個階段及兩個轉捩點來說說我的經歷。</p><blockquote><p>這邊也提前先說明一下，圖上的「Scrum 讀書會」是由產品團隊的一位成員發起的一次活動，邀請所有團隊成員提前閱讀 2020 新發布的 <a href="https://scrumguides.org/docs/scrumguide/v2020/2020-Scrum-Guide-Chinese-Traditional.pdf" target="_blank" rel="noopener">Scrum Guide</a> 以及 2022 <a href="https://rsg.taipei/about/#organiser" target="_blank" rel="noopener">Regional Scrum Gathering</a> 活動的<a href="https://www.youtube.com/watch?v=24DXcoFmCHc" target="_blank" rel="noopener">前導影片</a>，最後在讀書會當天各自提出見解與問題來進行交流討論。</p></blockquote><br/><img src="scrum.png" style="max-width: 800px; margin: 16px auto 0;" /><br/><h4 id="階段一：團隊秘書-amp-行政管理"><a href="#階段一：團隊秘書-amp-行政管理" class="headerlink" title="# 階段一：團隊秘書 &amp; 行政管理"></a># 階段一：團隊秘書 &amp; 行政管理</h4><p><strong>我的心情</strong><br>因為我一開始是對 Scrum Master 實際職責其實是一知半解的，所以我並沒有太多的緊張，反而蠻平常心的，認為只是多處理幾件行政庶務而已。</p><p><strong>我做了什麼</strong><br>在這個階段裡，基本上我做的工作就只是提醒成員開會，並按照過去的流程依樣畫葫蘆，以及把成員的任務進度及狀態做些簡單的管理與追蹤等…沒有做什麼太複雜的工作。</p><p><strong>踩到什麼誤區</strong><br>就如這個階段的標題一樣，我在這個階段所扮演的角色，其實就是「團隊秘書與行政」，工作項目都是一些雞毛蒜皮的小事。而我想這正是因為我對 Scrum Master 的理解太過片面，我對以往 SM 的觀察太過表面，以至於只能模仿，卻無法理解 Scrum 的深層內涵。</p><img src="step1.png" style="max-width: 700px; margin: 16px auto 0;" /><br/><br/><h4 id="轉變：Scrum-讀書會準備期"><a href="#轉變：Scrum-讀書會準備期" class="headerlink" title="# 轉變：Scrum 讀書會準備期"></a># 轉變：Scrum 讀書會準備期</h4><p>第一階段在維持了大約 2 個多月之後，團隊便有了舉辦讀書會的規劃，讀書會的召集人給了我大約兩個禮拜的時間，讓我們閱讀 Scrum Guide 和相關影片，並在讀書會當天要發表一段自己的觀看心得，同時也可以提出自己的疑問和大家討論。</p><p><strong>接觸到的新事物</strong></p><ul><li><a href="https://scrumguides.org/docs/scrumguide/v2020/2020-Scrum-Guide-Chinese-Traditional.pdf" target="_blank" rel="noopener">2020 Scrum Guide</a></li><li><a href="https://www.youtube.com/watch?v=24DXcoFmCHc" target="_blank" rel="noopener">2022 Regional Scrum Gathering 前導影片</a></li></ul><p><strong>領悟及感受</strong></p><ul><li><p>在看過了這些相關資料之後，我才發現原來 Scrum Guide 有提到不少概念和原則，而且好像有些東西是目前團隊沒有做到的。會說「好像」是因為 Scrum Guide 的部分內容並不是那麼具體，所以我實際上是「感覺」我們沒做到。</p></li><li><p>「那既然沒有完全遵照 Scrum Guide 還是可以好好工作，那差別在哪？」是當時一個油然而生的感受，因為我發現公司內的每個團隊遵循 Scrum 的程度有高有低，但身為開發人員的我．似乎在工作上也沒有太大的差別。</p></li><li><p>在看過這些資料或其他網路文章時，大家都會宣揚說 Scrum 能夠帶來什麼好處，但卻沒什麼人會跟你說你應該要怎麼一步步的實踐它，這讓我感到很困擾。</p></li></ul><img src="change1.png" style="max-width: 700px; margin: 16px auto 0;" /><br/><br/><h4 id="階段二：超級英雄-amp-敏捷警察"><a href="#階段二：超級英雄-amp-敏捷警察" class="headerlink" title="# 階段二：超級英雄 &amp; 敏捷警察"></a># 階段二：超級英雄 &amp; 敏捷警察</h4><p><strong>我的心情</strong><br>隨著開始準備讀書會，我開始進到第二個階段，在這個階段裡我的心情其實有點複雜。</p><p>因為就如前面所說的，我其實有點懷疑遵循 Scrum 的意義，不過身為團隊的 SM，我又覺得還是有責任要讓團隊的各個規範對齊 Scrum Guide，但 Scrum Guide 的內容又有不是很具體，所以儘管我很想嘗試做些什麼，卻又不知道該從何開始，導致我也會開始懷疑自己，變得很緊張。</p><p><strong>我做了什麼</strong><br>在這個階段裡，我做的工作基本一樣，只不過我會一直找各種文章來看，希望從中得到指引，或是希望團隊成員能給我一些具體的意見，讓我知道我接下來該做接什麼，才能將 Scrum 真正地在團隊內運作。</p><p><strong>踩到什麼誤區</strong><br>後來回頭看看這個階段並自我檢討後，才發現我有點太心急了，自認為 Scrum Master 要幫成員準備好一切，只要有哪個環節不符合 Scrum Guide 就會覺得不對勁，一直想要做些什麼來證明我是可以擔起這個職務的。所以這個階段才會被我稱作為「超級英雄與敏捷警察」。</p><p>並且現在我也才知道，Scrum Guide 其實就像是媽媽在家裡教你做菜，她不會告訴你鹽要加多少，或是肉要燉多久才會嫩，因為實際在品嚐的是你與你的成員，所以你應該自己找到符合你們的調味，而不是期待 Scrum Guide 像一本食譜，總是給你明確的數字與步驟。</p><img src="step2.png" style="max-width: 700px; margin: 16px auto 0;" /><br/><br/><h4 id="轉變：Scrum-讀書會結束後"><a href="#轉變：Scrum-讀書會結束後" class="headerlink" title="# 轉變：Scrum 讀書會結束後"></a># 轉變：Scrum 讀書會結束後</h4><p>第二階段其實並沒有維持很久，因為在讀書會結束之後，我大該花了一兩天的時間去釐清跟整理，就讓我有了新的領悟跟想法。</p><p><strong>接觸到的新事物</strong></p><ul><li>讀書會中成員的想法</li><li>無數的網路文章</li></ul><p><strong>領悟及感受</strong></p><ul><li><p>在讀書會中，其實每個團隊成員都有提出他們找到的問題與改善的方向，這時候就會感受到其實一個團隊該如何運作 Scrum 並不是 SM 一人的責任，而是整個團隊要一起不斷的檢討與改善才能成型。</p></li><li><p>另外也獲得一個資訊，是大部分的成員都對 Sprint Goal 和有蠻大的關注，所以我認為這可能會是我第一個可以下手改善的部分。</p></li></ul><blockquote><p>最後我整理了大家的想法並且自己反覆看了一些網路文章後，我終於理出一個自己身為 SM 該完成的終極目標：<br><strong><em>因為完成 Sprint Goal 代表團隊產出了價值，而且會為成員帶來向心力及成就感，所以<code>想辦法提升 Sprint Goal 的完成機率與程度</code>就對了</em></strong></p></blockquote><img src="change2.png" style="max-width: 700px; margin: 16px auto 0;" /><hr><h2 id="邁向-Master-的途中"><a href="#邁向-Master-的途中" class="headerlink" title="邁向 Master 的途中"></a>邁向 Master 的途中</h2><br/><p>經歷了前面的兩個階段與轉變，我認為我目前已經開始慢慢步向正軌，朝著真正的 Scrum Master 前進，所以我稱這個階段為「邁向 Master 的途中」，雖然因為我目前正處於這個階段，所以還不太能為這個階段做一些比較完整的總結，不過我還是希望把這個階段額外拉出來，和大家分享一下截至目前為止我在這個階段所做的一些行動。</p><br/><img src="mine.png" style="max-width: 800px; margin: 16px auto 0;" /><br/><h4 id="心智圖"><a href="#心智圖" class="headerlink" title="# 心智圖"></a># 心智圖</h4><p>首先，因為已經在讀書會結束之後找到了我作為 Scrum Master 的終極目標 - <code>提升 Sprint Goal 的完成機率與程度</code>，所以我做的第一件事情是以「Sprint Goal」為題，進行心智圖的繪製，透過不斷地向自己提問「Why? What? How?」來產生分支，然後再以完成終極目標的前提去回答這些問題，如此一來 Sprint 中的每個環節就更可以知道如何執行。</p><p>後面我就會透過三個案例來說明我是如何利用這一套心智圖框架來和團隊一起改善現有流程的。</p><p><br/><br/></p><h4 id="目前的-Planning-有什麼可以改善的？"><a href="#目前的-Planning-有什麼可以改善的？" class="headerlink" title="# 目前的 Planning 有什麼可以改善的？"></a># 目前的 Planning 有什麼可以改善的？</h4><p><strong>我觀察到的現況</strong></p><ol><li>首先比較弔詭的是，我們團隊其實沒有訂定過 Sprint Goal，大家只能看著一連串的 Sprint Backlog 來大概感受產品在這個 Sprint 的走向。</li><li>另外每次在召開 Planning 之前，確切的任務工單是沒有被列出來的，都是先透過 PM 口頭說明的方式來大致了解這個 Sprint 的工作項目。</li></ol><p><strong>問題</strong></p><ul><li>由於沒有 Sprint Goal，導致團隊成員對 Sprint 沒有共識，焦點會分散在各自的任務上而缺乏凝聚力，對於任務的意義性與重要程度也會沒有明顯感受。</li><li>沒有明確的任務數量、範疇、排序等資訊，則會影響成員預估工時的準確性，最後就可能會讓 Sprint Backlog 做不完，使得 Sprint Goal 的完成度降低。</li></ul><p><strong>改善方式</strong></p><ul><li>首先當務之急，當然是請 PM 在每個 Sprint 開始前先訂定一個初步的 Sprint Goal，等到 Planning 時，在與成員討論並定案。</li><li>而為了增加工時估算的精準度，我也請 PM 前一定要將所有工單建立完畢，並按照握們這次的目標制定任務的優先順序，而在 Planning 時，也要請成員預估自己在這個 Sprint 可以花費的時間，若認為時間不夠，才可以在當下將部分任務排除，進而提升 Sprint Goal 的完成度。</li></ul><blockquote><p><strong>架構套用</strong></p><ol><li>因為要提升 Sprint Goal 完成度 → 所以必須要先有 Sprint Goal</li><li>因為要提升 Sprint Goal 完成度 → 所以一開始就要精確的圈出可完成的範圍，否則沒完成的任務將降低完成度</li></ol></blockquote><p><br/><br/></p><h4 id="目前的總結會議-Review-Retrospective-有什麼可以改善的？"><a href="#目前的總結會議-Review-Retrospective-有什麼可以改善的？" class="headerlink" title="# 目前的總結會議(Review + Retrospective)有什麼可以改善的？"></a># 目前的總結會議(Review + Retrospective)有什麼可以改善的？</h4><p><strong>我觀察到的現況</strong></p><ol><li>目前 Review 的回顧方式是請所有成員將自己手上的任務說明一遍狀況，沒有固定形式，大家說明的詳細程度也不一樣，感覺只是一場大型的站立會議。</li><li>Retrospective 的流程是固定不變的，所以感覺成員有點出現疲態。</li></ol><p><strong>問題</strong></p><ul><li>Review 沒有具體展現團隊在這個 Sprint 完成了什麼事以及 Sprint Goal 的推進，而是只有個別成員的工作日誌，成員缺乏目標感以及成就感。</li><li>Retrospective 中，團隊成員的重點都放在感謝與自我檢討，缺乏團隊的核心問題思考，Retro 應該是用來改進團隊運作與流程的時間。</li></ul><p><strong>改善方式</strong></p><ul><li>Review 的第一件事應該是回顧所有工作項，並計算完成與未完成的項目，就可以求得這個 Sprint 的 Sprint Goal 完成度，具體的數值才能讓成員感受到實質的產品推進，而非用感覺的。</li><li>取消工作日誌式的報告，取而代之的是「成果發表」，請該 Sprint 有完成任何「價值」的成員在會議中用簡報形式向整個團隊展示成果，除了增加個別成員的成就感，也能讓整個團隊真正了解這個 Sprint 我們達成了什麼。<code>企劃、設計、功能開法、研究報告等...都是可以發表的內容。</code></li><li>經常變換 Retro 的形式與活動流程，刺激成員的思考，讓主題聚焦在挖掘團隊的核心問題，而不是流於表面。</li></ul><blockquote><p><strong>架構套用</strong></p><ol><li>因為要提升 Sprint Goal 完成度 → 首先要先有機制可以知道我們每次完成了多少</li><li>因為要提升 Sprint Goal 完成度 → 所以要提升成員的成就感、向心力，讓成員覺得自己做的事情有意義</li><li>因為要提升 Sprint Goal 完成度 → 所以要透過有效果的 Retro 來不斷改善團隊的運作</li></ol></blockquote><p><br/><br/></p><h4 id="怎麼制定-Daily-Scrum-的形式？"><a href="#怎麼制定-Daily-Scrum-的形式？" class="headerlink" title="# 怎麼制定 Daily Scrum 的形式？"></a># 怎麼制定 Daily Scrum 的形式？</h4><p><strong>我觀察到的現況</strong></p><ol><li>會想要改善 Daily Scrum，是因為有多數成員都在讀書會上提到，覺得目前的站立會議過於流水帳，常常會抓不到重點。</li><li>有時候部分成員已經完成這個 Sprint 的任務時，他便只能把一些庶務、會議或非團隊相關的事項拿出來說。</li></ol><p><strong>問題</strong></p><ul><li>由於每天的站立中，哪些任務會被提及，取決於負責人有沒有向大家說明，所以大家在站立中是無法得知所有任務的確切進度的。</li><li>當大家對於任務推進沒有具體感受時，很可能就會缺乏目標感，並漸漸淡忘 Sprint Goal 的存在。</li></ul><p><strong>改善方式</strong></p><ul><li>為了讓大家每天都可以知道所有任務的進度，哪些被擱置，哪些已經被完成等…報告的順序由任務排序取代人員排序。</li><li>與團隊成員討論站立的報告重點與句型。</li></ul><blockquote><p><strong>架構套用</strong></p><ol><li>因為要提升 Sprint Goal 完成度 → 所以要可以讓大家清楚知道每天的目標進度，提升目標感</li><li>因為要提升 Sprint Goal 完成度 → 有效果的站立報告才能讓成員提前發現困難並解決，否則將降低完成度</li></ol></blockquote><br/><p>以上就是三個我實際有作出改善的例子，目前團隊跑起來也算順暢，成員也有給出很好的回饋。不過就像我前面領悟到的一樣，團隊的狀況、產品的發展、成員的變動等等都有可能會使原本可行的流程變得過時，所以 Scrum Master 的職責就是不斷為了維護團隊的終極目標而對這些流程與規範進行調整。</p><p>也因此，我的改善方案未必能為直接的幫助所有讀者，我只能分享解決問題的方式讓各位參考，實際還是要針對你的團隊狀況，並與你的團隊成員討論，找出最符合你們的方案。</p><hr><h2 id="心得感想"><a href="#心得感想" class="headerlink" title="心得感想"></a>心得感想</h2><p>最後，想透過幾個問答來總結這幾個月的心得，也算是回答過去自己的一些疑問。</p><p><strong>認為擔任 ScrumMaster 有什麼好處或心得？</strong><br>可以透過不同角度參與產品是很好的經驗，會有很多新的學習機會。且可以順勢改善一些流程來幫助工程方面的作業。</p><p><strong>有沒有遵循或採用 Scrum 有差別嗎？</strong><br>是有差別的，差別並不是工作內容，而是怎麼看待目前的工作內容背後的意義。每個成員都可以參與動態調整團隊所需的開發或行政流程，而非被動接收指令。</p><p><strong>對於之後也想要 SM 的人有什麼建議？</strong><br>學習與未解之題相處。你需要不斷發現隱藏的問題、引導成員說出問題、嘗試與成員一起解決問題，然後再次發現更多問題。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;因緣際會下接下了公司團隊的 Scrum Master 角色，從 2022 六月開始至今已經擔任了六個月的時間，希望用此篇記錄一下我在這個職務下所見所得，希望可以幫助跟我一樣是第一次接觸或承接這樣職務的人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br
      
    
    </summary>
    
    
    
      <category term="Agile" scheme="https://maxleebk.com/tags/Agile/"/>
    
      <category term="Scrum" scheme="https://maxleebk.com/tags/Scrum/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / 結語</title>
    <link href="https://maxleebk.com/2021/10/14/webApi/webApi-30/"/>
    <id>https://maxleebk.com/2021/10/14/webApi/webApi-30/</id>
    <published>2021-10-14T12:11:00.000Z</published>
    <updated>2023-01-12T00:54:39.030Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Web API – Application Programming Interface for The Web，翻譯成中文就是「給網頁使用的應用程序介面」</p></blockquote><p>一個月的時間，我們認識了至少 25 個 Web API，或許不是每一個都能立刻派上用場，但希望至少能讓各位對它們有個印象，未來遇到需求時腦中可以響起：「印象中某個 API 好像能夠做到。」 這麼一句話。</p><p>又或是把本系列文章當作一個字典，每當有功能卡住時，上來翻翻晃晃，說不定就能找到符合情境的 API。另外如果有發現文章中與實際使用上有出入的地方，還請一定要跟我說一聲，避免錯誤的內容傳遞給大家。</p><hr><h2 id="選題動機"><a href="#選題動機" class="headerlink" title="選題動機"></a>選題動機</h2><br/><p>我想應該有不少前端朋友都和我一樣，可能都是透過一些業界課程開始接觸及學習前端知識的，無論是實體課程還是線上課程，而大部分的課程會著重在 JS 基礎語法與觀念，然後學習一些常用的字串、數字、陣列操作等等的原生方法，Web API 的範疇也都圍繞在 DOM 元素的操作及事件上。</p><p>這並不是壞事，因為起初確實需要將基礎打好，多熟悉語法與原生方法，不過也因為這樣，當我們遇到一些功能需求時，會<strong>以既定的觀念或目前掌握的工具來實踐</strong>，卻沒發現原來早就有某個 Web API 已經能輕鬆完成這些任務。而且最可惜地方在於，並不是這些 API 太複雜困難才沒有使用，而是因為根本沒有機會去認識它，所以才沒有使用。</p><p>也因為這個原因，我才決定撰寫這個主題，希望能將這些被埋沒的 Web API 丟到各位的印象裡，儘管現在用不上，但至少你已經對它有基本的認識了，未來才不會又用舊方法硬幹。</p><br/><img src="think.png" style="max-width: 400px; margin: 16px auto 0;" /><hr><h2 id="參賽心得"><a href="#參賽心得" class="headerlink" title="參賽心得"></a>參賽心得</h2><br/><p>今年是第二次參加鐵人賽了，由於去年獲得佳作的題目是比較聚焦深入的，所以一直在思考今年是不是也應該以這種形式內容來參賽，但後來還是認為應該把自己真的想整理、分享的寫出來就好，而不是為了獎項去迎合。</p><p>雖然說今年決定的這個主題並不是很困難，對於比較資深的前端來說，可能不是一個很有資訊量的內容，但如果你跟我一樣，是位 Junior 的話，非常希望這次的系列文章對你有幫助。</p><p>今年選擇不囤積文章，讓自己真的以「每天寫一篇」的形式來完賽，沒想到這真的是一個很大的挑戰，由於白天還有工作，下班後也有健身的習慣，所以每天能夠寫文章的時間大約只有三到四個小時，我必須要將大量的資訊歸納成條列式的內容，甚至還要寫些小範例，真的是好幾天都是壓線完成。但也很感謝自己有堅持不懈，今年又順利完賽了。</p><img src="success.png" style="max-width: 400px; margin: 16px auto 0;" /><blockquote><p>本次系列文章中的所有範例列表：<a href="https://codepen.io/max-lee/pens/tags/?selected_tag=2021ithome" target="_blank" rel="noopener">https://codepen.io/max-lee/pens/tags/?selected_tag=2021ithome</a></p></blockquote><hr><h2 id="未來期許"><a href="#未來期許" class="headerlink" title="未來期許"></a>未來期許</h2><br/><p>目前對於明年是否參賽以及參賽主題都還沒有任何想法，只期許自己可以不斷吸收新知並且抱持一個樂於分享的心情，並且只要在準備好的狀況下，就要把握機會將自己所擁有的訊息歸納整理並傳遞出去。非常感謝對此系列文章有興趣的各位，順利的話，明年再繼續和鐵人賽的大家見面。</p><img src="grow.png" style="max-width: 400px; margin: 16px auto 0;" /><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10281832" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Web API – Application Programming Interface for The Web，翻譯成中文就是「給網頁使用的應用程序介面」&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一個月的時間，我們認識了至少 25 個 Web A
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / Geolocation</title>
    <link href="https://maxleebk.com/2021/10/13/webApi/webApi-29/"/>
    <id>https://maxleebk.com/2021/10/13/webApi/webApi-29/</id>
    <published>2021-10-13T11:19:00.000Z</published>
    <updated>2023-01-12T00:54:39.030Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我的字典裡沒有放棄，因為已鎖定你</p></blockquote><p>現在有不少網站都有地圖相關的功能，而為了解決地圖繪製、路線運算、區域標示…等等複雜的功能，通常大家都會選用第三方的套件或服務，例如 Google Map API、Leaflet、MapBox 之類的，也因為有了這些好用的地圖套件，所以瀏覽器本身的 Geolocation API 可能就容易被遺忘。</p><hr><h2 id="Geolocation"><a href="#Geolocation" class="headerlink" title="Geolocation"></a>Geolocation</h2><p>當然，Geolocation API 並沒有上述那些套件的強大功能，它能做的就是取得使用者目前的地理座標位置，不過，要是你的功能並沒有那麼複雜，單單只是想知道用戶位置的話，其他大可不用殺雞焉用牛刀，Geolocation API 就可以滿足你了。</p><p><br/><br/></p><h4 id="Navigator-geolocation"><a href="#Navigator-geolocation" class="headerlink" title="# Navigator.geolocation"></a># Navigator.geolocation</h4><p>Geolocation 的支援度是非常高的，電腦、手機，各家瀏覽器基本上都是可以使用的，不過在使用前你依然可以先進行檢查，若瀏覽器支援的話，只要透過 <code>navigator.geolocation</code> 就能取得 Geolocation 實體。</p><pre><code class="javascript">if (&quot;geolocation&quot; in navigator) {  console.log(navigator.geolocation);} else {  alert(&quot;你的裝置或瀏覽器不支援定位功能&quot;);}</code></pre><p><br/><br/></p><h4 id="Geolocation-getCurrentPosition"><a href="#Geolocation-getCurrentPosition" class="headerlink" title="# Geolocation.getCurrentPosition"></a># Geolocation.getCurrentPosition</h4><p>有了 Geolocation 實體後，就可以用 <code>getCurrentPosition</code> method 來取得座標位置了，該方法有三個參數，其中第一個為必傳，後兩個為選填：</p><ul><li><strong>success</strong>： 一個回呼函式，會在成功取得位置資訊時觸發，該函式會接到一個 Position 物件。</li><li><strong>error</strong>： 一個回呼函式，會在方法發生錯誤時觸發，該函式則會接到 PositionError 物件。</li><li><strong>options</strong>： 一個物件，其中的屬性可以用來設定獲取位置時的規則。</li></ul><br/><p>參數 options 的詳細屬性：</p><ul><li><strong>enableHighAccuracy</strong>： 一個布林值，決定是否要以最高精準度來取得座標位置，預設為 <code>false</code>。</li><li><strong>timeout</strong>： 一個代表毫秒數的正數，規定設備必須要在多少時間內回應位置資訊，預設為 <code>Infinity</code>。</li><li><strong>maximumAge</strong>： 一個代表毫秒數的正數，表示可以接受多少毫秒以前的暫存位置，預設為 <code>0</code>。</li></ul><br/><blockquote><p><strong>注意</strong>： 若將 <code>enableHighAccuracy</code> 打開，位置資訊的回傳時間將會變長，且可能會使裝置消耗更多電量。</p></blockquote><pre><code class="javascript">function successHandler(position) {  console.log(position);}function errorHandler(err) {  console.log(err);}navigator.geolocation.getCurrentPosition(successHandler, errorHandler, {  enableHighAccuracy: true,  timeout: 5000,  maximumAge: 0,});</code></pre><p>由於定位資訊屬於隱私範圍，所以在呼叫 <code>getCurrentPosition</code> 時，它會先確認裝置的授權狀態，若使用者不接受則會發生錯誤，若使用者未表明授權與否，則會出現詢問對話框。</p><img src="check.png" style="max-width: 500px; margin: 24px auto;" /><p><br/><br/></p><h4 id="Geolocation-watchPosition"><a href="#Geolocation-watchPosition" class="headerlink" title="# Geolocation.watchPosition"></a># Geolocation.watchPosition</h4><p>除了 <code>getCurrentPosition</code> 可以拿到執行當下的使用者定位之外，還有另外一個 method 是 <code>watchPosition</code>，它的功能與參數都與 <code>getCurrentPosition</code> 相同，差別是它會在使用者的位置發生改變時主動觸發 Success CallBack，等於是在監聽使用者的定位。</p><pre><code class="javascript">function successHandler(position) {  console.log(position);}function errorHandler(err) {  console.log(err);}// watchPosition 執行後會回傳一個獨一的 IDconst geoId = navigator.geolocation.watchPosition(successHandler, errorHandler);</code></pre><p><br/><br/></p><h4 id="Geolocation-clearWatch"><a href="#Geolocation-clearWatch" class="headerlink" title="# Geolocation.clearWatch"></a># Geolocation.clearWatch</h4><p>在上方 <code>watchPosition</code> 的範例中，我們用 <code>geoId</code> 來接它丟出來 ID 編號，我們可以將編號傳入 <code>clearWatch</code> method 中，便可以使對應的 <code>watchPosition</code> 停止監聽使用者定位。</p><pre><code class="javascript">const geoId = navigator.geolocation.watchPosition(successHandler, errorHandler);navigator.geolocation.clearWatch(geoId);</code></pre><p><br/><br/></p><h4 id="Position-物件"><a href="#Position-物件" class="headerlink" title="# Position 物件"></a># Position 物件</h4><p>就如前面所說，Success CallBack 在成功獲取位置資訊時會被觸發，並且可以拿到 Position 物件，其中就包含了許多與地理位置相關的屬性可以使用：</p><ul><li><strong>position.coords.longitude</strong>： 使用者所在位置的經度。</li><li><strong>position.coords.latitude</strong>： 使用者所在位置的緯度。</li><li><strong>position.coords.accuracy</strong>： 回傳經緯度的水平誤差(平面距離)，單位為公尺。</li><li><strong>position.coords.altitude</strong>： 使用者所在位置的海拔高度，單位為公尺。</li><li><strong>position.coords.altitudeAccuracy</strong>： 回傳高度的垂直誤差(垂直高度)，單位為公尺。</li><li><strong>position.coords.heading</strong>： 使用者面向的方位，會以順時針相對於正北方的夾角角度呈現。</li><li><strong>position.coords.speed</strong>： 使用者面對的數度，單位為公尺/秒。</li></ul><br/><blockquote><p><strong>注意</strong>： 以上屬性均為浮點數，部分屬性會在裝置無法提供時回傳 <code>null</code>。</p></blockquote><p><br/><br/></p><h4 id="PositionError-物件"><a href="#PositionError-物件" class="headerlink" title="# PositionError 物件"></a># PositionError 物件</h4><p>另一方面，Error CallBack 則會在發生錯誤時觸發，並取得 PositionError 物件，該物件中的 <code>code</code> 屬性將會告知我們目前的錯誤是何種類型及原因：</p><table><thead><tr><th align="center">錯誤代號</th><th align="center">錯誤名稱</th><th align="center">解釋</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">PERMISSION_DENIED</td><td align="center">沒有獲取裝置定位的權限</td></tr><tr><td align="center">2</td><td align="center">POSITION_UNAVAILABLE</td><td align="center">位置資訊獲取錯誤</td></tr><tr><td align="center">3</td><td align="center">TIMEOUT</td><td align="center">在 Timeout 前未取得定位資訊</td></tr></tbody></table><p><br/><br/></p><h4 id="簡單的小範例"><a href="#簡單的小範例" class="headerlink" title="# 簡單的小範例"></a># 簡單的小範例</h4><p>有了 Geolocation API 之後，我們就可以製作一些與位置有關的簡單小功能，像下方的範例就是取得使用者位置後，將經緯度丟給後端來計算距離最近的門市，然後將門市資訊提供給用戶。</p><pre><code class="html">&lt;button onclick=&quot;getPosition()&quot;&gt;搜尋最近的門市&lt;/button&gt;&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;&lt;script&gt;  const result = document.querySelector(&quot;#result&quot;);  function successHandler(position) {    const { longitude, latitude } = position.coords;    // 取得經緯度後傳給後端進行門市的搜尋    axios.get(&quot;https://backend/store&quot;, { longitude, latitude }).then((res) =&gt; {      const store = res.data;      result.innerHTML = &quot;離你最近的門市是&quot; + store.name + &quot;地址： &quot; store.address;    });  }  function errorHandler(err) {    alert(&quot;暫時無法取得您的所在位置，請稍後再試&quot;);  }  function getPosition() {    navigator.geolocation.getCurrentPosition(successHandler, errorHandler);  }&lt;/script&gt;</code></pre><p><br/><br/></p><p>每每說到裝置定位、座標時，大家第一個想到的可能都是 Google Map 或其他地圖套件，但其實瀏覽器本身就有 Geolocation API 可以幫我們處理簡單的定位功能。所以要是你的功能未必要顯示地圖的話，其實你可以選擇使用它喔。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10281557" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我的字典裡沒有放棄，因為已鎖定你&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;現在有不少網站都有地圖相關的功能，而為了解決地圖繪製、路線運算、區域標示…等等複雜的功能，通常大家都會選用第三方的套件或服務，例如 Google Map API、Leafl
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / Notification</title>
    <link href="https://maxleebk.com/2021/10/12/webApi/webApi-28/"/>
    <id>https://maxleebk.com/2021/10/12/webApi/webApi-28/</id>
    <published>2021-10-12T10:31:00.000Z</published>
    <updated>2023-01-12T00:54:39.010Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>訂閱、分享、開啟小鈴鐺，才不會錯過通知喔～</p></blockquote><p>各位有沒有收過網站的通知呢？例如 Youtube 或 Netflix 的新片通知，或是 Facebook 的訊息通知等等…，這個其實就是今天要介紹的 Notification 所達成的效果。</p><hr><h2 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h2><p>不過實話是，真的要像 Youtube 那樣在使用者沒有拜訪網站的狀況下發送通知，是需要使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers" target="_blank" rel="noopener">Service Worker</a> 以及後端的配合，有興趣的人可以看看 <a href="https://whien.medium.com/%E5%BB%BA%E7%AB%8B-service-worker-web-push-notification-web-notification-%E5%AF%A6%E4%BD%9C%E7%B4%80%E9%8C%84-8a3bb9ff09e8" target="_blank" rel="noopener">這篇文章</a>，有詳細說明如何推送未拜訪網站情況下的通知，而今天我們的範疇就先聚焦在如何在「瀏覽情況下」發送通知吧。</p><img src="os.png" style="margin: 24px auto;" /><p>Notification 對於電腦瀏覽器到支援度是不錯的，但在行動裝置上就很糟糕了，iOS 全軍覆沒，Android 也是有使用上的限制，所以使用上還是需要注意一下的。</p><p><br/><br/></p><h4 id="Window-Notification"><a href="#Window-Notification" class="headerlink" title="# Window.Notification"></a># Window.Notification</h4><p>Notification 使用起來並不困難，它本身是一個建構函式，透過 <code>new</code> 關鍵字創建，並傳入一個必要參數即可：</p><pre><code class="javascript">// 檢查瀏覽器是否有支援 Notificationif (&quot;Notification&quot; in window) {  let notification = new Notification(&quot;這是一則通知&quot;);}</code></pre><p>Notification 的第一個參數是 <code>title</code>，會顯示為通知的標題，該參數為必傳參數，而除了 <code>title</code> 之外，你也可以傳入一個可選參數 <code>options</code>，它為一個物件，當中有更多關於通知的詳細設定，下面我只列出幾個我認為比較實用的，若對其他屬性有興趣的話可以看 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Notification/Notification" target="_blank" rel="noopener">這裡</a>。</p><br/><ul><li><strong>body</strong>： 一組字串，會設定為通知的內文，位置會在 <code>title</code> 的下方。</li><li><strong>image</strong>： 一組圖片的 URL 字串，它會成為通知的主視覺圖片。</li><li><strong>icon</strong>： 一組圖片的 URL 字串，它會成為通知的圖標，位置大小依系統原生通知而定。</li><li><strong>data</strong>： 任意的資料格式，任何與通知相關的資料可以放在這，不會顯示在通知當中，一般情境下比較少用，</li><li><strong>requireInteraction</strong>： 一個布林值，決定通知必須要由使用者來關閉，而不是使其自動關閉，預設值為 <code>false</code></li></ul><br/><blockquote><p><strong>注意：</strong> 每個作業系統對於不同的設定屬性有不同的支援或做法，最終的行為可能不會相同，例如 macOS 不支援 <code>image</code> 圖片顯示。</p></blockquote><pre><code class="html">&lt;button onclick=&quot;notifyMe()&quot;&gt;click&lt;/button&gt;&lt;script&gt;  function notifyMe() {    let notification = new Notification(&quot;這裡是通知的標題&quot;, {      body: &quot;這裡是通知的內文&quot;,      icon: &quot;./max.jpg&quot;,      image: &quot;./max.jpg&quot;,      requireInteraction: true,    });  }&lt;/script&gt;</code></pre><img src="mic.png" style="margin: 24px auto;" /><p>可以看到不同作業系統本身在通知的顯示上有很大的不同，而且針對同一個屬性也會有不同的行為模式：</p><ul><li>首先在 macOS 上，右邊的圖示是根據 <code>icon</code> 的設定顯示的，而非 <code>image</code>，但 Microsoft 就同時顯示了 <code>icon</code> 和 <code>image</code>。</li><li>再者，由於設定了 <code>requireInteraction</code>，所以當使用者沒有主動關閉中前 macOS 會將通知訊息疊加顯示，反之 Microsoft 並不會，要等到第一條通知被關閉後，第二條才會出現。</li></ul><p><br/><br/></p><h4 id="Notification-實體"><a href="#Notification-實體" class="headerlink" title="# Notification 實體"></a># Notification 實體</h4><p>如果我們在創建 Notification 時有將宣告在變數中，我們就可以取得 Notification 實體，並訪問它的相關屬性，而它的屬性其實就是當初在呼叫建構函式時所傳入的參數，像是這樣：</p><pre><code class="javascript">let notification = new Notification(&quot;這是一則通知&quot;, {  body: &quot;這是 Ｍax 的通知&quot;,  icon: &quot;./max.jpg&quot;,  data: { name: &quot;Max&quot; },  requireInteraction: true,});console.log(notification.title); // &quot;這是一則通知&quot;console.log(notification.body); // &quot;這是 Ｍax 的通知&quot;console.log(notification.data.name); // &quot;Max&quot;console.log(notification.requireInteraction); // true</code></pre><p>另外除了這些唯讀屬性外，我們還可以為通知綁定事件，而且事件的 Callback 也和其他事件一樣，可以接到一個 Event 物件，當中的 <code>event.target</code> 就會是被觸發事件的 Notification 實體。</p><p><strong>可監聽的事件有:</strong></p><ul><li><code>click</code>： 使用者點擊通知時觸發，關閉時的點擊不包含在內。</li><li><code>error</code>： 當通知發生錯誤時觸發。</li></ul><pre><code class="javascript">let notification = new Notification(&quot;這是一則通知&quot;, {  body: &quot;這是 Ｍax 的通知&quot;,  icon: &quot;./max.jpg&quot;,  data: { name: &quot;Max&quot; },  requireInteraction: true,});notification.addEventListener(&quot;click&quot;, function (event) {  console.log(event.target.data.name); // &quot;Max&quot;  // 打開頁面是一個常見的點擊事件行為  window.open(&quot;https://maxleebk.com/&quot;, &quot;_blank&quot;);});</code></pre><p><br/><br/></p><h4 id="Window-Notification-permission"><a href="#Window-Notification-permission" class="headerlink" title="# Window.Notification.permission"></a># Window.Notification.permission</h4><p>由於 Notification 算是一個有點打擾使用者的功能，所以使用前是需要取得授權的，而 Notification 這個建構函示（class）本身有提供 <code>permission</code> 這個靜態屬性讓我們確認授權的狀態。</p><p>當我們訪問 <code>permission</code> 時會讀取到一個表示授權狀態的字串，其值可能會是以下三種：</p><ul><li><code>&quot;granted&quot;</code>： 表示使用者允許網站的通知功能。</li><li><code>&quot;denied&quot;</code>： 表示使用者阻擋網站的通知功能，直到使用者主動到瀏覽器設定中開啟通知。</li><li><code>&quot;default&quot;</code>： 表示使用者對於通知功能還沒有明確的授權與否。</li></ul><pre><code class="javascript">if (!window.Notification) {  console.log(&quot;這個瀏覽器不支援 Notification&quot;);} else if (Notification.permission === &quot;granted&quot;) {  let notification = new Notification(&quot;這是一則通知&quot;);} else if (Notification.permission === &quot;denied&quot;) {  alert(&quot;建議您允許通知，以收到最新消息&quot;);}</code></pre><p><br/><br/></p><h4 id="Window-Notification-requestPermission"><a href="#Window-Notification-requestPermission" class="headerlink" title="# Window.Notification.requestPermission"></a># Window.Notification.requestPermission</h4><p>若是授權狀態為 <code>&quot;default&quot;</code>，那表示使用者並未對通知功能表示明確的答覆，這時候就需要我們使用 <code>requestPermission</code> 來詢問，它本身會再去確認一次授權狀態，若發現狀態為 <code>&quot;default&quot;</code> 就會跳出詢問授權的對話框，並且在使用者答覆之後利用 Promise 將結果丟給我們。</p><pre><code class="javascript">if (!window.Notification) {  console.log(&quot;這個瀏覽器不支援 Notification&quot;);} else if (Notification.permission === &quot;granted&quot;) {  let notification = new Notification(&quot;這是一則通知&quot;);} else if (Notification.permission === &quot;denied&quot;) {  alert(&quot;建議您允許通知，以收到最新消息&quot;);} else if (Notification.permission === &quot;default&quot;) {  Notification.requestPermission().then((result) =&gt; {    // result 相當於 Notification.permission    if (result === &quot;granted&quot;) {      let notification = new Notification(&quot;這是一則通知&quot;);    }  });}</code></pre><img src="pr.png" style="margin: 24px auto;" /><p>前面有說，其實 <code>requestPermission</code> 會自己再去確認一次狀態，如果為 <code>&quot;default&quot;</code> 才會詢問使用者，反之則會直接將授權狀態丟給我們，所以我們其實直接呼叫它就好，不一定要先透過 <code>permission</code> 來判斷。</p><pre><code class="javascript">Notification.requestPermission().then((result) =&gt; {  if (result === &quot;granted&quot;) {    let notification = new Notification(&quot;這是一則通知&quot;);  } else if (result === &quot;denied&quot;) {    alert(&quot;建議您允許通知，以收到最新消息&quot;);  }});</code></pre><p><br/><br/></p><p>以上就是 Notification API 的大致內容了，但就如開頭所說，其實它還是搭配 Service Worker 才會有更強大的效果，尤其是網站有提供訂閱服務的話，那它的幫助絕對是非常大的，不過至少今天我們已經知道如何發送通知了，未來如果有機會和後端配合也可以快速上手。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10281329" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;訂閱、分享、開啟小鈴鐺，才不會錯過通知喔～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;各位有沒有收過網站的通知呢？例如 Youtube 或 Netflix 的新片通知，或是 Facebook 的訊息通知等等…，這個其實就是今天要介紹的 Notifi
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / Share</title>
    <link href="https://maxleebk.com/2021/10/11/webApi/webApi-27/"/>
    <id>https://maxleebk.com/2021/10/11/webApi/webApi-27/</id>
    <published>2021-10-11T12:52:00.000Z</published>
    <updated>2023-01-12T00:54:39.006Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>與你分享的快樂，勝過獨自擁有</p></blockquote><p>現代人看到有趣的網頁、新聞、消息等等時，最常做的事情就是分享到社群帳號中，而現在社群軟體數不勝數，Facebook、LINE、Instagram、twitter…等等。</p><p>起初，只有在 Android 和 iOS 的 APP 中你可以呼叫 OS 系統的原生分享介面，一般網頁則還是得一個個處理各家社群軟體的分享機制，所以你往往會在網頁中看到一排社群軟體的 LOGO 用來分享到不同地方。不過現在瀏覽器也提供了 Share API 來呼叫原生的分享介面了。</p><hr><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>雖然網頁終於有 Share API 來讓我們呼叫系統原生的分享介面，不過它的支援度還不是非常完善，其中對「電腦瀏覽器」不僅支援度低，就算有支援，也並沒有提供社群網站的分享，提供的分享途徑非常不實用。</p><img src="os.png" style="margin: 24px auto;" /><p><strong>而對於電腦的低支援度，我認為可能有兩點原因：</strong></p><ul><li><p><strong>系統權限：</strong><br>由於行動裝置中的 APP 都是依照手機 OS（Android、iOS）的規範編寫，所以手機 OS 能有相應的權限來開啟「社群軟體」的分享功能。反之電腦 OS (Microsoft、macOS) 沒有任何權限去啟動「社群網頁」的分享功能。</p></li><li><p><strong>操作習慣：</strong><br>電腦使用者一般的的分享手段還是以網址分享為主，這樣的手段在電腦操作上是快速且方便的，而行動裝置對於同樣的操作是麻煩的，所以才需要原生分享的幫助。</p></li></ul><br/><p>隨然我們平常多以電腦的視角在開發網頁，不過為了加強行動裝置的使用體驗，Share API 還是有使用的需求性。</p><p><br/><br/></p><h4 id="Navigator-share"><a href="#Navigator-share" class="headerlink" title="# Navigator.share"></a># Navigator.share</h4><p>只要執行這個 method 就能啟用分享功能，不過需要注意幾個限制才能順利使用：</p><ul><li>最重要的當然是瀏覽器要支援</li><li>它必須經由使用者的操作／手勢觸發</li><li>網站必須要有 https 的協定</li></ul><br/><p>另外，呼叫 <code>navigator.share</code> 時還需要傳入一個參數，用來設定分享內容或檔案：</p><ul><li><strong>ShareData：</strong> 該參數需為一個物件，當中的所有屬性都是「可選的」，但必須至少有一項，可接受的屬性有以下：<ul><li>title: 一組字串，分享訊息的標題</li><li>text: 一組字串，分享訊息的描述</li><li>url: 一組字串，分享訊息要帶上的連結</li><li>files: 一組 <a href="https://developer.mozilla.org/en-US/docs/Web/API/File/File" target="_blank" rel="noopener">File 物件</a> 的陣列，會成為分享內容的附件</li></ul></li></ul><blockquote><p><strong>你需要注意</strong>： 不是每個瀏覽器都能辨識所有的屬性，若不能辨識時就會忽略。</p></blockquote><blockquote><p><strong>你需要注意</strong>： 就算瀏覽器能辨認，不同的分享途徑也可能會有不同的支援程度，例如臉書貼文就不支援 <code>files</code>，但 LINE、電子郵件就可以。</p></blockquote><pre><code class="javascript">const shareBtn = document.querySelector(&quot;.share&quot;);shareBtn.addEventListener(&quot;click&quot;, function () {  const file = new File([&quot;foo&quot;], &quot;foo.txt&quot;, { type: &quot;text/plain&quot; });  const shareData = {    title: &quot;分享功能&quot;,    text: &quot;測試分享功能&quot;,    url: &quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share&quot;,    files: [file],  };  if (navigator.share) {    // 有分享功能就分享    navigator      .share(shareData)      .then(() =&gt; alert(&quot;分享成功&quot;))      .catch((err) =&gt; alert(&quot;發生錯誤:&quot; + err));  } else {    // 沒有分享功能就複製網址到剪貼簿    navigator.clipboard      .writeText(location.href))      .then(() =&gt; alert(&quot;已複製網頁網址&quot;))      .catch(() =&gt; alert(&quot;複製失敗&quot;));  }});</code></pre><p>上方就是一個最基本的使用方式，利用 <code>click</code> 來觸發事件，並且先確認瀏覽器的 <code>navigator</code> 有 <code>share</code> 這個 method 才去執行，並且傳入一組 <code>ShareData</code> 物件，這樣只要有有支援的瀏覽器以及分享途徑就會開啟並根據 <code>ShareData</code> 來組合分享訊息。</p><p>要注意的是，<code>navigator.share</code> 會回傳一個 Promise，你可以利用 <code>then</code> 和 <code>catch</code> 來處理分享成功或失敗的後續動作。</p><img src="share.png" style="margin: 24px auto;" /><p><br/><br/></p><p>要是你希望網站有良好的傳遞性，非常建議使用 Share API，尤其是那些支援行動裝置瀏覽的網站。儘管現在手機上的瀏覽器 APP 已經有內建的分享選項，但最直覺的操作還是直接顯示在網頁中的分享按鈕。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10280875" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;與你分享的快樂，勝過獨自擁有&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;現代人看到有趣的網頁、新聞、消息等等時，最常做的事情就是分享到社群帳號中，而現在社群軟體數不勝數，Facebook、LINE、Instagram、twitter…等等。&lt;/p&gt;
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / 拖拉式待辦清單</title>
    <link href="https://maxleebk.com/2021/10/10/webApi/webApi-26/"/>
    <id>https://maxleebk.com/2021/10/10/webApi/webApi-26/</id>
    <published>2021-10-10T09:39:00.000Z</published>
    <updated>2023-01-12T00:54:38.983Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>就算拖拖拉拉，也可以把待辦事項處理好</p></blockquote><p>昨天雖然已經知道該如何使用 Drag &amp; Drop API 了，不過今天會實際用它來做個「拖拉式待辦清單」，用具體的範例來讓我們更加理解它的運用技巧。</p><hr><h2 id="設計概念"><a href="#設計概念" class="headerlink" title="設計概念"></a>設計概念</h2><br/><h4 id="確立需求與功能"><a href="#確立需求與功能" class="headerlink" title="# 確立需求與功能"></a># 確立需求與功能</h4><ol><li>既然是待辦清單，那自然要可以新增待辦事項</li><li>每項任務可以透過拖曳來進行狀態的更換（待處理、進行中、已完成）</li><li>每項任務可以透過拖曳來進行排序的調換</li><li>每項任務可以透過拖曳來進行刪除</li></ol><br/><h2 id="開始實踐"><a href="#開始實踐" class="headerlink" title="開始實踐"></a>開始實踐</h2><br/><p>由於主要是為了示範 Drag &amp; Drop，所以就不額外使用前端框架，並且也不進行資料的處理，完全使用 DOM 的增刪操作來完成作品，如果各位想要完善範例的話可以再自行採用更方便的技術。</p><p>首先準備好我們 ToDo List 的結構和樣式，大致上長成下面這樣，樣式部分各位可以各自發揮，這邊就不秀出完整 CSS 了。</p><pre><code class="html">&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&quot;column&quot;&gt;    &lt;div class=&quot;title todo&quot;&gt;待處理&lt;/div&gt;    &lt;div class=&quot;input-wrap&quot;&gt;      &lt;input type=&quot;text&quot; placeholder=&quot;＋ 新增事項&quot; /&gt;      &lt;button&gt;新增&lt;/button&gt;    &lt;/div&gt;    &lt;ol class=&quot;list&quot;&gt;&lt;/ol&gt;  &lt;/div&gt;  &lt;div class=&quot;column&quot;&gt;    &lt;div class=&quot;title handle&quot;&gt;進行中&lt;/div&gt;    &lt;ol class=&quot;list&quot;&gt;&lt;/ol&gt;  &lt;/div&gt;  &lt;div class=&quot;column&quot;&gt;    &lt;div class=&quot;title complete&quot;&gt;已完成&lt;/div&gt;    &lt;ol class=&quot;list&quot;&gt;&lt;/ol&gt;  &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;delete&quot;&gt;刪除&lt;/div&gt;</code></pre><img src="layout.png" style="margin: 24px auto;" /><br/><h4 id="新增代辦任務"><a href="#新增代辦任務" class="headerlink" title="# 新增代辦任務"></a># 新增代辦任務</h4><p>首先我們先來透過 <code>&lt;input&gt;</code> 和 <code>&lt;button&gt;</code> 來完成「新增任務」的功能，透過點擊按鈕或按下 Enter 就會執行 <code>createToDo</code> 函式，用來創造一個 <code>li</code> 元素，並加上屬性及文字後丟掉「待處理」的 <code>ol</code> 中。</p><pre><code class="javascript">const input = document.querySelector(&quot;input&quot;);const button = document.querySelector(&quot;button&quot;);const todoList = input.parentElement.nextElementSibling;function createToDo(content) {  const newItem = document.createElement(&quot;li&quot;);  newItem.classList.add(&quot;item&quot;);  // 記得要加上 draggable，這樣任務才可以拖曳  newItem.setAttribute(&quot;draggable&quot;, true);  newItem.textContent = content;  todoList.appendChild(newItem);  input.value = &quot;&quot;;}input.addEventListener(&quot;keydown&quot;, (e) =&gt; {  if (!input.value.trim() || e.which !== 13) return;  createToDo(input.value);});button.addEventListener(&quot;click&quot;, () =&gt; {  if (!input.value.trim()) return;  createToDo(input.value);});</code></pre><img src="add.gif" style="margin: 24px auto;" /><p><br/><br/></p><h4 id="拖曳以改變任務狀態"><a href="#拖曳以改變任務狀態" class="headerlink" title="# 拖曳以改變任務狀態"></a># 拖曳以改變任務狀態</h4><p>接著我們要讓任務可以進行「拖曳」，且三個不同的區塊都要可以「被放置」任務，也就是 Drag &amp; Drop API 的部分了，分別把 Drag Source 和 Drop Location 監聽事件的流程包裝成函式，然後在新增任務時把元素加上 <code>drag</code> 相關事件，以及為三個狀態區塊加上 <code>drop</code> 相關事件。</p><pre><code class="javascript">// 用來暫存被 drag 的元素let source = null;function addDragEvt(element) {  element.addEventListener(&quot;dragstart&quot;, (e) =&gt; {    e.target.classList.add(&quot;dragging&quot;);    source = e.target;  });  element.addEventListener(&quot;dragend&quot;, (e) =&gt; {    e.target.classList.remove(&quot;dragging&quot;);    source = null;  });}function createToDo(content) {  // ...前面省略  // 記得在 createToDo 中加入這一行來為新增的 li 監聽事件  addDragEvt(newItem);  todoList.appendChild(newItem);  input.value = &quot;&quot;;}</code></pre><pre><code class="javascript">function addDropEvt(element) {  element.addEventListener(&quot;dragover&quot;, (e) =&gt; {    e.preventDefault();  });  element.addEventListener(&quot;drop&quot;, (e) =&gt; {    e.currentTarget.querySelector(&quot;ol&quot;).appendChild(source);  });}const columns = document.querySelectorAll(&quot;.column&quot;);columns.forEach((column) =&gt; {  addDropEvt(column);});</code></pre><img src="drag.gif" style="margin: 24px auto;" /><p><br/><br/></p><h4 id="拖曳以改變任務排序"><a href="#拖曳以改變任務排序" class="headerlink" title="# 拖曳以改變任務排序"></a># 拖曳以改變任務排序</h4><p>現在各項任務已經可以通過拖曳放置在不同狀態的區塊了，現在要來處理排序問題了，我們可以先透過 <code>dragover</code> 事件來取得鼠標的位置，得以判斷使用者想要把項目放在哪一個位置，並且利用樣式的改變讓使用者能更清楚知道他放開滑鼠後，任務會被加在哪裡：</p><pre><code class="css">.item {  position: relative;}.item::before,.item::after {  content: &quot;&quot;;  position: absolute;  display: block;  width: 100%;  height: 4px;  background: lightblue;  opacity: 0;}.item.before::before {  top: -2px;  left: 0;  opacity: 1;}.item.after::after {  bottom: -2px;  left: 0;  opacity: 1;}</code></pre><pre><code class="javascript">// 用來暫存被 dragover 的元素let overItem = null;// 重置被 dragover 的元素function clearOverItem() {  if (!overItem) return;  overItem.classList.remove(&quot;before&quot;);  overItem.classList.remove(&quot;after&quot;);  overItem = null;}function addDropEvt(element) {  element.addEventListener(&quot;dragover&quot;, (e) =&gt; {    clearOverItem();    // 如果 dragover 的元素也是任務項目且不是目前被 drag 的 source 時執行    if (e.target.getAttribute(&quot;draggable&quot;) &amp;&amp; e.target !== source) {      overItem = e.target;      if (e.offsetY &gt; overItem.offsetHeight / 2) {        // 如果鼠標在元素的下半部顯示下方的藍條        overItem.classList.add(&quot;after&quot;);      } else {        // 反之，顯示上方的藍條        overItem.classList.add(&quot;before&quot;);      }    }    e.preventDefault();  });  //...以下省略}</code></pre><img src="sort.gif" style="margin: 24px auto;" /><p>接著我們只要在修改一下 <code>drop</code> 事件，在當中判斷目前被 <code>dragover</code> 元素的狀態就可以放到對應的位置了：</p><pre><code class="javascript">function addDropEvt(element) {  //...以上省略  element.addEventListener(&quot;drop&quot;, (e) =&gt; {    const list = e.currentTarget.querySelector(&quot;ol&quot;);    if (overItem) {      if (overItem.classList.contains(&quot;before&quot;)) {        // 如果 overItem 有 before class 就將 source 移動到它的前面        list.insertBefore(source, overItem);      } else {        // 反之，有 after class 就將 source 移動到它的後面        list.insertBefore(source, overItem.nextElementSibling);      }    } else {      // 如果沒有 overItem 也沒有更換狀態就不動作      if (e.currentTarget.contains(source)) return;      // 反之，加到最後面      else list.appendChild(source);    }    clearOverItem();  });}</code></pre><img src="done.gif" style="margin: 24px auto;" /><p><br/><br/></p><h4 id="拖曳以刪除任務"><a href="#拖曳以刪除任務" class="headerlink" title="# 拖曳以刪除任務"></a># 拖曳以刪除任務</h4><p>最後在把刪除的功能給補上，這樣一切就大功告成了。</p><pre><code class="javascript">const del = document.querySelector(&quot;.delete&quot;);del.addEventListener(&quot;dragover&quot;, (e) =&gt; {  e.preventDefault();});del.addEventListener(&quot;drop&quot;, (e) =&gt; {  source.remove();  clearOverItem();});</code></pre><p><br/><br/></p><p>整個範例做完後，希望各位對於 Drag &amp; Drop API 能有更深更具體的認識，如果你在動手做之前想先試玩看看的話，我把原始碼放在 <a href="https://codepen.io/max-lee/pen/rNzNXOX" target="_blank" rel="noopener">CodePen</a> 囉，如果文章中的說明看不是很懂的話，也可以在 CodePen 看看，有任何問題或建議也好歡迎各位提出～</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10280490" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;就算拖拖拉拉，也可以把待辦事項處理好&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;昨天雖然已經知道該如何使用 Drag &amp;amp; Drop API 了，不過今天會實際用它來做個「拖拉式待辦清單」，用具體的範例來讓我們更加理解它的運用技巧。&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / Drag &amp; Drop</title>
    <link href="https://maxleebk.com/2021/10/09/webApi/webApi-25/"/>
    <id>https://maxleebk.com/2021/10/09/webApi/webApi-25/</id>
    <published>2021-10-09T13:19:00.000Z</published>
    <updated>2023-01-12T00:54:38.979Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>就是要拖拖拉拉</p></blockquote><p>現在使用手機、平板來瀏覽網站的機會比起電腦來說，實在是多太多了，所以其實 Web API 也不斷針對這樣的趨勢在靠攏，像是我們前期介紹的 Battery API 就是一個案例。</p><p>使用者在長期使用行動裝置的情況下，已經習慣了系統 OS 或 APP 的操作，所以對於「拖曳物件」這個手勢動作已經是直覺反應了，而在網站開發中，Drag &amp; Drop API 就是協助我們完成「拖曳」功能的好幫手。</p><hr><h2 id="Drag-amp-Drop"><a href="#Drag-amp-Drop" class="headerlink" title="Drag &amp; Drop"></a>Drag &amp; Drop</h2><p>Drag &amp; Drop 其實是「拖」和「放」兩個動作，也就是除了「拖曳」元素外，也可以將其「放置」在特定位置。這也代表說整個過程中會與使用者交互的元素不只有一個，會發生的事件也不只有一個，在拖放的過程中至少會有兩個角色，各自也都有對應的事件：</p><br/><ul><li><strong>Drag Source</strong>： 被使用者點擊不放並「拖曳」的目標元素。</li></ul><table><thead><tr><th align="center">事件</th><th align="center">說明</th></tr></thead><tbody><tr><td align="center">dragstart</td><td align="center">當使用者<strong>開始</strong>拖曳時觸發（滑鼠開始移動時）</td></tr><tr><td align="center">drag</td><td align="center">開始拖曳到結束拖曳前都會不斷觸發（約幾百毫秒觸發一次）</td></tr><tr><td align="center">dragend</td><td align="center">當使用者<strong>結束</strong>拖曳時觸發（滑鼠按鍵放開時）</td></tr></tbody></table><br/><ul><li><strong>Drop Location</strong>： 一個可以「放置」 <code>drag source</code> 的元素。</li></ul><table><thead><tr><th align="center">事件</th><th align="center">說明</th></tr></thead><tbody><tr><td align="center">dragenter</td><td align="center">當使用者拖曳期間<strong>進入</strong>元素時觸發</td></tr><tr><td align="center">dragover</td><td align="center">當使用者拖曳期間<strong>經過</strong>元素時觸發（約幾百毫秒觸發一次）</td></tr><tr><td align="center">dragleave</td><td align="center">當使用者拖曳期間<strong>離開</strong>元素時觸發</td></tr><tr><td align="center">drop</td><td align="center">當使用者將拖曳的目標<strong>放置</strong>在元素時觸發</td></tr></tbody></table><p><br/><br/></p><h4 id="Attribute-draggable"><a href="#Attribute-draggable" class="headerlink" title="# Attribute:draggable"></a># Attribute:draggable</h4><p>通常來說，按住元素不放也是沒辦法拖曳的，若要使其可以拖曳必須要在 HTML 標籤上加入 <code>draggable</code> 屬性：</p><pre><code class="html">&lt;div class=&quot;box&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;</code></pre><blockquote><p>Drop Location 則不用額外添加屬性，任何元素都可以是 Drop Location。</p></blockquote><p><br/><br/></p><h4 id="交互事件"><a href="#交互事件" class="headerlink" title="# 交互事件"></a># 交互事件</h4><p>由於前面的表格已經大致說明了各個事件的觸發時機了，應該也都不難離解，所以我們就直接試試看能夠利用事件做些什麼效果，以及 Drag Source 和 Drop Location 之間該怎麼互動。</p><br/><p><strong>- 樣式改變</strong></p><p>我們可以利用 <code>dragstart</code> 和 <code>dragend</code> 來改變 Drag Source 的樣式，讓使用者能更清楚目前被拖曳的元素是哪一個，以及利用 <code>dragenter</code> 和 <code>dragleave</code> 來改變 Drop Location 的樣式：</p><pre><code class="html">&lt;div class=&quot;container&quot;&gt;  &lt;div class=&quot;box&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;box&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;box&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;container&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="css">.container {  background: white;}.container.hover {  background: aliceBlue;}.box {  background: lightblue;  cursor: grab;}.box.dragging {  background: lightgreen;  cursor: grabbing;}</code></pre><pre><code class="javascript">const boxes = document.querySelectorAll(&quot;.box&quot;);boxes.forEach((box) =&gt; {  box.addEventListener(&quot;dragstart&quot;, (e) =&gt; {    e.target.classList.add(&quot;dragging&quot;);  });  box.addEventListener(&quot;dragend&quot;, (e) =&gt; {    e.target.classList.remove(&quot;dragging&quot;);  });});const containers = document.querySelectorAll(&quot;.container&quot;);containers.forEach((container) =&gt; {  container.addEventListener(&quot;dragenter&quot;, (e) =&gt; {    e.target.classList.add(&quot;hover&quot;);  });  container.addEventListener(&quot;dragleave&quot;, (e) =&gt; {    e.target.classList.remove(&quot;hover&quot;);  });});</code></pre><br/><p><strong>- 鼠標位置</strong></p><p>由於 <code>drag</code> 和 <code>dragover</code> 都是不斷觸發的事件，所以我們可以用來追蹤使用者游標的位置：</p><pre><code class="javascript">const boxes = document.querySelectorAll(&quot;.box&quot;);boxes.forEach((box) =&gt; {  box.addEventListener(&quot;drag&quot;, (e) =&gt; {    console.log(`滑鼠在視窗中的座標: ${e.clientX} / ${e.clientY}`);  });});const containers = document.querySelectorAll(&quot;.container&quot;);containers.forEach((container) =&gt; {  container.addEventListener(&quot;dragover&quot;, (e) =&gt; {    console.log(`滑鼠在 Drop Location 中的座標: ${e.offsetX} / ${e.offsetY}`);  });});</code></pre><br/><p><strong>- 移動元素</strong></p><p>最後只要搭配上 <code>drop</code> 事件，我們就可以達成移動元素的效果，不過有個要注意的事情是 <code>dragover</code> 和 <code>drop</code> 會有執行上的衝突，所以如果要讓 <code>drop</code> 的 Callback 能夠順利觸發，必須要在 <code>dragover</code> 中將預設行為給取消掉：</p><pre><code class="javascript">let source = null;const boxes = document.querySelectorAll(&quot;.box&quot;);boxes.forEach((box) =&gt; {  box.addEventListener(&quot;dragstart&quot;, (e) =&gt; {    source = e.target;  box.addEventListener(&quot;dragend&quot;, (e) =&gt; {    source = null;  });});const containers = document.querySelectorAll(&quot;.container&quot;);containers.forEach((container) =&gt; {  container.addEventListener(&quot;dragover&quot;, (e) =&gt; {    e.preventDefault();  });  container.addEventListener(&quot;drop&quot;, (e) =&gt; {    e.target.appendChild(source)    e.target.classList.remove(&quot;hover&quot;);  });});</code></pre><img src="move.gif" style="margin: 24px auto;" /><p><br/><br/></p><p>看過以上示範後是不是覺得 Drag &amp; Drop API 還蠻簡單的呢？只要先設定好需要拖曳的元素後，透過幾個事件的交互就可以達到這樣的效果。不過其實很多 API 都是這樣的，使用起來都很容易，但實際上要應用時就容易邏輯卡住，所以為了讓各位能對 Drag &amp; Drop 有更具體的印象，明天就來實際寫一個拖拉的 ToDo List 吧！</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10280217" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;就是要拖拖拉拉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;現在使用手機、平板來瀏覽網站的機會比起電腦來說，實在是多太多了，所以其實 Web API 也不斷針對這樣的趨勢在靠攏，像是我們前期介紹的 Battery API 就是一個案例。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / ScrollIntoView</title>
    <link href="https://maxleebk.com/2021/10/07/webApi/webApi-24/"/>
    <id>https://maxleebk.com/2021/10/07/webApi/webApi-24/</id>
    <published>2021-10-07T08:47:00.000Z</published>
    <updated>2023-01-12T00:54:38.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>將元素玩弄與指尖，說來就來，呼風喚雨</p></blockquote><p>既然有 IntersectionObserver 能夠偵測元素是否進入視窗中，那當然也會有 API 能夠主動讓元素進入到我們的視野當中，第一時間，各位可能有想到 <code>window.scrollTo</code> 來指定「捲軸」的滾動距離，但其實今天介紹的 ScrollIntoView 能夠更方便的做到這件事。</p><hr><h2 id="ScrollIntoView"><a href="#ScrollIntoView" class="headerlink" title="ScrollIntoView"></a>ScrollIntoView</h2><p>說到操作「捲軸」這件事，最常使用的可能會是 <code>window.scrollTo</code> 或 <code>window.scrollBy</code>，可以讓視窗動到任何位置，例如「回到頂部」功能就會使用 <code>scrollTo(0,0)</code> 來完成，不過如果是希望捲軸移動到某個指定元素的位置，那就還需要先計算元素之於文件頂部的距離才能做到，這時候反而運用 ScrollIntoView 就可以輕輕鬆鬆解決。</p><br/><h4 id="Element-scrollIntoView"><a href="#Element-scrollIntoView" class="headerlink" title="# Element.scrollIntoView"></a># Element.scrollIntoView</h4><p><code>scrollIntoView</code> 並不隸屬於 Window，反而是 Element 的 method，而執行 <code>scrollIntoView</code> 就會是需要進入視窗中的目標元素。</p><pre><code class="javascript">const element = document.getElementById(&quot;box&quot;);window.addEventListener(&quot;click&quot;, function () {  element.scrollIntoView();});</code></pre><img src="intoView.gif" style="max-width: 600px; margin: 24px auto;" /><p>呼叫之後，視窗捲軸就會直接 <strong>「跳」</strong> 到 <strong>「元素頂部對齊視窗頂部」</strong> 的距離，而其實我們可以傳入參數來調整捲軸移動的方式與位置，可以接收的參數形式有兩種：</p><br/><ul><li><p><strong>alignToTop</strong>： 第一種是傳入布林值，這個布林值會決定是否要讓「捲軸位置」剛好讓元素頂部對齊視窗頂部。</p></li><li><p><strong>scrollIntoViewOptions</strong>： 第二種是傳入物件，這物件當中可以有三個屬性來調整更細節的捲動設定：</p><ul><li><code>behavior</code>： 這個屬性接受 <code>auto</code>、<code>smooth</code> 兩個值，決定了捲軸的移動方式要用「跳」的還是用「滑」的。預設為 <code>auto</code> 跳的</li><li><code>block</code>： 這個屬性決定了垂直捲軸的位置，接受 <code>start</code>、<code>center</code>、<code>end</code> 和 <code>nearest</code> 四種。預設為 <code>start</code></li><li><code>inline</code>： 這個屬性則決定水平捲軸的位置，也是 <code>start</code>、<code>center</code>、<code>end</code> 和 <code>nearest</code> 四種。預設為 <code>nearest</code></li></ul></li></ul><p>其中 <code>start</code> 代表對齊垂直捲軸的頂部、水平卷軸的左側，<code>end</code> 對齊垂直底部、水平右側，<code>center</code> 自然就是對齊中心點，而 <code>nearest</code> 則是依據元素當下位置來判斷最近的位置來對齊</p><pre><code class="javascript">element.scrollIntoView();element.scrollIntoView(true);element.scrollIntoView(false);element.scrollIntoView({ block: &quot;end&quot; });element.scrollIntoView({  behavior: &quot;smooth&quot;,  block: &quot;center&quot;,  inline: &quot;nearest&quot;,});</code></pre><img src="align.png" style="margin: 24px auto;" /><p>另外如果目標元素被放在其他也有「捲軸」的元素中，那它會將每一層的捲軸都進行滾動，並且盡可能的達成我們指定的位置，會說「盡可能」是因為未必視窗會有垂直或水平捲軸，若沒有捲軸，ScrollIntoView 也是無能為力的。</p><pre><code class="html">&lt;div class=&quot;wrap&quot;&gt;  &lt;div class=&quot;placeholder&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;target&quot;&gt;&lt;/div&gt;  &lt;div class=&quot;placeholder&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="javascript">const target = document.querySelector(&quot;.target&quot;);target.scrollIntoView({  behavior: &quot;smooth&quot;,  block: &quot;start&quot;,  inline: &quot;end&quot;,});</code></pre><img src="move.gif" style="max-width: 600px; margin: 24px auto;" /><p><br/><br/></p><p>不曉得有沒有人有發現其實 ScrollIntoView 的功能很像 HTML 中 <code>&lt;a&gt;</code> 標籤的錨點（Anchor Link）功能，所以這也是為什麼 ScrollIntoView 可能比較少用的原因，但其實錨點連結並不能實踐 <code>smooth</code> 滑動效果，也不能指定位置，所以如果你想讓 UI/UX 的體驗好一點，其實 ScrollIntoView 是更好的選擇喔。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10279669" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;將元素玩弄與指尖，說來就來，呼風喚雨&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然有 IntersectionObserver 能夠偵測元素是否進入視窗中，那當然也會有 API 能夠主動讓元素進入到我們的視野當中，第一時間，各位可能有想到 &lt;co
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / Animation On Scroll</title>
    <link href="https://maxleebk.com/2021/10/06/webApi/webApi-23/"/>
    <id>https://maxleebk.com/2021/10/06/webApi/webApi-23/</id>
    <published>2021-10-06T14:35:00.000Z</published>
    <updated>2023-01-12T00:54:38.963Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>學以致用是最快樂的事情</p></blockquote><p>昨天我們認識了 IntersectionObserver，知道它可以偵測到元素進入畫面的時機，而這個特性非常適合用來製作 Animation On Scroll 的捲動動畫效果，像是 <a href="https://michalsnik.github.io/aos/" target="_blank" rel="noopener">AOS</a> 就是一個很經典的套件，雖然 AOS 其實不是用 IntersectionObserver 實踐的，但我們可以嘗試做出類似效果的工具。</p><hr><h2 id="設計概念"><a href="#設計概念" class="headerlink" title="設計概念"></a>設計概念</h2><br/><h4 id="確立需求與功能"><a href="#確立需求與功能" class="headerlink" title="# 確立需求與功能"></a># 確立需求與功能</h4><ol><li>既然是工具，就代表要幫我們簡化一些繁複的動作</li><li>這個工具需要在元素進入可視窗口時，進行指定樣式的變化</li><li>除了樣式變化，還希望可以設定 Callback，讓我們做一些額外的操作</li></ol><p><br/><br/></p><h4 id="機制規劃與設計"><a href="#機制規劃與設計" class="headerlink" title="# 機制規劃與設計"></a># 機制規劃與設計</h4><p><strong>1. 既然是工具，就代表要幫我們簡化一些繁複的動作</strong><br>在使用 IntersectionObserver 時，總是要進行的動作就是要建立實體然後註冊目標元素，我希望可以只用一個指令就處理完這些事。這個需求應該可以包裝一個「建構函式」來處理。</p><br/><p><strong>2. 這個工具需要偵測到元素進入可視窗口時，進行指定樣式的變化</strong><br>偵測元素的部分 IntersectionObserver 會幫我們處理，而元素的樣式變化最快的方式就是利用 <code>class</code> 的增減了，但用 <code>class</code> 可能會有撞名的風險，所以我們改用 <code>data-*</code> 屬性好了。而且改變屬性這件事應該由工具處理，而不是我們都要寫一遍。</p><br/><p><strong>3. 除了樣式變化，還希望可以設定 Callback，讓我們做一些額外的操作</strong><br>由於在第一點已經決定設計一個「建構函式」來幫我們創建 IntersectionObserver 實體，那原本在創建時該傳入的 Callback Function 和 options 物件就必須要先提供給「建構函式」，它才能幫我們建立實體。</p><p><br/><br/></p><h2 id="開始實踐"><a href="#開始實踐" class="headerlink" title="開始實踐"></a>開始實踐</h2><br/><h4 id="元素的樣式變換機制"><a href="#元素的樣式變換機制" class="headerlink" title="# 元素的樣式變換機制"></a># 元素的樣式變換機制</h4><p>整理完需求及機制後，就來開始動手吧，首先是為了讓元素可以透過 <code>data-*</code> 屬性的變化來轉換樣式，所以為想要有動畫效果的元素加上 <code>data-appear=&quot;hide&quot;</code>，表示元素還沒進入畫面，未來只要把 <code>data-appear</code> 改成 <code>show</code> ，元素就會有樣式的變化。</p><pre><code class="html">&lt;div class=&quot;box&quot; data-appear=&quot;hide&quot;&gt;&lt;/div&gt;</code></pre><pre><code class="css">.box {  width: 500px;  height: 500px;  transition: 0.3s;}.box[data-appear=&quot;hide&quot;] {  background: white;}.box[data-appear=&quot;show&quot;] {  background: pink;}</code></pre><p><br/><br/></p><h4 id="自動建立實體與註冊元素"><a href="#自動建立實體與註冊元素" class="headerlink" title="# 自動建立實體與註冊元素"></a># 自動建立實體與註冊元素</h4><p>再來程式部分，先宣告一個叫做 <code>Appear</code> 建構函式，其中會有一個函式 <code>init</code>，要用來創建 IntersectionObserver 實體以及註冊要觀察的元素，未來只要執行 <code>appear.init()</code> 一行就搞定了，而且因為已經確定只要有 <code>data-appear</code> 屬性的元素就是要觀察的對象，所以直接全部抓出來註冊即可。</p><pre><code class="javascript">const Appear = function () {  this.init = function (callback, options) {    this.observer = new IntersectionObserver(callback, options);    const container = options.root || document;    const targetList = container.querySelectorAll(&quot;[data-appear]&quot;);    targetList.forEach((el) =&gt; {      this.observer.observe(el);    });  };};const appear = new Appear();</code></pre><p><br/><br/></p><h4 id="Callback-包裝與元素屬性切換"><a href="#Callback-包裝與元素屬性切換" class="headerlink" title="# Callback 包裝與元素屬性切換"></a># Callback 包裝與元素屬性切換</h4><p>前面有說，工具需要自動改變元素的 <code>data-appear</code> 屬性，而不是由我們手動寫在 Callback 中，所以看來傳入 <code>init</code> 的 <code>callback</code> 參數不能直接放到 IntersectionObserver 中，需要另外在包裝一次。</p><p>包裝後的 Callback 就可以在元素進出畫面時進行 <code>data-appear</code> 屬性的調整了，另外我們也將 <code>entry.target</code> 和改變後的狀態傳進 <code>init</code> 的 <code>callback</code> 中，讓使用工具的人可以取得額外資訊。</p><pre><code class="javascript">const Appear = function () {  this.init = function (callback, options) {    // IntersectionObserver 要觸發的 Callback Function    const obCallback = function (entries) {      entries.forEach((entry) =&gt; {        // 取得元素進入當下的狀態        let state = entry.target.getAttribute(&quot;data-appear&quot;);        if (state === &quot;hide&quot; &amp;&amp; entry.isIntersecting) {          // 從 hide 的狀態下進到畫面時...          state = &quot;show&quot;;          entry.target.setAttribute(&quot;data-appear&quot;, state);          callback(entry.target, state);        } else if (state === &quot;show&quot; &amp;&amp; !entry.isIntersecting) {          // 從 show 的狀態下離開畫面時...          state = &quot;hide&quot;;          entry.target.setAttribute(&quot;data-appear&quot;, state);          callback(entry.target, state);        }      });    };    this.observer = new IntersectionObserver(obCallback, options);    const container = options.root || document;    const targetList = container.querySelectorAll(&quot;[data-appear]&quot;);    targetList.forEach((el) =&gt; {      this.observer.observe(el);    });  };};const appear = new Appear();</code></pre><p><br/><br/></p><h4 id="自定義的函式參數"><a href="#自定義的函式參數" class="headerlink" title="# 自定義的函式參數"></a># 自定義的函式參數</h4><p>再來其實我覺得原本 IntersectionObserver 的 <code>options</code> 參數設定有點不是很容易懂，所以我們自己設計一個新的物件做為 <code>init</code> 的參數設定，以下是它的屬性名稱及預設值，順便也把 <code>callback</code> 一起放進去了：</p><pre><code class="javascript">const defaultOptions = {  container: null,  offsetTop: 0,  offsetRight: 0,  offsetBottom: 0,  offsetLeft: 0,  threshold: 0,  callback: function () {},};</code></pre><p>這樣在使用工具的人只要傳一個參數到 <code>init</code> 中就好，而且屬性名稱也比較好了解，傳進去後只要在 <code>init</code> 內部再轉換成原本 IntersectionObserver 接受的格式即可。</p><pre><code class="javascript">const Appear = function () {  this.init = function (userOptions) {    const options = { ...defaultOptions, ...userOptions };    const obOptions = {      root: options.container,      rootMargin: [        `${options.offsetTop}px`,        `${options.offsetRight}px`,        `${options.offsetBottom}px`,        `${options.offsetLeft}px`,      ].join(&quot; &quot;),      threshold: options.threshold,    };    //...其他省略    this.observer = new IntersectionObserver(obCallback, obOptions);  };};const appear = new Appear();</code></pre><p><br/><br/></p><h4 id="防呆機制與註銷"><a href="#防呆機制與註銷" class="headerlink" title="# 防呆機制與註銷"></a># 防呆機制與註銷</h4><p>最後為了避免有人重複執行 <code>init</code>，我們在最前面進行判斷來阻擋，額外也可以再做一個關閉 IntersectionObserver 的功能：</p><pre><code class="javascript">const Appear = function () {  this.init = function (userOptions) {    if (this.observer) return;    //...其他省略  };  // 註銷所有觀察元素並釋放 observer  this.destroy = function () {    if (!this.observer) return;    this.observer.disconnect();    this.observer = null;  };};const appear = new Appear();</code></pre><p><br/><br/></p><h2 id="實際使用"><a href="#實際使用" class="headerlink" title="實際使用"></a>實際使用</h2><p>以上的 JS 程式碼我們可以包成一支 <code>appear.js</code> 檔案，只要未來有專案需要使用時直接引入並且呼叫 <code>init</code> 就可以了：</p><pre><code class="html">&lt;style&gt;  .box {    width: 500px;    height: 500px;    margin: 30px auto;    transition: 0.3s;  }  .box[data-appear=&quot;hide&quot;] {    background: white;  }  .box[data-appear=&quot;show&quot;] {    background: pink;  }&lt;/style&gt;&lt;div class=&quot;box&quot; data-appear=&quot;hide&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot; data-appear=&quot;hide&quot;&gt;&lt;/div&gt;&lt;div class=&quot;box&quot; data-appear=&quot;hide&quot;&gt;&lt;/div&gt;&lt;script src=&quot;appear.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  appear.init({    threshold: 0.5,    callback: function (target, state) {      console.log(target, state);    },  });&lt;/script&gt;</code></pre><img src="result.gif" style="max-width: 800px; margin: 24px auto;" /><p><br/><br/></p><p>這樣的工具是不是非常實用呢？而且能夠自己做出一個以後也能夠不斷使用的小套件真的是非常有成就感，有興趣的小夥伴們也可以發揮自己的創新，把這個小工具不斷的擴充，增加新功能喔。完整原始碼，我就放在 CodePen，文章中如果有不清楚的，可以再去看看。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10279479" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;學以致用是最快樂的事情&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;昨天我們認識了 IntersectionObserver，知道它可以偵測到元素進入畫面的時機，而這個特性非常適合用來製作 Animation On Scroll 的捲動動畫效果，像是
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / IntersectionObserver</title>
    <link href="https://maxleebk.com/2021/10/05/webApi/webApi-22/"/>
    <id>https://maxleebk.com/2021/10/05/webApi/webApi-22/</id>
    <published>2021-10-05T12:11:00.000Z</published>
    <updated>2023-01-12T00:54:38.939Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>當你進入我的眼簾，我們的命運就有了交集～</p></blockquote><p>看到 Observer，應該就知道今天要介紹的又是「觀察者」系列的 API 了，而且這次的觀察者可能比前面的 MutationObserver 和 ResizeObserver 還要實用。只要有了它，Scroll Animation 就只是一塊小蛋糕了。</p><hr><h2 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h2><p>IntersectionObserver 幫我們觀察的是元素的「相交（intersect）」變動，也就是元素與指定可視窗口的「相交與否」發生變動時觸發。</p><p>簡單來說就是頁面元素因捲動而進入到可視範圍中，或是離開了可視範圍時，IntersectionObserver 就會執行指定任務，所以我們可以利用它來偵測「某個元素是不是進入視窗中」了，而且還可以調整許多細微的偵測設定，相當強大。</p><img src="inter.gif" style="max-width: 600px; margin: 24px auto;" /><br/><h4 id="Window-IntersectionObserver"><a href="#Window-IntersectionObserver" class="headerlink" title="# Window.IntersectionObserver"></a># Window.IntersectionObserver</h4><p>和其他「觀察者」一樣，<code>IntersectionObserver</code> 為一個建構函示，需要使用 <code>new</code> 關鍵字來創建實體，並且需要傳入 Callback Function 作為參數，該 Callback 會獲得一個存放 IntersectionObserverEntry 的陣列以及「觀察者（observer）」自身實體，</p><br/><ul><li><strong>IntersectionObserverEntry</strong>： 其中會有一些關於觀測元素與可視範圍交互的相關資訊，後面會詳細介紹。</li><li><strong>IntersectionObserver</strong>： 呼叫 Callback 的 IntersectionObserver 實體，即為該 Function 的 <code>this</code>。</li></ul><br/><pre><code class="javascript">const observer = new IntersectionObserver((entries, owner) =&gt; {  console.log(owner); // IntersectionObserver 實體  entries.forEach((entry) =&gt; {    console.log(entry); // IntersectionObserverEntry 物件  });});</code></pre><br/><p>另外，IntersectionObserver 除了 Callback 之外還有一個可選的 <code>options</code> 參數可以設定：</p><pre><code class="javascript">const callback = function (entries) {  console.log(entries);};const observer = new IntersectionObserver(callback, {  root: null,  rootMargin: &quot;0px 0px 0px 0px&quot;,  threshold: 0.0,});</code></pre><br/><p>這個 <code>options</code> 參數須為物件，並接受上面這三個屬性：</p><ul><li><strong>root</strong>： 這個屬性將決定要以哪個元素的可視窗口作為觀察依據，預設為 <code>null</code>，表示以 Viewport 作為判斷依據，也可以設定成其他元素。</li><li><strong>rootMargin</strong>： 這個屬性決定的是窗口的縮放，設定規則和 CSS 的 <code>margin</code>，可以給定一個值，也可以四邊各自設定，正值為外擴，負值為內縮。</li><li><strong>threshold</strong>： 這個屬性是設定觸發的<strong>比例門檻</strong>，當目標元素與可視範圍的相交範圍「經過」了這道門檻，Callback 就會被觸發，舉例來說：<ul><li>預設值 <code>0</code>： 當相交範圍的比例「開始大於 0%」或「開始小於 0%」 的瞬間會觸發。</li><li>設定為 <code>1</code>： 當相交範圍的比例「開始大於 100%」或「開始小於 100%」 的瞬間會觸發。</li><li>設定成陣列 <code>[0, 0.5, 1]</code>： 規則如上，但目標元素就會有三個觸發時機。</li></ul></li></ul><img src="options2.png" style="margin: 24px auto;" /><p><br/><br/></p><h4 id="IntersectionObserver-observe"><a href="#IntersectionObserver-observe" class="headerlink" title="# IntersectionObserver.observe"></a># IntersectionObserver.observe</h4><p>老樣子，觀察者們都需要我們使用 <code>observe</code> method 來指定觀察對象：</p><pre><code class="javascript">const observer = new IntersectionObserver((entries) =&gt; {  console.log(entries);});const div = document.querySelector(&quot;div&quot;);observer.observe(div);</code></pre><p><br/><br/></p><h4 id="IntersectionObserver-unobserve"><a href="#IntersectionObserver-unobserve" class="headerlink" title="# IntersectionObserver.unobserve"></a># IntersectionObserver.unobserve</h4><p>若要註銷某元素的觀察，IntersectionObserver 一樣有 <code>unobserve</code> method 可以使用：</p><pre><code class="javascript">const observer = new IntersectionObserver((entries) =&gt; {  console.log(entries);});const div = document.querySelector(&quot;div&quot;);observer.observe(div);observer.unobserve(div);</code></pre><p><br/><br/></p><h4 id="IntersectionObserver-disconnect"><a href="#IntersectionObserver-disconnect" class="headerlink" title="# IntersectionObserver.disconnect"></a># IntersectionObserver.disconnect</h4><p>當然也可以一次性的註銷所有元素的觀察，同樣要記得，IntersectionObserver 實體並不會消失，只是沒有觀測中的元素而已，你依然可以再次使用 <code>observe</code> 來註冊一個新的觀察：</p><pre><code class="javascript">const observer = new IntersectionObserver((entries) =&gt; {  console.log(entries);});const box1 = document.querySelector(&quot;.box1&quot;);const box2 = document.querySelector(&quot;.box2&quot;);observer.observe(box1);observer.disconnect();observer.observe(box2);</code></pre><p><br/><br/></p><h4 id="IntersectionObserverEntry-物件"><a href="#IntersectionObserverEntry-物件" class="headerlink" title="# IntersectionObserverEntry 物件"></a># IntersectionObserverEntry 物件</h4><p>IntersectionObserver 和之前介紹的 MutationObserver 和 ResizeObserver 不同，它是<strong>「非同步」</strong>觸發的，畢竟「相交與否」這件事情是一個瞬間，不會有不斷疊加的狀態，所以也就不需要考慮連續觸發導致的效能問題，也就是說儘管你非常快速的來回捲動，它也不會將事件合併。</p><p>而 IntersectionObserverEntry 需要用陣列存放，是因為會有多個觀測中的元素同時進入／離開可視範圍的可能，這時候每一筆的 IntersectionObserverEntry 便代表一個元素的變動，而其中有許多屬性可以提供我們使用，下面就一一向各位介紹：</p><br/><ul><li><strong>IntersectionObserverEntry.target</strong><br>發生進出變動的目標元素(element)，每個「觀察者」都會提供的資訊。</li></ul><br/><ul><li><strong>IntersectionObserverEntry.isIntersecting</strong><br><code>isIntersecting</code> 是當中非常實用的屬性，用來表示目前元素是否與可是範圍（root）相交，也就是目標元素是否進入到可視範圍中。</li></ul><pre><code class="javascript">const observer = new IntersectionObserver((entries) =&gt; {  entries.forEach((entry) =&gt; {    if (entry.isIntersecting) {      // 目標元素進入 viewport 時執行    } else {      // 目標元素離開 viewport 時執行    }  });});</code></pre><br/><ul><li><strong>IntersectionObserverEntry.intersectionRatio</strong><br>這個屬性提供的是目前元素與觀察窗口的相交比例，會是一個 0~1 的數值，計算方式是 <code>相交面積 / 目標元素面積</code>。</li></ul><br/><ul><li><strong>IntersectionObserverEntry.boundingClientRect</strong><br>這個屬性會提供目標元素的尺寸、座標資訊，而它就等於拿 <code>target</code> 去執行昨天介紹的 <code>getBoundingClientRect</code> 所得到的結果。</li></ul><br/><ul><li><strong>IntersectionObserverEntry.rootBounds</strong><br>這個拿到的也會是 <code>getBoundingClientRect</code> 資訊，但計算的是可視窗口的尺寸、座標，要記得有 <code>rootMargin</code> 的影響。</li></ul><br/><ul><li><strong>IntersectionObserverEntry.intersectionRect</strong><br>和前面都一樣，不過提供的區塊範圍很特別，是目標元素與可視窗口的「交疊範圍」。</li></ul><img src="rect.png" style="max-width: 600px; margin: 24px auto;" /><p><br/><br/></p><h4 id="使用情境"><a href="#使用情境" class="headerlink" title="# 使用情境"></a># 使用情境</h4><p>IntersectionObserver 的使用情境很多，可以做「捲動特效」或是「無限捲動」，下面我們就來試試寫個無間捲動的功能看看，先看效果：</p><img src="infinity.gif" style="max-width: 600px; margin: 24px auto;" /><pre><code class="html">&lt;ul class=&quot;list&quot;&gt;  &lt;li class=&quot;item&quot;&gt;    &lt;div class=&quot;avatar&quot;&gt;&lt;/div&gt;    &lt;div&gt;      &lt;h3&gt;Name&lt;/h3&gt;      &lt;h5&gt;        Lorem ipsum dolor sit, amet consectetur adipisicing elit. Rem tenetur odit.rem ipsum dolor sit, amet consectetur        adipisicing elit. Rem tenetur odit      &lt;/h5&gt;    &lt;/div&gt;  &lt;/li&gt;&lt;/ul&gt;</code></pre><pre><code class="javascript">const ul = document.querySelector(&quot;ul&quot;);// 這個 function 會一次新增20筆項目到 ul 中// 用來模擬獲取資料後渲染畫面const getMoreItem = () =&gt; {  const fragment = document.createDocumentFragment();  for (let i = 0; i &lt;= 20; i++) {    const item = document.querySelector(&quot;li:first-child&quot;);    const newItem = item.cloneNode(true);    fragment.appendChild(newItem);  }  ul.appendChild(fragment);};const observer = new IntersectionObserver(  function (entries, observer) {    // 每當目標元素進入畫面後就新增20筆，並且重置觀察的元素    if (entries[0].isIntersecting) {      getMoreItem();      observer.unobserve(entries[0].target);      observer.observe(document.querySelector(&quot;li:nth-last-child(2)&quot;));    }  },  { root: ul } // 觀察窗口為 ul 的元素範圍);getMoreItem();observer.observe(document.querySelector(&quot;li:nth-last-child(2)&quot;));</code></pre><p>無限捲動的功能是非常常見的一個功能，平常在滑 FB 或 IG 時，貼文能不段的出現就是使用無線捲動，而使用 IntersectionObserver 就可以輕鬆做到。</p><p>我們實踐的概念也非常簡單，就是在目標元素進入窗口時去向後端獲取資料並渲染在畫面上，然後不斷的重新觀察倒數第二個 <code>li</code>，所以可以看到 Callback 中有執行 <code>unobserve</code> 來註銷原本的元素，然後又再次使用 <code>observe</code> 來註冊新元素。</p><p><br/><br/></p><p>IntersectionObserver 是不是非常方便呢？昨天我們還在用 <code>getBoundingClientRect</code> 來計算元素是否進入畫面，今天已經連計算都不用計算，完全交由「觀察者」來幫忙偵測，我們只要坐等通知就好了，大家快把它學起來，當個懶惰的工程師吧！</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10279046" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;當你進入我的眼簾，我們的命運就有了交集～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到 Observer，應該就知道今天要介紹的又是「觀察者」系列的 API 了，而且這次的觀察者可能比前面的 MutationObserver 和 ResizeOb
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / GetBoundingClientRect</title>
    <link href="https://maxleebk.com/2021/10/04/webApi/webApi-21/"/>
    <id>https://maxleebk.com/2021/10/04/webApi/webApi-21/</id>
    <published>2021-10-04T08:54:00.000Z</published>
    <updated>2023-01-12T00:54:38.927Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>小孩才做選擇，成年人當然是尺寸、座標全都要！</p></blockquote><p>昨天介紹的 ResizeObserver API 可以觀察到元素的尺寸變動時執行回呼，並且會提供元素變動後的「尺寸」、「座標」等資訊，而今天介紹的 GetBoundingClientRect 雖然無法再觀察元素變動了，但我們可以主動出擊，直接索取目前元素的相關資訊。</p><hr><h2 id="GetBoundingClientRect"><a href="#GetBoundingClientRect" class="headerlink" title="GetBoundingClientRect"></a>GetBoundingClientRect</h2><p>GetBoundingClientRect 可以使我們取得 Element 元素的寬高以及相對於視窗可視範圍(Viewport)的座標位置，對於前端老鳥來說可能不是那麼陌生，但對於新手來說，它不太會是第一批認識的 Web API，大部分可能都會先認識 <code>clientWidth</code>、<code>scrollWidth</code>、<code>offsetWidth</code>、<code>scrollTop</code>、<code>clientTop</code>、<code>offsetTop</code>…等等，這一大堆眼花撩亂讓人容易混淆的系列屬性。</p><br/><h4 id="元素的各種寬高與位置"><a href="#元素的各種寬高與位置" class="headerlink" title="# 元素的各種寬高與位置"></a># 元素的各種寬高與位置</h4><p>為了讓各位更好的理解 GetBoundingClientRect，先來幫各位整理及複習前面提到的這一大堆元素屬性，</p><ul><li><strong>offsetWidth / offsetHeight</strong>： 元素 <code>borderBox</code> 的寬/高，包含 <code>padding</code>、<code>border</code></li><li><strong>clientWidth / clientHeight</strong>： 元素 <code>paddingBox</code> 的寬/高，包含 <code>padding</code>，不包含 <code>border</code></li><li><strong>scrollWidth / scrollHeight</strong>： 元素包含 <code>padding</code> 及外溢內容的寬/高，不包含 <code>border</code></li></ul><img src="width.png" style="max-width: 600px; margin: 24px auto;" /><ul><li><strong>offsetTop / offsetLeft</strong>： 元素 <code>borderBox</code> 相對於 <code>offsetParent</code> 的垂直/水平距離</li><li><strong>clientTop / clientLeft</strong>： 元素 <code>paddingBox</code> 相對於 <code>borderBox</code> 的垂直/水平距離</li><li><strong>scrollTop / scrollLeft</strong>： 元素 <code>paddingBox</code> 被捲動的垂直/水平距離</li></ul><img src="top.png" style="max-width: 600px; margin: 24px auto;" /><p><br/><br/></p><h4 id="Element-getBoundingClientRect"><a href="#Element-getBoundingClientRect" class="headerlink" title="# Element.getBoundingClientRect"></a># Element.getBoundingClientRect</h4><p>其實剛剛介紹的眾多屬性，相信大家或多或少都有使用過，尤其在一些捲動事件中常常會出現它們的身影，不過在今天之後，你使用它們的機會可能會漸漸減少了。</p><p><code>getBoundingClientRect</code> 的使用方式非常簡單，它屬於 Element 的原生 method，直接互叫即可：</p><pre><code class="javascript">const div = document.querySelector(&quot;div&quot;);console.log(div.getBoundingClientRect());</code></pre><br/><p>執行過後便會回傳一個 DOMRect 物件，該物件中就會有指定元素的相關尺寸與座標訊息：</p><ul><li><strong>width</strong>： 元素的 <code>borderBox</code> 寬度，相當於 <code>offsetWidth</code></li><li><strong>height</strong>： 元素的 <code>borderBox</code> 高度，相當於 <code>offsetHeight</code></li><li><strong>x</strong>： 元素的 <code>borderBox</code> 左上角相對於視窗的水平(Ｘ)座標</li><li><strong>y</strong>： 元素的 <code>borderBox</code> 左上角相對於視窗的垂直(Ｙ)座標</li><li><strong>left</strong>： 元素的 <code>borderBox</code> 左上角相對於視窗的水平(Ｘ)座標，等同 <code>x</code></li><li><strong>top</strong>： 元素的 <code>borderBox</code> 左上角相對於視窗的垂直(Ｙ)座標，等同 <code>y</code></li><li><strong>right</strong>： 元素的 <code>borderBox</code> 右下角相對於視窗的水平(Ｘ)座標</li><li><strong>bottom</strong>： 元素的 <code>borderBox</code> 右下角相對於視窗的垂直(Ｙ)座標</li></ul><br/><blockquote><p>DOMRect 跟昨天介紹的 <code>ResizeObserverEntry.contentRect</code> 所回傳的 DOMRectReadOnly 格式是一樣的，但當中數值所代表的意義完全不同，不要被混淆囉。</p></blockquote><img src="rect.png" style="margin: 24px auto;" /><p>有了這些資訊後，針對一些捲動事件的需求其實就會變得簡單許多，像是我們常常會做的事情是「判斷某元素是否進入可視範圍」，就可以來看看使用 <code>getBoundingClientRect</code> 後的差別：</p><pre><code class="javascript">const div = document.querySelector(&quot;div&quot;);// 不使用 getBoundingClientRectwindow.addEventListener(&quot;scroll&quot;, function (e) {  if (div.offsetTop + div.offsetHeight &lt;= window.pageYOffset) {    console.log(&quot;元素底端已離開畫面&quot;);  } else if (div.offsetTop &lt;= window.pageYOffset + window.innerHeight) {    console.log(&quot;元素頂端已進入畫面&quot;);  }});// 使用 getBoundingClientRectwindow.addEventListener(&quot;scroll&quot;, function (e) {  const { top, bottom } = div.getBoundingClientRect();  if (bottom &lt;= 0) {    console.log(&quot;元素底端已離開畫面&quot;);  } else if (top &lt;= window.innerHeight) {    console.log(&quot;元素頂端已進入畫面&quot;);  }});</code></pre><p>可以看到，如果不使用 <code>getBoundingClientRect</code> 需進行較複雜的計算，而且如果該元素的 <code>offsetParent</code> 不是 <code>body</code> 的話，這個計算就會出現 Bug。反之使用 <code>getBoundingClientRect</code> 的程式碼簡潔又容易理解，而且因為 <code>top</code> 和 <code>bottom</code> 的數值是直接相對視窗計算出來的，所以也不用去顧慮元素的 <code>offsetParent</code>。</p><blockquote><p>小技巧： 利用 <code>window.pageYOffset</code> + <code>getBoundingClientRect().top</code> 就可以計算出元素相對於文件(document)的絕對座標喔。</p></blockquote><p><br/><br/></p><h4 id="實際練習"><a href="#實際練習" class="headerlink" title="# 實際練習"></a># 實際練習</h4><p>為了讓大家更能感受到 <code>getBoundingClientRect</code> 的強大，我們來做一個 「動態 Highlight」 的小練習，需求是「當游標滑到文章中的粗體字時會自動添加底色，且底色在不同關鍵字之間切換時，要有移動的過渡效果」。先看效果：</p><img src="bounding.gif" style="max-width: 700px; margin: 24px auto;" /><pre><code class="css">.highlight {  position: fixed;  background: yellowgreen;}</code></pre><pre><code class="javascript">const highlight = document.querySelector(&quot;.highlight&quot;);const bold = document.querySelectorAll(&quot;b&quot;);let hoverElement;bold.forEach((el) =&gt; {  el.addEventListener(&quot;mouseenter&quot;, function () {    hoverElement = this;    highlight.style.transition = &quot;0.3s&quot;;    setHighlight();  });});// 為了在視窗滾動時不會跑版，要在 scroll 進行重新定位window.addEventListener(&quot;scroll&quot;, function () {  highlight.style.transition = &quot;0s&quot;;  if (hoverElement) setHighlight();});function setHighlight() {  const { width, height, top, left } = hoverElement.getBoundingClientRect();  highlight.textContent = hoverElement.textContent;  highlight.style.width = width + &quot;px&quot;;  highlight.style.height = height + &quot;px&quot;;  highlight.style.top = top + &quot;px&quot;;  highlight.style.left = left + &quot;px&quot;;}</code></pre><p>整體概念就是在指定的元素上綁定 <code>mouseenter</code> 事件，並在事件發生時使用 <code>getBoundingClientRect</code> 來取得該元素的尺寸座標資訊，然後將其設定在 Highlight 元素的樣式上。</p><p>不要認為這樣的功能效果好像很簡單，如果沒有 <code>getBoundingClientRect</code> 的話，做起來是特別麻煩的，想要實際玩玩看的話，這邊提供我已經寫好的 <a href="https://codepen.io/max-lee/pen/GREVWGa" target="_blank" rel="noopener">CodePen</a>，並且也鼓勵大家發揮創意來試試看其他的應用，感受一下它的好用之處。</p><p><br/><br/></p><p>希望經過今天的介紹，各位已經開始愛上 <code>getBoundingClientRect</code> 了，我本身就蠻常使用的，比較記下一堆容易搞混的屬性，只需要一行我就可以取得那些經常使用的資訊，而且還可以剩下很多麻煩的計算，何樂不為呢？</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10278542" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;小孩才做選擇，成年人當然是尺寸、座標全都要！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;昨天介紹的 ResizeObserver API 可以觀察到元素的尺寸變動時執行回呼，並且會提供元素變動後的「尺寸」、「座標」等資訊，而今天介紹的 GetBou
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / ResizeObserver</title>
    <link href="https://maxleebk.com/2021/10/03/webApi/webApi-20/"/>
    <id>https://maxleebk.com/2021/10/03/webApi/webApi-20/</id>
    <published>2021-10-03T14:33:00.000Z</published>
    <updated>2023-01-12T00:54:38.923Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你的改變，我看得見！</p></blockquote><p>今天要介紹的是 ResizeObserver，它和昨天的 MutationObserver 非常相像，都是透過「觀察者模式」的設計方式來監測元素，不過 ResizeObserver 監測的變動是元素的「大小」。</p><hr><h2 id="ResizeObserver"><a href="#ResizeObserver" class="headerlink" title="ResizeObserver"></a>ResizeObserver</h2><p>各位應該有使用過 window 的 <code>resize</code> 事件吧？只要視窗大小有更動，事件就會觸發並執行 Callback，然後各位也一定跟我一樣，肖想著把 <code>resize</code> 事件綁定在一般元素上，可想而知是不會成功的，但 ResizeObserver 的出現，終於可以實現我們的願望了。</p><br/><h4 id="Window-ResizeObserver"><a href="#Window-ResizeObserver" class="headerlink" title="# Window.ResizeObserver"></a># Window.ResizeObserver</h4><p>ResizeObserver： 一樣是一個建構函式，所以需要使用 <code>new</code> 關鍵字來建立實體，建立時需要傳入一個 Callback Function 作為參數，該 Function 可以接到由 ResizeObserver 提供的一個陣列作為參數，該陣列中會一個或多個 ResizeObserverEntry 物件：</p><br/><ul><li><strong>ResizeObserverEntry</strong>： 該物件中會有一些屬性，讓我們可以取得一些有關元素的「大小」、「位置」資訊，後面會再詳細介紹。</li></ul><br/><pre><code class="javascript">const observer = new ResizeObserver(function (entries) {  console.log(entries);});</code></pre><p><br/><br/></p><h4 id="ResizeObserver-observe"><a href="#ResizeObserver-observe" class="headerlink" title="# ResizeObserver.observe"></a># ResizeObserver.observe</h4><p>就和昨天說的一樣，ResizeObserver 創建後並不會直接開始進行觀察，我們需要透過 <code>observe</code> 來註冊想要監測的元素，這樣 ResizeObserver 才會在該元素發生變動時進行動作，這裡有兩個參數傳入：</p><br/><ul><li><strong>target</strong>： 一個要受到觀察的 Element 元素。</li><li><strong>options</strong>：這是一個可選的參數，用來初始化觀測的設定選項，目前只有一個屬性：<ul><li>box: 這個屬性會決定要觀測元素的哪一種「盒模型(Box Model)」。可接受的值有 <code>content-box</code> 和 <code>border-box</code> 兩種，預設為 <code>content-box</code>。（其實有第三種，但使用度很低）</li></ul></li></ul><blockquote><p>如果對盒模型不太熟悉的朋友可以看<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model#%E4%BB%80%E4%B9%88%E6%98%AFcss_%E7%9B%92%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">這裡</a>瞭解一下</p></blockquote><br/><pre><code class="javascript">const observer = new ResizeObserver(function (entries) {  console.log(entries);});const div = document.querySelector(&quot;div&quot;);observer.observe(div, {  box: &quot;border-box&quot;,});</code></pre><p>這樣只要受到監測的元素發生寬高的變化，ResizeObserver 就會執行我們指定的行為了。</p><p><br/><br/></p><h4 id="ResizeObserver-disconnect"><a href="#ResizeObserver-disconnect" class="headerlink" title="# ResizeObserver.disconnect"></a># ResizeObserver.disconnect</h4><p>和 MutationObserver 一樣，只要使用 <code>disconnect</code> 這個 method 就可以註銷目前所有被觀察的元素，後續只要再次呼叫 <code>observe</code> 來註冊一個被觀察的元素，ResizeObserver 依然會持續運作。</p><pre><code class="javascript">const observer = new ResizeObserver(function (entries) {  console.log(entries);});observer.disconnect();</code></pre><p><br/><br/></p><h4 id="ResizeObserver-unobserve"><a href="#ResizeObserver-unobserve" class="headerlink" title="# ResizeObserver.unobserve"></a># ResizeObserver.unobserve</h4><p>ResizeObserver 除了 <code>disconnect</code> 之外，還額外多了一個 <code>unobserve</code> method，它可以讓我們註銷「單個」元素的觀察，當某個元素已經不在需要受到監測，就可以將其做為參數，<code>unobserve</code> 便會把它從 ResizeObserver 的監測中移除。</p><pre><code class="javascript">const observer = new ResizeObserver(function (entries) {  console.log(entries);});const div = document.querySelector(&quot;div&quot;);observer.observe(div, {  box: &quot;border-box&quot;,});observer.unobserve(div);</code></pre><p><br/><br/></p><h4 id="ResizeObserver-特性"><a href="#ResizeObserver-特性" class="headerlink" title="# ResizeObserver 特性"></a># ResizeObserver 特性</h4><p>一樣的，ResizeObserver 為了優化效能問題，如果有一連串連續且即時的元素尺寸變動，那 ResizeObserver 並不會一次次觸發，而是會將它們合併成一次變動，並且只會紀錄最終的結果。</p><p>而如果同一時間中，有多個觀測中的元素都發生了尺寸變動，那 ResizeObserver 就會有相應數量的紀錄，這也就是為什麼會以陣列形式來包裝 ResizeObserverEntry 物件。</p><pre><code class="javascript">const observer = new ResizeObserver(function (entries) {  entries.forEach((entry) =&gt; {    console.log(entry); // ResizeObserverEntry 物件  });});const element1 = document.querySelector(&quot;#element1&quot;);const element2 = document.querySelector(&quot;#element2&quot;);observer.observe(element1);observer.observe(element2);element1.style.width = &quot;300px&quot;;element1.style.height = &quot;200px&quot;;element2.style.width = &quot;300px&quot;;element2.style.height = &quot;200px&quot;;// 看似是四次變動，但 ResizeObserver 只會視為「兩個元素的一次變動」// 因此 callback 只會觸發一次，且 entries 中會有兩組 ResizeObserverEntry</code></pre><p><br/><br/></p><h4 id="ResizeObserverEntry-物件"><a href="#ResizeObserverEntry-物件" class="headerlink" title="# ResizeObserverEntry 物件"></a># ResizeObserverEntry 物件</h4><p>ResizeObserverEntry 的屬性雖然不多，但都較為複雜，所以下面就一一拉出來說明：</p><br/><ul><li><strong>ResizeObserverEntry.target</strong><br>這是其中比較單純的屬性，讀取到的會是變動的元素(element)。</li></ul><br/><ul><li><p><strong>ResizeObserverEntry.contentRect</strong><br>這個屬性的值為一個 DOMRectReadOnly 物件，該物件會紀錄很多 <code>target</code> 的相關資訊：</p><ul><li><strong>x</strong>： 變動元素之 <code>contentBox</code> 在該元素中的Ｘ座標，通常等於 padding 寬度。</li><li><strong>y</strong>： 變動元素之 <code>contentBox</code> 在該元素中的Ｙ座標，通常等於 padding 寬度。</li><li><strong>width</strong>： 變動元素之 <code>contentBox</code> 的寬度。</li><li><strong>height</strong>： 變動元素之 <code>contentBox</code> 的高度。</li><li><strong>top</strong>： 變動元素之 <code>contentBox</code> 的「頂邊」的Ｙ座標，通常與 <code>y</code> 相同。</li><li><strong>bottom</strong>： 變動元素之 <code>contentBox</code> 的「底邊」的Ｙ座標，通常與 <code>y + height</code> 相同。</li><li><strong>left</strong>： 變動元素之 <code>contentBox</code> 的「左側」的Ｘ座標，通常與 <code>x</code> 相同。</li><li><strong>right</strong>： 變動元素之 <code>contentBox</code> 的「右側」的Ｘ座標，通常與 <code>x + width</code> 相同。</li></ul></li></ul><img src="rect.png" style="max-width: 600px; margin: 24px auto;" /><br/><ul><li><p><strong>ResizeObserverEntry.borderBoxSize</strong><br>這個屬性會是一個陣列，而陣列中會是一個或多個 borderBoxSize 物件，該物件中又會有兩個屬性：</p><ul><li><p><strong>blockSize</strong>： 這個屬性的值會是一個數值，該數值通常代表元素的高，會說通常是因為，這取決於元素被設定的書寫方向，<code>blockSize</code> 代表的是「垂直」於書寫方向的元素邊長尺寸(單位:px)。</p></li><li><p><strong>inlineSize</strong>： 而 <code>inlineSize</code> 剛好相反，它代表的是「平行」於書寫方向的元素邊長尺寸(單位:px)。</p></li></ul></li></ul><br/><ul><li><p><strong>ResizeObserverEntry.contentBoxSize</strong><br>這個屬性會是一個陣列，而陣列中會是一個或多個 contentBoxSize 物件，而物件中一樣會有兩個屬性，其實跟 borderBoxSize 物件是一樣的，但是兩者的差別在於尺寸的計算方式，borderBoxSize 是依照 <code>border-box</code> 的方式計算，contentBoxSize 則是依 <code>content-box</code> 進行計算。</p><ul><li><p><strong>blockSize</strong>： 「垂直」於書寫方向的元素邊長尺寸(單位:px)。</p></li><li><p><strong>inlineSize</strong>： 「平行」於書寫方向的元素邊長尺寸(單位:px)。</p></li></ul></li></ul><img src="box.png" style="max-width: 600px; margin: 24px auto;" /><p>以上這些資訊我們都可以在 Callback 中取得，想要做任何判斷或計算都是非常方便，所以大家可以根據需求去決定需要利用的資訊有哪些。</p><pre><code class="javascript">const observer = new ResizeObserver(function (entries) {  entries.forEach((entry) =&gt; {    const target = entry.target;    const borderBox = entry.borderBoxSize[0];    console.log(`${target.id} 寬度: ${borderBox.inlineSize} 高度: ${borderBox.blockSize}`);  });});</code></pre><p><br/><br/></p><p>相比 MutationObserver，ResizeObserver 的使用情境就比較多了，因為今天元素的變動會受到很多因素影響，且大部分都不是我們可以完全預測掌控的，例如視窗大小的壓縮、元素內容的增加/減少、RWD 的控制的等等，這時就可以透過 ResizeObserver 來監測元素的大小，並做出相對應的動作。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10278080" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;你的改變，我看得見！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天要介紹的是 ResizeObserver，它和昨天的 MutationObserver 非常相像，都是透過「觀察者模式」的設計方式來監測元素，不過 ResizeObserver 監
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / MutationObserver</title>
    <link href="https://maxleebk.com/2021/10/02/webApi/webApi-19/"/>
    <id>https://maxleebk.com/2021/10/02/webApi/webApi-19/</id>
    <published>2021-10-02T09:19:00.000Z</published>
    <updated>2023-01-12T00:54:38.923Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我的改變，你看得見！</p></blockquote><p>在開發網頁過程中，我們最常做的事情就是對資料進行修改後運用在 DOM 元素上，像是新增 / 刪除節點、調整樣式、改寫內容或是屬性(attribute)的調整，而這些「修改 DOM」的動作通常散落在程式碼的各個角落，發生時機也並不相同，在這樣的情況下，我們能不能追蹤這些動作呢？</p><hr><h2 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h2><p>MutationObserver API 就是用來解決上述問題的，它可以讓我們追蹤 DOM 的變化，無論是子節點的變動或內容、屬性的變動，並且獲得相關的資訊，以便作出後續的行動。</p><br/><h4 id="Window-MutationObserver"><a href="#Window-MutationObserver" class="headerlink" title="# Window.MutationObserver"></a># Window.MutationObserver</h4><p>MutationObserver 本身是建構函式，所以我們需要用 <code>new</code> 關鍵字來建立實體，建立時需要傳入一個 Callback Function 作為參數，該 Function 可以接到由 MutationObserver 提供的 MutationRecords 陣列和 MutationObserver 實體作為參數：</p><br/><ul><li><strong>MutationRecords</strong>： 這個陣列會存放 MutationRecord 物件，該物件記錄著 DOM 變動的相關資訊，後面再詳細介紹。</li><li><strong>MutationObserver</strong>： 呼叫此 Callback Function 的 MutationObserver 實體，其實就等於該 Function 的 <code>this</code>。</li></ul><br/><pre><code class="javascript">const observer = new MutationObserver(function (mutations, owner) {  console.log(mutation, owner);});</code></pre><p><br/><br/></p><h4 id="MutationObserver-observe"><a href="#MutationObserver-observe" class="headerlink" title="# MutationObserver.observe"></a># MutationObserver.observe</h4><p>我們可以把剛剛 <code>new</code> 出來的 MutationObserver 實體譬喻成一個「觀察者」，當這位觀察者監測到節點變動，他就會執行設定好的任務(callback)，但他目前並未被指派要觀察哪一個元素，所以我們要透過 <code>observe</code> 這個 method 來指定「被觀察的對象」，其中需要傳入兩個參數：</p><br/><ul><li><strong>target</strong>： 一個要受到觀察的 DOM 節點。</li><li><strong>options</strong>：一個初始化設定物件，用來指定 DOM 節點的哪些項目需要被觀察等相關設定。</li></ul><table><thead><tr><th align="center">屬性</th><th align="center">解釋</th><th align="center">型別、預設值</th></tr></thead><tbody><tr><td align="center">childList</td><td align="center">是否觀察節點的直屬子節點變動</td><td align="center">boolean、<code>false</code></td></tr><tr><td align="center">subtree</td><td align="center">是否觀察節點的所有子節點變動</td><td align="center">boolean、<code>false</code></td></tr><tr><td align="center">attributes</td><td align="center">是否觀察節點的屬性變動</td><td align="center">boolean、<code>false</code></td></tr><tr><td align="center">characterData</td><td align="center">是否觀察節點中的內容變動</td><td align="center">boolean、<code>false</code></td></tr><tr><td align="center">attributeOldValue</td><td align="center">是否紀錄變動前的屬性值</td><td align="center">boolean、<code>false</code></td></tr><tr><td align="center">characterDataOldValue</td><td align="center">是否紀錄變動前的內容值</td><td align="center">boolean、<code>false</code></td></tr><tr><td align="center">attributeFilter</td><td align="center">需要觀察的屬性名稱，如果為空則全部觀察</td><td align="center">array[string]、<code>[]</code></td></tr></tbody></table><br/><pre><code class="javascript">const observer = new MutationObserver(function (mutations) {  console.log(mutations);});const div = document.querySelector(&quot;div&quot;);observer.observe(div, {  childList: true,  attributes: true,  characterData: true,});</code></pre><p>如此一來，只要元素有被觀察到我們所指定項目的變動，MutationObserver 就會去執行 Callback。</p><p><br/><br/></p><h4 id="MutationObserver-disconnect"><a href="#MutationObserver-disconnect" class="headerlink" title="# MutationObserver.disconnect"></a># MutationObserver.disconnect</h4><p>另外還可以透過 <code>disconnect</code> 來註銷目前已經被觀察的 DOM，但 MutationObserver 實體並不會消失，只是暫時不再進行觀察，直到你又使用 <code>observe</code> 來註冊一個被觀察對象。</p><pre><code class="javascript">const observer = new MutationObserver(function (mutations) {  console.log(mutations);});observer.disconnect();</code></pre><p><br/><br/></p><h4 id="MutationRecord-物件"><a href="#MutationRecord-物件" class="headerlink" title="# MutationRecord 物件"></a># MutationRecord 物件</h4><p>前面有說，MutationObserver 在執行 Callback 時會提供一個 MutationRecords 陣列，裡面會存放 MutationRecord 物件，這個段落我們要來了解為何 MutationRecord 要存放在陣列中，以及它到底存放著哪些資訊供我們使用。</p><br/><ul><li><p><strong>首先要先知道一個 MutationObserver 的特性：</strong></p><p>MutationObserver 並非事件監聽，事件是同步執行的，而 MutationObserver 則是非同步執行的，這意味著，如果目前執行的一段程序中有多次的節點變動，MutationObserver 會等到一切結束後才呼叫 Callback。</p><p>這是為了避免大量 DOM 操作所帶來的效能問題，也因此，MutationObserver 會將該程序時間內所有的變動記錄下來並包裝成陣列給我們。</p></li></ul><pre><code class="javascript">const observer = new MutationObserver(function (mutations) {  mutations.forEach((record) =&gt; {    console.log(record); // MutationRecord 物件  });});const div = document.querySelector(&quot;div&quot;);observer.observe(div, {  childList: true,  attributes: true,  characterData: true,});div.textContent = &quot;example&quot;;div.style.background = &quot;pink&quot;;// 此時 MutationObserver 只會呼叫一次 Callback// 而 mutations 中會有兩個 MutationRecord</code></pre><br/><br/><ul><li><strong>接著來看一下 MutationRecord 中有哪些屬性：</strong><br>以下這些並非全部的屬性，只介紹了幾個比較實用的，如果想知道完整內容的話可以看<a href="https://developer.mozilla.org/zh-TW/docs/Web/API/MutationObserver#mutationobserverinit" target="_blank" rel="noopener">這裡</a>。</li></ul><table><thead><tr><th align="center">屬性</th><th align="center">解釋</th><th align="center">型別</th></tr></thead><tbody><tr><td align="center">type</td><td align="center">觀察到的變動類型</td><td align="center">string</td></tr><tr><td align="center">target</td><td align="center">變動的節點</td><td align="center">Node</td></tr><tr><td align="center">addedNodes</td><td align="center">被新增的節點，如果沒有會是 <code>null</code></td><td align="center">Node</td></tr><tr><td align="center">removedNodes</td><td align="center">被刪除的節點，如果沒有會是 <code>null</code></td><td align="center">Node</td></tr><tr><td align="center">attributeName</td><td align="center">觀察到的變動屬性之名稱</td><td align="center">string</td></tr><tr><td align="center">oldValue</td><td align="center">變動前的值</td><td align="center">string</td></tr></tbody></table><blockquote><p>MutationRecord.oldValue 只有在 <code>observe()</code> 的 <code>options</code> 有開啟設定時才會有值。</p></blockquote><p><br/><br/></p><h4 id="使用情境"><a href="#使用情境" class="headerlink" title="# 使用情境"></a># 使用情境</h4><p>老實說，一定要使用 MutationObserver 的情況並不多，可能比較需要使用的情境會是：「專案中使用了第三方套件，為了觀測該套件所進行的一些 DOM 操作」，由於我們無法直接對第三方套件的程式碼進行修改，導致無法掌控 DOM 變動的程序，所以只能透過 MutationObserver 來追蹤。</p><p>但因為平常的 DOM 操作其實都是由我們主動執行的，所以真的需要在節點變動後做什麼事情就直接放在後面一起執行就好了，例如：</p><pre><code class="html">&lt;button onclick=&quot;changeContent()&quot;&gt;改變內容&lt;/button&gt;&lt;button onclick=&quot;changeColor()&quot;&gt;改變顏色&lt;/button&gt;&lt;div&gt;Hi I&#39;m Max&lt;/div&gt;&lt;script&gt;  const div = document.querySelector(&quot;div&quot;);  // 當 DOM 變動時我們想做的事情  function onDomMutation(info) {    console.log(info);  }  function changeContent() {    const oldValue = div.textContent;    div.textContent = &quot;Hi I&#39;m Tom&quot;;    onDomMutation({      target: div,      oldValue,      type: &quot;characterData&quot;,    });  }  function changeColor() {    const oldValue = div.style;    div.style.color = &quot;red&quot;;    onDomMutation({      target: div,      oldValue,      type: &quot;attributes&quot;,    });  }&lt;/script&gt;</code></pre><p><strong>其實透過上面這樣的寫法依然可以做到類似的效果，但我認為 MutationObserver 最主要的優點是「減少耦合」，就像之前介紹的 CustomEvent 一樣，透過「觀察者模式」的 Design Patterns 來讓原本是許多「一對一的依賴關係」整合成單個「一對多的依賴關係」。</strong></p><pre><code class="html">&lt;button onclick=&quot;changeContent()&quot;&gt;改變內容&lt;/button&gt;&lt;button onclick=&quot;changeColor()&quot;&gt;改變顏色&lt;/button&gt;&lt;div&gt;Hi I&#39;m Max&lt;/div&gt;&lt;script&gt;  const div = document.querySelector(&quot;div&quot;);  const observer = new MutationObserver(function (mutations) {    mutations.forEach((record) =&gt; {      console.log(record);    });  });  observer.observe(div, {    childList: true,    attributes: true,    characterData: true,  });  function changeContent() {    div.textContent = &quot;Hi I&#39;m Tom&quot;;  }  function changeColor() {    div.style.color = &quot;red&quot;;  }&lt;/script&gt;</code></pre><p><br/><br/></p><p>不曉得經過這樣的解釋後，各位有沒有理解使用 MutationObserver 的好處呢？後面我們還會陸續介紹幾個也是採用「觀察者模式(Observer Pattern)」的 API，可以期待一下喔。另外有使用過 Vue 的朋友，你知道 <code>$nextTick</code> 其實就是基於 MutationObserver 實踐出來的喔，有興趣的人可以去看看<a href="https://github.com/vuejs/vue/blob/2.6/src/core/util/next-tick.js" target="_blank" rel="noopener">原始碼</a>。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10277536" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我的改變，你看得見！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在開發網頁過程中，我們最常做的事情就是對資料進行修改後運用在 DOM 元素上，像是新增 / 刪除節點、調整樣式、改寫內容或是屬性(attribute)的調整，而這些「修改 DOM」的動
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / RequestIdleCallback</title>
    <link href="https://maxleebk.com/2021/10/01/webApi/webApi-18/"/>
    <id>https://maxleebk.com/2021/10/01/webApi/webApi-18/</id>
    <published>2021-10-01T07:32:00.000Z</published>
    <updated>2023-01-12T00:54:38.923Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>時間管力大師就是要忙裡偷閒</p></blockquote><p>各位應該知道 JavaScript 是單執行緒(單線程)的程式語言，也就是一次只能處理一件事情。這樣的特性會使得事件的執行必定有個先後順序，這時候就會希望重要的事情能夠排序在前面，剩下比較不重要的任務等空閒時再處理即可，這時候就可以靠 RequestIdleCallback 來幫助我們。</p><hr><h2 id="RequestIdleCallback"><a href="#RequestIdleCallback" class="headerlink" title="RequestIdleCallback"></a>RequestIdleCallback</h2><p>RequestIdleCallback 會在瀏覽器「每一幀」中剩下的空閒裡來執行當中的 Callback。</p><br/><p>我們之前在介紹 RequestAnimationFrame 時有提過「幀數(FPS)」的概念，也就是「一秒鐘內能夠更新多少幀」，假如在一秒內能夠更新 60 幀，則 FPS 為 60，每一幀的時間約為 16.7 ms(毫秒)。</p><p>對於瀏覽器來說每一次「重繪(Repaint)」就是「一幀」，而這一幀要花多少時間就要看當下的網路或硬體狀況而定了。在這每一幀中，瀏覽器都有可能正在執行任務，若這個任務完成時，當下那一幀還沒結束時，就會有一個短暫的空閒時間。</p><blockquote><p>以 60FPS 為例，每一幀的空閒時間必定小於等於 16.7 ms。</p></blockquote><br/><p>而只要有這個空閒時間 RequestIdleCallback 就會去執行當中的 Callback，來完成那些我們覺得不重要的任務，換句話說，如果瀏覽器一直處於繁忙狀態的話，那該任務就會一直無法執行。</p><br/><h4 id="Window-requestIdleCallback"><a href="#Window-requestIdleCallback" class="headerlink" title="# Window.requestIdleCallback"></a># Window.requestIdleCallback</h4><p><code>requestIdleCallback</code> 有兩個參數要傳入：</p><ul><li>callback: 需要在空閒時間(Idle)執行的函示。</li><li>timeout: 這是一個可選參數，你可以設定一個時間來強制執行 <code>callback</code>，以避免瀏覽器因為持續繁忙的忽略(單位:毫秒)。</li></ul><blockquote><p>大部分情況不建議使用 <code>timeout</code>，因為會使用 <code>requestIdleCallback</code> 就代表不想影響主線程的任務進行 。</p></blockquote><pre><code class="javascript">const handlerId = requestIdleCallback(function () {  //..做些不住要的事}, 500);cancelIdleCallback(handlerId); // 取消requestIdleCallback</code></pre><p><br/><br/></p><h4 id="IdleDeadline"><a href="#IdleDeadline" class="headerlink" title="# IdleDeadline"></a># IdleDeadline</h4><p>而我們傳入的 Callback Function 會被丟進一個由 <code>requestIdleCallback</code> 提供的參數，該參數通常取名為 <code>deadline</code>，並且有兩個屬性可以使用：</p><ul><li>didTimeout: 這是一個唯讀屬性，以布林值來表示 Callback 是否是因為 <code>timeout</code> 被觸發的。</li><li>timeRemaining: 它是一個 method，執行後會傳傳一個毫秒數，用來表示當下這一幀的剩餘時間。</li></ul><pre><code class="javascript">requestIdleCallback(function (deadline) {  // 如果你在 requestIdleCallback 中沒有傳入 timeout 參數，didTimeout 必定為 false  console.log(deadline.didTimeout);  console.log(deadline.timeRemaining());}, 500);</code></pre><p><br/><br/></p><h4 id="實際測試"><a href="#實際測試" class="headerlink" title="# 實際測試"></a># 實際測試</h4><p>由於 JavaScript 是單執行緒，所以要是我今天進行了一個需要耗費大量時間的任務，那使用者的 UI 操作其實也會受到影響。<br>就像下面這個範例中，在 <code>count</code> 被函式 <code>add</code> 加到 1000000 以前，你不管怎麼敲擊鍵盤，<code>keydown</code> 事件都不會被觸發，因為瀏覽器正在忙著算數：</p><pre><code class="javascript">window.addEventListener(&quot;keydown&quot;, function () {  console.log(&quot;Hey !!!!!!!!!&quot;);});let count = 0;add();function add() {  if (count &lt; 10000) {    console.log(count++);    add();  }}</code></pre><p>但是我們只要用 <code>requestIdleCallback</code> 來改寫一下，那狀況就不一樣了，因為這時候 <code>add</code> 這項任務的優先度會往後排，所以當我按下鍵盤時，瀏覽器會先處理 <code>keydown</code> 事件，等到閒置下來後才會繼續進行。</p><pre><code class="javascript">window.addEventListener(&quot;keydown&quot;, function () {  console.log(&quot;Hey !!!!!!!!!&quot;);});let count = 0;requestIdleCallback(add);function add(deadline) {  if (deadline.timeRemaining() &gt; 0) {    if (count &lt; 10000) {      console.log(count++);      requestIdleCallback(add);    }  }}</code></pre><p><br/><br/></p><h4 id="使用情境"><a href="#使用情境" class="headerlink" title="# 使用情境"></a># 使用情境</h4><p>在了解 RequestIdleCallback 的效果後，我第一個想到的實際應用會是 LazyLoad，想像以下，如果我們有個網頁，當中有幾十甚至幾百張的高畫質圖片需要顯示，可想而知瀏覽器的負擔會相當的大，非常有可能會影響頁面的效能與任務執行，但如果們我利用 <code>requestIdleCallback</code> 來處理，就可以在不影響主執行緒的情況下載入圖片。</p><pre><code class="javascript">const images = [  &quot;https://img/001.png&quot;,  &quot;https://img/002.png&quot;,  //.....  &quot;https://img/099.png&quot;,  &quot;https://img/100.png&quot;,];requestIdleCallback(loadImage);function loadImage(deadline) {  if (deadline.timeRemaining() &gt; 0) {    if (images.length) {      const imgSrc = images.shift();      const img = new Image(250, 150);      img.onload = document.body.appendChild(img);      img.src = imgSrc;      requestIdleCallback(loadImage);    }  }}</code></pre><p><br/><br/></p><p>不曉得使用過 React 的朋友有沒有了解過 React Fiber 呢？其實它的原理就和 RequestIdleCallback 一樣，將大量沒那麼優先的工作拆成許多小片段，在瑣碎的時間裡慢慢完成，也因為這樣的機制，使得我們可以去中斷它，將一些突發的重要任務(例如使用者的 UI 事件)插在這些小片段中，宛如有另一條執行緒一般。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10276904" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;時間管力大師就是要忙裡偷閒&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;各位應該知道 JavaScript 是單執行緒(單線程)的程式語言，也就是一次只能處理一件事情。這樣的特性會使得事件的執行必定有個先後順序，這時候就會希望重要的事情能夠排序在前面
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / BroadcastChannel</title>
    <link href="https://maxleebk.com/2021/09/30/webApi/webApi-17/"/>
    <id>https://maxleebk.com/2021/09/30/webApi/webApi-17/</id>
    <published>2021-09-30T14:32:00.000Z</published>
    <updated>2023-01-12T00:54:38.915Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>里長辦公室廣播：張君雅小妹妹，恁兜欸泡麵已經煮好了！</p></blockquote><p>前兩天已經認識了 PostMessage 和建立專屬頻道的 MessageChannel，它們都是進行點對點的溝通，但如果想要一次跟多個頁面溝通時怎麼辦了，這時 BroadcastChannel 就能派上用場了。</p><hr><h2 id="BroadcastChannel"><a href="#BroadcastChannel" class="headerlink" title="BroadcastChannel"></a>BroadcastChannel</h2><p>BroadcastChannel 就如同一個無線對講機系統，訊息是播放在一個廣播頻道中，任何頁面只要取得頻道的頻率就可以在無線電中發送／接收訊息。</p><br/><h4 id="建立頻道"><a href="#建立頻道" class="headerlink" title="# 建立頻道"></a># 建立頻道</h4><p>和 <code>MessageChannel</code> 一樣，<code>BroadcastChannel</code> 本身也是一個 <code>Class</code>，只要透過關鍵字 <code>new</code> 就能建立一個廣播頻道，不過這次我們要傳入一個字串來當作廣播頻道的名稱，未來其他頁面才能藉由同樣的字串來進入頻道。</p><pre><code class="javascript">const channel = new BroadcastChannel(&quot;max_channel&quot;);</code></pre><p>接著只要透過我們建立的廣播頻道送出訊息即可：</p><pre><code class="javascript">const channel = new BroadcastChannel(&quot;max_channel&quot;);channel.postMessage(&quot;你已成功加入頻道!&quot;, location.origin);</code></pre><p>要收到訊息的話就用 BroadcastChannel 監聽 <code>message</code> 即可：</p><pre><code class="javascript">const channel = new BroadcastChannel(&quot;max_channel&quot;);channel.onmessage = function (event) {  console.log(event.data);};</code></pre><p><br/><br/></p><h4 id="頻道溝通"><a href="#頻道溝通" class="headerlink" title="# 頻道溝通"></a># 頻道溝通</h4><p>這時候其他頁面只要使用同樣的頻道名稱建立一個 BroadcastChannel，並且一樣透過該頻道來傳送／接收訊息，這樣所有頻道中的頁面就都可以相互溝通了。</p><pre><code class="html">&lt;!-- 這裡是 main.html --&gt;&lt;button onclick=&quot;sendMessage()&quot;&gt;send message&lt;/button&gt;&lt;iframe src=&quot;pageA.html&quot; width=&quot;480&quot; height=&quot;120&quot;&gt;&lt;/iframe&gt;&lt;iframe src=&quot;pageB.html&quot; width=&quot;480&quot; height=&quot;120&quot;&gt;&lt;/iframe&gt;&lt;script&gt;  const channel = new BroadcastChannel(&quot;max_channel&quot;);  channel.onmessage = function (event) {    console.log(event.data);  };  function sendMessage() {    channel.postMessage(&quot;你已成功加入頻道!&quot;, location.origin);  }&lt;/script&gt;</code></pre><pre><code class="html">&lt;!-- 這裡是 pageA.html --&gt;&lt;button onclick=&quot;sendMessage()&quot;&gt;send message&lt;/button&gt;&lt;div class=&quot;output&quot;&gt;pageA content&lt;/div&gt;&lt;script&gt;  const output = document.querySelector(&quot;.output&quot;);  const channel = new BroadcastChannel(&quot;max_channel&quot;);  channel.onmessage = function (event) {    const output = document.querySelector(&quot;.output&quot;);    output.innerHTML = event.data;  };  function sendMessage() {    channel.postMessage(&quot;pageA 發送訊息！&quot;, location.origin);  }&lt;/script&gt;</code></pre><pre><code class="html">&lt;!-- 這裡是 pageB.html --&gt;&lt;button onclick=&quot;sendMessage()&quot;&gt;send message&lt;/button&gt;&lt;div class=&quot;output&quot;&gt;pageB content&lt;/div&gt;&lt;script&gt;  const channel = new BroadcastChannel(&quot;max_channel&quot;);  channel.onmessage = function (event) {    const output = document.querySelector(&quot;.output&quot;);    output.innerHTML = event.data;  };  function sendMessage() {    channel.postMessage(&quot;pageB 發送訊息！&quot;, location.origin);  }&lt;/script&gt;</code></pre><img src="broadcast.gif" style="margin: 24px auto;" /><p><br/><br/></p><h4 id="頻道名稱"><a href="#頻道名稱" class="headerlink" title="# 頻道名稱"></a># 頻道名稱</h4><p>不過上面這樣的範例，會有一個令人詬病的地方，就是「頻道名稱」的同步問題，要是有其中某個頁面打錯頻道名稱，那就會連不上頻道。或是如果想要更換頻道名稱的時候，就必須大家一起改，似乎是又點不太方便。</p><p>所以在主頁面建立頻道後，其實可以先用一般的 <code>postMessage</code> 將頻道名稱傳給需要的頁面：</p><pre><code class="html">&lt;iframe src=&quot;pageA.html&quot; width=&quot;480&quot; height=&quot;120&quot;&gt;&lt;/iframe&gt;&lt;iframe src=&quot;pageB.html&quot; width=&quot;480&quot; height=&quot;120&quot;&gt;&lt;/iframe&gt;&lt;script&gt;  const allIframe = document.querySelectorAll(&quot;iframe&quot;);  const channel = new BroadcastChannel(&quot;max_channel&quot;);  // 發送頻道名稱  allIframe.forEach((iframe) =&gt; {    iframe.addEventListener(&quot;load&quot;, function () {      this.contentWindow.postMessage(channel.name, location.origin);    });  });  channel.onmessage = function (event) {    console.log(event.data);  };&lt;/script&gt;</code></pre><pre><code class="html">&lt;!-- 這裡是 pageA.html --&gt;&lt;div class=&quot;output&quot;&gt;pageA content&lt;/div&gt;&lt;script&gt;  let channel;  window.addEventListener(&quot;message&quot;, function (event) {    if (event.origin !== location.origin) return;    channel = new BroadcastChannel(event.data);    channel.onmessage = function (bc_event) {      const output = document.querySelector(&quot;.output&quot;);      output.innerHTML = event.data;    };    channel.postMessage(&quot;pageA 加入頻道&quot;, location.origin);  });&lt;/script&gt;</code></pre><pre><code class="html">&lt;!-- 這裡是 pageB.html --&gt;&lt;div class=&quot;output&quot;&gt;pageB content&lt;/div&gt;&lt;script&gt;  let channel;  window.addEventListener(&quot;message&quot;, function (event) {    if (event.origin !== location.origin) return;    channel = new BroadcastChannel(event.data);    channel.onmessage = function (bc_event) {      const output = document.querySelector(&quot;.output&quot;);      output.innerHTML = event.data;    };    channel.postMessage(&quot;pageB 加入頻道&quot;, location.origin);  });&lt;/script&gt;</code></pre><blockquote><p>補充：如果有頁面想要與廣播頻道斷開連結的話，只要拿建立的頻道執行 <code>close()</code> 即可，關閉後頻道還是存在，只是該頁面不再接收頻道的訊息。</p></blockquote><p><br/><br/></p><p>這三天我們已經完全認識了 PostMessage，了解到它不但可以傳送訊息，還可以建立私訊或群組的通訊模式，而這項技術其實時常會用在 <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">Web Worker</a> 中，但因為它的範疇有點龐大，所以這次的系列文章不會介紹到，有興趣的朋友可以再自行研究～</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10276437" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;里長辦公室廣播：張君雅小妹妹，恁兜欸泡麵已經煮好了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前兩天已經認識了 PostMessage 和建立專屬頻道的 MessageChannel，它們都是進行點對點的溝通，但如果想要一次跟多個頁面溝通時怎麼辦
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / MessageChannel</title>
    <link href="https://maxleebk.com/2021/09/29/webApi/webApi-16/"/>
    <id>https://maxleebk.com/2021/09/29/webApi/webApi-16/</id>
    <published>2021-09-29T09:15:00.000Z</published>
    <updated>2023-01-12T00:54:38.903Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>熱線你和我，這是一條情感的線路，屬於你和我。</p></blockquote><p>昨天我們認識了 PostMessage，它可以讓我們在兩個頁面之間傳遞訊息，只要有地址(Domain Origin)，就可以送信給對方，而對方只要有收信的機制就能夠獲得訊息，甚至可以回信。但這有個壞處，也就是當我們建立了收信機制後，可能會有來自四面八方的訊息寄過來，那就必須要做一個過濾的動作。但今天的 MessageChannel 卻可以解決這個問題。</p><p><strong>有些 Package 或 Library 有可能會使用 PostMessage 在你的網頁文件中執行訊息傳遞，這些訊息也是需要過濾的。</strong></p><hr><h2 id="MessageChannel"><a href="#MessageChannel" class="headerlink" title="MessageChannel"></a>MessageChannel</h2><p>MessageChannel 就像是在兩個頁面中建立一個熱線系統，這樣就不會再那些不想收到訊息，只有綁定的雙方可以透過 MessageChannel 來進行溝通，就像是一個專屬的頻道。如果以圖像來表示整個頻道建立的過程的話，會像是下圖這樣：</p><img src="channel.png" style="margin: 24px auto;" /><br/><h4 id="建立頻道"><a href="#建立頻道" class="headerlink" title="# 建立頻道"></a># 建立頻道</h4><p>先來看第一步「建立頻道」，<code>MessageChannel</code> 本身是一個 <code>Class</code>，所以我們用關鍵字 <code>new</code> 來創建一個新的 MessageChannel 物件，就這麼簡單明瞭，而且也不需要傳入任何參數。</p><pre><code class="javascript">const msgChannel = new MessageChannel();</code></pre><p>而當 MessageChannel 建立後，它底下就會有兩個唯讀屬性可以取得，分別是 <code>port1</code> 和 <code>port2</code>，也就是圖片中的兩部手機：</p><pre><code class="javascript">console.log(msgChannel.port1);console.log(msgChannel.port2);</code></pre><p><br/><br/></p><h4 id="交付權限"><a href="#交付權限" class="headerlink" title="# 交付權限"></a># 交付權限</h4><p>在建立頻道之後，目前兩部手機(Port)都還是由目前的頁面所掌控，我們需要將其中一部手機(Port)傳遞給我們想建立通訊的另一個頁面中。</p><pre><code class="html">&lt;!-- 這裡是 pageA.html --&gt;&lt;iframe src=&quot;pageB.html&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/iframe&gt;&lt;script&gt;  let messagePort;  const iframe = document.querySelector(&quot;iframe&quot;);  iframe.addEventListener(&quot;load&quot;, function () {    // 建立頻道，並取得 port1、port2    const { port1, port2 } = new MessageChannel();    // 將 port1 存在全域變數中    messagePort = port1;    // 將 port2 送給 pageB    const msg = &quot;這是 pageA 送來的手機&quot;;    iframe.contentWindow.postMessage(msg, location.origin, [port2]);  });&lt;/script&gt;</code></pre><p>雖然已經建立了 MessageChannel，但「送手機」的這一步還是要靠一般的方式送過去，而手機(Port)的部分必須放在之前介紹 <code>postMessage</code> 時沒說的第三個參數中：</p><ul><li>transfer： 這個參數必須是一個陣列，當中要放的是由 MessageChannel 所產生的 <code>port</code>，藉此產生兩個頁面的訊息通道。</li></ul><br/><p>再來，pageA 還需要先做好準備，才不會漏接了 pageB 傳過來的訊息，也就是要監聽 <code>message</code> 事件，但是這次不再是用 <code>window</code> 監聽了，而是使用 <code>port1.onmessage</code>:</p><pre><code class="html">&lt;!-- 這裡是 pageA.html --&gt;&lt;iframe src=&quot;pageB.html&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/iframe&gt;&lt;script&gt;  let messagePort;  const iframe = document.querySelector(&quot;iframe&quot;);  iframe.addEventListener(&quot;load&quot;, function () {    const { port1, port2 } = new MessageChannel();    messagePort = port1;    // 用 port1 監聽 message 事件    messagePort.onmessage = function (event) {      console.log(event.data);    };    const msg = &quot;這是 pageA 送來的手機&quot;;    iframe.contentWindow.postMessage(msg, location.origin, [port2]);  });&lt;/script&gt;</code></pre><br/><p>再來就是要在 pageB 接收這個「寄送手機」的信息，只要在傳送端有在 <code>postMessage</code> 放入 <code>transfer</code> 這個參數，接收端就可以在 Event 物件中的 <code>ports</code> 屬性取得「這部手機」。</p><p>在收到這部手機(Port)後，我們可以先存起來，然後為它建立事件，以便未來在頻道中收到 pageA 時才會對應的操作。除此之外，我們還可以順勢用這部手機馬上打回去，跟 pageA 說我們已經拿到手機(Port)了。</p><pre><code class="html">&lt;!-- 這裡是 pageB.html --&gt;&lt;div class=&quot;output&quot;&gt;default content&lt;/div&gt;&lt;script&gt;  let messagePort;  const output = document.querySelector(&quot;.output&quot;);  window.addEventListener(&quot;message&quot;, function (event) {    if (!event.ports || !event.ports.length) return;    // 將訊息文字顯示在頁面上    output.innerHTML = event.data;    // 將 port2 存在全域變數中    messagePort = event.ports[0];    // 用 port2 監聽 message 事件    messagePort.onmessage = function (port_event) {      output.innerHTML = port_event.data;    };    // 用 port2 送出訊息    messagePort.postMessage(&quot;收到手機囉！&quot;);  });&lt;/script&gt;</code></pre><img src="post.gif" style="margin: 24px auto;" /><p><br/><br/></p><h4 id="頻道溝通"><a href="#頻道溝通" class="headerlink" title="# 頻道溝通"></a># 頻道溝通</h4><p>前面我們已經把前置作業全部都完善了，包括建立頻道、傳送埠口(Port)、事件監聽，接下來我們就可以享受信息暢通的專屬熱線了：</p><pre><code class="html">&lt;!-- 這裡是 pageA.html --&gt;&lt;button onclick=&quot;sendMessage()&quot;&gt;send message&lt;/button&gt;&lt;iframe src=&quot;pageB.html&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/iframe&gt;&lt;script&gt;  let messagePort;  // ... 省略其他 code  function sendMessage() {    messagePort.postMessage(&quot;來自 pageA 的訊息&quot;);  }&lt;/script&gt;</code></pre><pre><code class="html">&lt;!-- 這裡是 pageB.html --&gt;&lt;button onclick=&quot;sendMessage()&quot;&gt;send message&lt;/button&gt;&lt;div class=&quot;output&quot;&gt;default content&lt;/div&gt;&lt;script&gt;  let messagePort;  // ... 省略其他 code  function sendMessage() {    messagePort.postMessage(&quot;來自 pageB 的訊息&quot;);  }&lt;/script&gt;</code></pre><img src="post2.gif" style="margin: 24px auto;" /><p><br/><br/></p><p>是不是對 PostMessage 又有新的一層認識呢？但你以為就只有這樣嗎？其實明天還會介紹 BroadcastChannel，除了可以建立專屬熱線之外，還可以建立廣播系統！</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10276002" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;熱線你和我，這是一條情感的線路，屬於你和我。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;昨天我們認識了 PostMessage，它可以讓我們在兩個頁面之間傳遞訊息，只要有地址(Domain Origin)，就可以送信給對方，而對方只要有收信的機制就
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / PostMessage</title>
    <link href="https://maxleebk.com/2021/09/28/webApi/webApi-15/"/>
    <id>https://maxleebk.com/2021/09/28/webApi/webApi-15/</id>
    <published>2021-09-28T09:15:00.000Z</published>
    <updated>2023-01-12T00:54:38.903Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>親像愛情的限時批～</p></blockquote><p>各位有想過該如何跟其他頁面進行溝通嗎？如果在Ａ頁面點擊了一個按鈕，能不能夠讓Ｂ頁面發生變化或執行動作呢？別說不可能，今天要介紹的 PostMessage 便能夠達成這樣的效果。</p><hr><h2 id="PostMessage"><a href="#PostMessage" class="headerlink" title="PostMessage"></a>PostMessage</h2><p>一般來說，不同的頁面要相互溝通的話，它們的 Domain 必須相同，然後通常就會使用 LocalStorage 搭配 <code>storage</code> 事件來進行溝通，但 PostMessage 神奇的地方就在於它可以越過這項限制，讓我們甚至可以跟不同源的網站頁面進行溝通，這樣就能解決前端最討厭的 CORS 問題了。</p><blockquote><p>雖然 PostMessage 可以跨域溝通，不過當然也要對方願意且有撰寫對應的機制程式碼，要不然世界就大亂了 XD</p></blockquote><p><br/><br/></p><h4 id="otherWindow-postMessage"><a href="#otherWindow-postMessage" class="headerlink" title="# otherWindow.postMessage"></a># otherWindow.postMessage</h4><p>PostMessage API 底下就是只有 <code>postMessage</code> 這個 method，非常的單純，卻也無比強大，其中 <code>otherWindow</code> 所指的是「目前分頁以外的 Window」，這個 Window 可以是利用 <code>window.open</code> 執行返回的 Window 物件，或是一個 <code>iframe</code> 元素的 <code>contentWindow</code>，而也就是訊息要送達的目的地。</p><p>另外 <code>postMessage</code> 還必須傳入兩個參數：</p><ul><li>message: 第一個是你要傳送的訊息，任何型別格式都可以接受。</li><li>targetOrigin: 第二個則是設定「能夠接收本次訊息」的網頁 Origin，必須要是在這個 Domain 底下的頁面才能接收到訊息。</li></ul><pre><code class="javascript">const url = &quot;https://maxleebk.com//2021/09/28/webApi/webApi-15/&quot;;const otherPage = window.open(url);otherPage.postMessage(&quot;Hi,Max&quot;, &quot;https://maxleebk.com/&quot;);</code></pre><p>以上面的例子來說，我們先利用 <code>window.open</code> 打開了一個作者本人的部落格分頁，而該分頁的 Window 已經被儲存在 <code>otherPage</code> 中，再來我們就利用 <code>postMessage</code> 傳遞一個字傳，並且利用 <code>targetOrigin</code> 來確保一定要是 <code>https://maxleebk.com/</code> 底下的頁面才能真正接受到訊息。</p><blockquote><p>你該注意：<code>targetOrigin</code> 這個參數建議一定要傳入並填妥，不然訊息有可能會被刻意攔截，導致無法預期的安全性問題。</p></blockquote><p><br/><br/></p><h4 id="Window-message-Event"><a href="#Window-message-Event" class="headerlink" title="# Window:message Event"></a># Window:message Event</h4><p>訊息有傳送的一方，自然也要有接收的一方，而接收方要順利接到訊息的話，只要在 <code>window</code> 上監聽 <code>message</code> 這個事件即可，而訊息的部分則會被放在 Event 物件的 <code>data</code> 屬性裡:</p><pre><code class="javascript">addEventListener(&quot;message&quot;, function (event) {  console.log(event.data);});</code></pre><p>所以只要你想傳送的網站中，有打開一個這樣的通道，那你就可以透過 PostMessage 來與之溝通，不過接收方也不可能所有的訊息都照單全收，要是我們今天身為接收方，那應該要像下方這樣做一些防禦。</p><p>在 Event 物件中還有一個 <code>origin</code> 屬性，可以用來獲取傳送方的來源，所以我們可以利用它來過濾那些不在信任範圍的網址：</p><pre><code class="javascript">addEventListener(&quot;message&quot;, function (event) {  // 如果訊息不是來自於 IT邦幫忙 那就不執行任何動作  if (event.origin !== &quot;https://ithelp.ithome.com.tw&quot;) return;  console.log(event.data);});</code></pre><p>當然了，信息往來總不能只有單向，如果接收方要回信的話，只要利用 Event 物件中的 <code>source</code> 屬性就可以進行訊息的傳送：</p><pre><code class="javascript">addEventListener(&quot;message&quot;, function (event) {  if (event.origin !== &quot;https://ithelp.ithome.com.tw&quot;) return;  console.log(event.data);  event.source.postMessage(&quot;hi,IT邦幫忙&quot;, event.origin);});</code></pre><p>透過 PostMessage 訊息的相互傳遞，我們就可以不受同源政策的限制，向其他網域的網頁請求資料了，或利用訊息的格式判定來執行其他頁面的動作等等…</p><pre><code class="javascript">addEventListener(&quot;message&quot;, function (event) {  axios.get(&quot;/user&quot;, event.data.id).then((res) =&gt; {    event.source.postMessage(res, event.origin);  });});addEventListener(&quot;message&quot;, function (event) {  window[event.data.method](); // 執行指定名稱的全域函式});</code></pre><p><br/><br/></p><p>PostMessage API 是不是非常有趣又神奇呢？或許要遇到頁面溝通的情境並不多，但千萬忽略了它，等到遇到了，它會是非常強大的幫手，而且應用起來也相當簡單，大家如果有興趣，隨手就能寫個簡單的範例。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10275491" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;親像愛情的限時批～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;各位有想過該如何跟其他頁面進行溝通嗎？如果在Ａ頁面點擊了一個按鈕，能不能夠讓Ｂ頁面發生變化或執行動作呢？別說不可能，今天要介紹的 PostMessage 便能夠達成這樣的效果。&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / CustomEvent</title>
    <link href="https://maxleebk.com/2021/09/27/webApi/webApi-14/"/>
    <id>https://maxleebk.com/2021/09/27/webApi/webApi-14/</id>
    <published>2021-09-27T13:03:00.000Z</published>
    <updated>2023-01-12T00:54:38.903Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>自己的事件自己決定。</p></blockquote><p>網頁最重要的兩件事，資訊顯示與使用者交互，而使用者交互在頁面中所代表的行為就是「監聽事件」與「觸發事件」，相信這是大家在熟悉不過的了，<code>click</code>、<code>input</code>、<code>blur</code>、<code>scroll</code>…等等，幾乎充斥在我們的網站中，但除了這些常見的、預設的事件之外，其實我們也可以自己創造出全新的事件。</p><hr><h4 id="Window-CustomEvent"><a href="#Window-CustomEvent" class="headerlink" title="# Window.CustomEvent"></a># Window.CustomEvent</h4><p>CustomEvent 本身是一個建構函式，也就是我們常講的 <code>class</code>，當我們想要建立自訂事件時，就透過 <code>new</code> 關鍵字來呼叫它即可，並且要記得傳入代表事件名稱的字串，另外還可以傳入第二個參數來設定事件觸發時傳遞的資料。</p><p>要注意的是，用來設定資料的第二個物件必須要是一個物件，且要傳遞的資料必須設定在該物件的 <code>detail</code> 屬性底下。</p><pre><code class="javascript">const customEvent = new CustomEvent(&quot;myEvent&quot;, {  detail: { customData: &quot;maxLee&quot; },});</code></pre><p>而當有 DOM 元素需要綁定這個事件時，一樣使用 <code>addEventListener</code> 來處理即可，而其中事件 Callback 會拿到的 Event 物件就會多一個 <code>detail</code> 的屬性，該屬性就會是我們當初設定的事件傳遞資料。</p><pre><code class="javascript">const customEvent = new CustomEvent(&quot;myEvent&quot;, {  detail: { customData: &quot;maxLee&quot; },});document.querySelector(&quot;#element&quot;).addEventListener(&quot;myEvent&quot;, function (event) {  console.log(event.detail); // { customData: &quot;maxLee&quot; }});</code></pre><p><br/><br/></p><h4 id="EventTarget-dispatchEvent"><a href="#EventTarget-dispatchEvent" class="headerlink" title="# EventTarget.dispatchEvent"></a># EventTarget.dispatchEvent</h4><p>與 CustomEvent 最極其相關的 API 就是 DispatchEvent 了，它是一個可以讓我們主動觸發事件的方法，當我們創建並綁定了一個事件後，就必須要倚靠它來幫我們啟動事件了。</p><p>其中 EventTarget 是一個代稱，它所指的是綁定事件的 DOM 對象，例如以下程式碼中，<code>div</code> 就是 EventTarget：</p><pre><code class="javascript">const customEvent = new CustomEvent(&quot;myEvent&quot;, {  detail: { customData: &quot;maxLee&quot; },});const div = document.querySelector(&quot;div&quot;);div.addEventListener(&quot;myEvent&quot;, function (e) {  console.log(event.detail);});</code></pre><p>此時上面的 <code>div</code> 已經被綁上了我們自訂的 <code>myEvent</code> 事件，這時候我們就可以使用 <code>dispatchEvent</code> 來主動觸發事件，只要在呼叫它時傳入 CustomEvent 物件即可：</p><pre><code class="javascript">const customEvent = new CustomEvent(&quot;myEvent&quot;, {  detail: { customData: &quot;maxLee&quot; },});const div = document.querySelector(&quot;div&quot;);div.addEventListener(&quot;myEvent&quot;, function (e) {  console.log(event.detail);});div.dispatchEvent(customEvent);</code></pre><p><br/><br/></p><h4 id="運用場景"><a href="#運用場景" class="headerlink" title="# 運用場景"></a># 運用場景</h4><p>認識了 CustomEvent 後，我們來假設一個需求：<strong><em>「今天有個頁面，在進入時會向後端 request 資料，當資料回來後，我們要更改頁面的標題及一個 list 的內容」</em></strong>，當然了，如果使用前端框架的話，這是一個非常簡單的事情，但我們先假如這次專案不允許使用框架，那一般的寫法可能會是這樣：</p><pre><code class="javascript">function updateTitle(title) {  const title = document.querySelector(&quot;h1&quot;);  title.textContent = title;}function updateList(list) {  const ul = document.querySelector(&quot;ul&quot;);  ul.innerHtml = &quot;&quot;;  list.forEach((item) =&gt; {    const li = document.createElement(&quot;li&quot;);    li.textContent = item;    ul.appendChild(li);  });}function onDataFetch(res) {  updateTitle(res.data.title);  updateList(res.data.list);}// 如果不認識 axios，可以把它當成一個請求資料的 Promise 即可axios.get(&quot;https://backend/data&quot;).then(onDataFetch);</code></pre><p>以上這樣的寫法其實已經算是盡量避免耦合了，因為還額外包裝了一支 <code>onDataFetch</code> 函式來獨立處理取得資料後的事情，但如果未來還有其他的事情要處理，就必須再加進這個函式中，而且其他人在閱讀時，可能會誤以為裡面執行內容可能有順序性。那接下來我們看看使用 CustomEvent 可以怎麼寫：</p><pre><code class="javascript">let dataFetchEventTarget = [];function addDataFetchEvent(element, callback) {  dataFetchEventTarget.push(element);  element.addEventListener(&quot;dataFetch&quot;, callback);}addDataFetchEvent(document.querySelector(&quot;h1&quot;), function (e) {  this.textContent = e.detail.title;});addDataFetchEvent(document.querySelector(&quot;ul&quot;), function (e) {  this.innerHtml = &quot;&quot;;  e.detail.list.forEach((item) =&gt; {    const li = document.createElement(&quot;li&quot;);    li.textContent = item;    this.appendChild(li);  });});// 用 setTimeout 來模擬請求資料setTimeout(() =&gt; {  const dataFetchEvent = new CustomEvent(&quot;dataFetch&quot;, {    detail: res.data,  });  dataFetchEventTarget.forEach((target) =&gt; {    target.dispatchEvent(dataFetchEvent);  });}, 3000);</code></pre><p>首先我們先宣告了一個陣列 <code>dataFetchEventTarget</code>，打算來存放所有有註冊事件的元素，然後寫了一個函式 <code>addDataFetchEvent</code> 來註冊事件，並且同時將元素丟進陣列中，直到我們將資料請求回來後開始建立自訂事件，並且把 <code>dataFetchEventTarget</code> 中的元素一一取出並 <code>dispatchEvent</code> 事件。</p><p>這樣寫法的好處在於，「取得資料」跟「後續行為」完全沒有耦合，「註冊事件」與「觸發事件」完全是獨立的兩件事，所以未來如果有其他地方註冊了這個事件，我們也不需要額外處理任何事，等到事件觸發了，Callback 自然會去執行。</p><p><br/><br/></p><p>一般來說，沒有特別去設計的話，大家都會使用第一種方式吧？但其實使用 CustomEvent 的話，會很接近 Design Patterns 中的觀察者模式(Observer Pattern)，其實是一個非常不錯的撰寫方式，大家可以在未來的開發中嘗試看看。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10274924" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;自己的事件自己決定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;網頁最重要的兩件事，資訊顯示與使用者交互，而使用者交互在頁面中所代表的行為就是「監聽事件」與「觸發事件」，相信這是大家在熟悉不過的了，&lt;code&gt;click&lt;/code&gt;、&lt;code&gt;
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / SessionStorage</title>
    <link href="https://maxleebk.com/2021/09/26/webApi/webApi-13/"/>
    <id>https://maxleebk.com/2021/09/26/webApi/webApi-13/</id>
    <published>2021-09-26T09:33:00.000Z</published>
    <updated>2023-01-12T00:54:38.903Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>狡兔有三窟，儲存用戶端的資料當然也要有三個。</p></blockquote><p>相信大家應該都有遇過需要將資料儲存在用戶端的需求，像是將後端的 SessionID 儲存在 Cookie，或是將一些靜態資料存在 LocalStorage，但今天想要分享的是一個大家比較少選擇的 API - SessionStorage。</p><hr><h2 id="Cookie-amp-LocalStorage"><a href="#Cookie-amp-LocalStorage" class="headerlink" title="Cookie &amp; LocalStorage"></a>Cookie &amp; LocalStorage</h2><p>在介紹 SessionStorage 之前，我們先來複習一下 Cookie 和 LocalStorage 的一些特性，這樣之後如果遇到類似情境就可以依照需求選擇更適合的 API。</p><br/><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="# Cookie"></a># Cookie</h4><ul><li>每筆可儲存的資料大小約為 4KB</li><li>有時效的限制，到期後就會自動刪除</li><li>每次進行 http request 時所有 cookie 會一併送出</li><li>有同源政策，無法讀取其他網站設定的 cookie</li><li>明碼儲存，不適合儲存機敏性資料</li></ul><blockquote><p>根據上面的特性，我們就知道 Cookie 比較適合儲存小量、以時效性的資料，而且也因為每次發送請求時都會送出，所以才會被拿來儲存 SessionID，以供後端進行驗證。</p></blockquote><p><br/><br/></p><h4 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="# LocalStorage"></a># LocalStorage</h4><ul><li>每筆可儲存的資料大小約為 5MB</li><li>沒有時效限制，除非使用者手動刪除，不然會一直存在</li><li>進行 http request 時並不會送出</li><li>有同源政策，無法讀取其他網站設定的 localStorage</li><li>明碼儲存，不適合儲存機敏性資料</li></ul><blockquote><p>跟 Cookie 比較不同，LocalStorage 就可以存一些比較大型、長期性的資料，常常會被拿來當作用戶端的快取，以減少 fetch 資料的次數。</p></blockquote><p><br/><br/></p><h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><p>SessionStorage 則是跟 LocalStorage 幾乎一樣，且存放大小也是 5MB，最大的不同點在於，它會受到分頁的限制，也就是說就算兩個分頁都處在同一個網站中，它們的 SessionStorage 也不會共用，且只要把分頁關掉也同時會把 SessionStorage 給刪除。</p><br/><p>SessionStorage 這樣的特性其實就有一個很實用的情境，那就是表單內容的儲存，在網頁中時常會有表單需要用戶填寫，例如基本資料、訂單資料、意見調查等等，但如果使用者在填寫過程中不慎離開頁面或是重新整理，那可就功虧一簣了。</p><p>這時候 SessionStorage 就可以派上用場，把使用者填到一半的內容給儲存起來，只要使用者不是關掉分頁，離開再回來都可以保留填寫進度。而且就算使用者開了好幾個分頁進行不同訂單的填寫，分頁間的 SessionStorage 資料也不會相互干擾。</p><br/><h4 id="SessionStorage-setItem"><a href="#SessionStorage-setItem" class="headerlink" title="# SessionStorage.setItem"></a># SessionStorage.setItem</h4><p>SessionStorage 就連 methods 也都和 LocalStorage 是一樣的，<code>setItem</code> 可以讓我們下增/修改一筆 SessionStorage：</p><pre><code class="javascript">sessionStorage.setItem(&quot;key&quot;, &quot;value&quot;);// 如果想要儲存物件、陣列等複雜型別，可以先進行字串化sessionStorage.setItem(&quot;object&quot;, JSON.stringify({ key: &quot;value&quot; }));</code></pre><br/><h4 id="SessionStorage-getItem"><a href="#SessionStorage-getItem" class="headerlink" title="# SessionStorage.getItem"></a># SessionStorage.getItem</h4><p><code>getItem</code> 則是可以幫我們讀取 SessionStorage 中的某筆資料：</p><pre><code class="javascript">const data = sessionStorage.getItem(&quot;object&quot;);console.log(JSON.parse(data));</code></pre><br/><h4 id="SessionStorage-removeItem"><a href="#SessionStorage-removeItem" class="headerlink" title="# SessionStorage.removeItem"></a># SessionStorage.removeItem</h4><p><code>removeItem</code> 則是刪除某筆資料：</p><pre><code class="javascript">const data = sessionStorage.removeItem(&quot;object&quot;);</code></pre><br/><h4 id="SessionStorage-clear"><a href="#SessionStorage-clear" class="headerlink" title="# SessionStorage.clear"></a># SessionStorage.clear</h4><p>而 <code>clear</code> 會將 SessionStorage 中的所有資料都清除：</p><pre><code class="javascript">sessionStorage.clear();</code></pre><p><br/><br/></p><p>不曉得今天認識了 SessionStorage 之後，各位有沒有靈光一閃，突然覺得之前某些資料其實可以存在 SessionStorage 就好了呢？之後如果再有這種要在用戶端儲存資料的需求，大家就可以再多思考一下，選出符合情境的 Storage API 囉。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10274151" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;狡兔有三窟，儲存用戶端的資料當然也要有三個。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相信大家應該都有遇過需要將資料儲存在用戶端的需求，像是將後端的 SessionID 儲存在 Cookie，或是將一些靜態資料存在 LocalStorage，但今
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
  <entry>
    <title>那些被忽略但很好用的 Web API / History</title>
    <link href="https://maxleebk.com/2021/09/25/webApi/webApi-12/"/>
    <id>https://maxleebk.com/2021/09/25/webApi/webApi-12/</id>
    <published>2021-09-25T12:33:00.000Z</published>
    <updated>2023-01-12T00:54:38.903Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>歷史是現在與過去之間永無休止的對話。</p></blockquote><p>我們都知道瀏覽器提供了上一頁、下一頁，甚至可以讓你回到前兩頁、前三頁…，但其實我們也可以借助 History API 的力量，在網頁中自己實踐這樣的功能。</p><hr><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><p>History 是一個瀏覽器提供的歷史紀錄操作介面，你可以透過 <code>window.history</code> 來取得該物件，當中有一些屬性跟方法可以獲取來使用，下面我們就一一來認識一下。</p><br/><h4 id="History-length"><a href="#History-length" class="headerlink" title="# History.length"></a># History.length</h4><p><code>length</code> 是一個唯讀屬性，可以取得目前瀏覽器分頁的歷史紀錄總數，當你開啟一個新分頁時，它會是 <code>1</code>，而每當你瀏覽一個新的網址，它便會不斷增加。</p><pre><code class="javascript">console.log(history.length);</code></pre><p><br/><br/></p><h4 id="History-scrollRestoration"><a href="#History-scrollRestoration" class="headerlink" title="# History.scrollRestoration"></a># History.scrollRestoration</h4><p><code>scrollRestoration</code> 這個屬性是可以修改的，它影響的是瀏覽器對於「使用者在歷史紀錄的頁面中移動時」的捲動行為，可以設定的值有兩個：</p><ul><li><code>&quot;auto&quot;</code>: 當使用者離開某個頁面時，瀏覽器會紀錄離開時的卷動距離，並在使用者到該頁時，自動卷動到記錄的位置。</li><li><code>&quot;manual&quot;</code>: 瀏覽器不會紀錄捲動距離，每次頁面更換時都會回到頂部。</li></ul><pre><code class="javascript">if (history.scrollRestoration === &quot;manual&quot;) {  history.scrollRestoration = &quot;auto&quot;;}</code></pre><blockquote><p>雖然 MDN 上說，<code>scrollRestoration</code> 還是一個實驗中的屬性，但其實除了 IE，其他的瀏覽器都已經實踐這個功能了，且預設會是 <code>auto</code>。</p></blockquote><p><br/><br/></p><h4 id="History-back"><a href="#History-back" class="headerlink" title="# History.back"></a># History.back</h4><p><code>back</code> 是 History 的其中一個 method，它相當於瀏覽器介面上的「上一頁」，所以如果你希望你的頁面中也有按鈕可以讓使用者返回上一頁，就可以適用它：</p><pre><code class="javascript">document.querySelector(&quot;button&quot;).addEventListener(&quot;click&quot;, function () {  history.back();});</code></pre><p><br/><br/></p><h4 id="History-forward"><a href="#History-forward" class="headerlink" title="# History.forward"></a># History.forward</h4><p>沒錯，有上一頁，自然也有下一頁，對應的 method 就是 <code>forward</code>。</p><pre><code class="javascript">document.querySelector(&quot;button&quot;).addEventListener(&quot;click&quot;, function () {  history.forward();});</code></pre><p><br/><br/></p><h4 id="History-go"><a href="#History-go" class="headerlink" title="# History.go"></a># History.go</h4><p>比起 <code>back</code> 和 <code>forward</code> 來說，<code>go</code> 就比較靈活了，它可以傳入一個數字來代表要往前或往後至相對於目前頁面的哪個歷史位置，例如傳入 <code>-1</code> 就相當於「上一頁」，傳入 <code>1</code> 則相當於「下一頁」。</p><p>要注意的是，如果傳入的數字超出了歷史紀錄的範圍，那將不會有任何效果。</p><pre><code class="javascript">history.go(-1); // 等於 history.back()history.go(1); // 等於 history.forward()history.go(-3); // 回到三頁之前history.go(0); // 瀏覽器會重新整理目前的頁面</code></pre><p><br/><br/></p><h2 id="pushState-replaceState"><a href="#pushState-replaceState" class="headerlink" title="pushState / replaceState"></a>pushState / replaceState</h2><p>上面介紹的 <code>back</code>、<code>forward</code> 和 <code>go</code>，其實都算是蠻簡單的，而且可能很多人都已經用過了，所以我們今天要重點介紹的其實是 <code>pushState</code> 和 <code>replaceState</code>，它們是 HTML5 中新增加的 API，讓我們可以添加或修改歷史紀錄。</p><br/><h4 id="History-pushState"><a href="#History-pushState" class="headerlink" title="# History.pushState"></a># History.pushState</h4><p><code>pushState</code> 可以讓我們在不移動頁面的情況下，添加一筆歷史紀錄，它一共有三個參數</p><ul><li>state: 這個參數可以接受一個物件，該物件裡可以存放任何資料，至於有什麼實際用途，後面會再介紹。</li><li>title: 這是一個被暫時保留的參數，實際上沒有任何用途，且會被瀏覽器忽略。</li><li>URL: 這個參數是用來設定我們添加的這筆歷史紀錄的網址，可傳可不傳。</li></ul><pre><code class="javascript">history.pushState({ name: &quot;max&quot; }, null, &quot;newPage.html&quot;);</code></pre><p>假設我們原本所在頁面的網址是 <code>https://maxleebk.com/index.html</code>，那當我們執行上面這段程式碼時，網址就會被改成 <code>https://maxleebk.com/newPage.html</code>，並且歷史紀錄會被加上一筆，所以如果點擊上一頁，又會回到 <code>/index.html</code>。</p><p>更有趣的是，當網址被改為 <code>/newPage.html</code> 時，瀏覽器不會真的去讀取 <code>newPage.html</code> 這個文件，而是維持在 <code>index.html</code>，直到使用者進行重新整理。</p><p><br/><br/></p><h4 id="History-replaceState"><a href="#History-replaceState" class="headerlink" title="# History.replaceState"></a># History.replaceState</h4><p><code>replaceState</code> 跟 <code>pushState</code> 的參數和效果都一樣，唯一不同的是 <code>replaceState</code> 並不是「添加」歷史紀錄，而是修改最新一筆的歷史紀錄。</p><pre><code class="javascript">history.replaceState({ name: &quot;max&quot; }, null, &quot;newPage.html&quot;);</code></pre><p>以同樣的例子來說，在 <code>https://maxleebk.com/index.html</code> 執行上面這段程式碼，網址一樣會被改成 <code>/newPage.html</code>，但當你按上一頁時，並不會回到 <code>/index.html</code>，而是回到更往前的一次的頁面，因為 <code>/index.html</code> 其實是被 <code>/newPage.html</code> 取代了。</p><p><br/><br/></p><h4 id="Window-popstate-Event"><a href="#Window-popstate-Event" class="headerlink" title="# Window:popstate Event"></a># Window:popstate Event</h4><p>再來要介紹的這個 WindowEvent 與 <code>pushState</code> 跟 <code>replaceState</code> 息息相關，這個事件會在使用者進行歷史紀錄操作（例如上一頁、下一頁）時觸發。</p><p>還記得前面講到 <code>pushState</code> 和 <code>replaceState</code> 的 <code>state</code> 參數嗎？<code>popstate</code> 事件的回呼函示所拿到的 Event 物件會有一個 <code>state</code> 屬性，它存放的就會是當初設定的 <code>state</code> 參數副本。</p><pre><code class="javascript">window.addEventListener(&quot;popstate&quot;, function (event) {  console.log(event.state);});history.pushState({ name: &quot;max&quot; }, null); // 不指定URL，所以網址不會變history.pushState({ name: &quot;tom&quot; }, null); // 不指定URL，所以網址不會變//此時按下「上一頁」，console 會印出 { name: &quot;max&quot; }//接著按下「下一頁」，console 會印出 { name: &quot;tom&quot; }</code></pre><p><br/><br/></p><h4 id="復原-重做小應用"><a href="#復原-重做小應用" class="headerlink" title="# 復原 / 重做小應用"></a># 復原 / 重做小應用</h4><p>那學會 <code>pushState</code>、<code>replaceState</code> 和 <code>popstate</code> 能做什麼呢？其實我們可以利用 <code>state</code> 的設定來把使用者的一些操作記錄在 History 中：</p><pre><code class="html">&lt;div id=&quot;editable&quot; contenteditable=&quot;true&quot;&gt;&lt;/div&gt;&lt;script&gt;  window.addEventListener(&quot;popstate&quot;, function (e) {    editable.textContent = &quot;&quot;;    if (e.state &amp;&amp; e.state.text) {      // 每次有歷史紀錄的「移動」時，便將當下紀錄的 state 丟到可編輯元素中      editable.textContent = e.state.text;    }  });  const editableDiv = document.querySelector(&quot;#editable&quot;);  editableDiv.addEventListener(&quot;input&quot;, function () {    // 每次輸入時新增一筆歷史紀錄，且會利用 state 儲存當下的輸入內容    window.history.pushState({ text: editable.textContent }, null);  });&lt;/script&gt;</code></pre><p>我們一樣拿 <code>contenteditable</code> 的可編輯元素來示範，每當使用者輸入文字時我們就 <code>pushState</code> 一次，並把元素當中的文字內容紀錄在 <code>state</code> 中。而因為我們有監聽了 <code>popstate</code> 事件，使得使用者每次在進行「上一頁」或「下一頁」時，便能取得每一次輸入的內容。</p><p>這樣的好處就是，使用者可以透過瀏覽器的上一頁或下一頁來模擬「復原」和「重做」功能。</p><p><strong>如果想要玩玩看的話，這邊是我已經寫好的 <a href="https://codepen.io/max-lee/pen/KKqrbBO" target="_blank" rel="noopener">CodePen</a></strong></p><p><br/><br/></p><p>其實大家如果有使用過 VueRouter 的話，它底層就是透過 <code>pushState</code>、<code>replaceState</code>，來實踐 SPA 的網址變換的，所以才說其實很多 Web API 都是非常好用，甚至很多有名的套件都會採用，只是我們通常會忽視這些 Web API 的強大功能。</p><hr><p>- 此篇文章為「iT 邦幫忙鐵人賽」參賽文章，同步發表於 <a href="https://ithelp.ithome.com.tw/articles/10273613" target="_blank" rel="noopener">iT 邦幫忙</a> -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;歷史是現在與過去之間永無休止的對話。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我們都知道瀏覽器提供了上一頁、下一頁，甚至可以讓你回到前兩頁、前三頁…，但其實我們也可以借助 History API 的力量，在網頁中自己實踐這樣的功能。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="https://maxleebk.com/tags/JavaScript/"/>
    
      <category term="WebApi" scheme="https://maxleebk.com/tags/WebApi/"/>
    
      <category term="13th鐵人賽" scheme="https://maxleebk.com/tags/13th%E9%90%B5%E4%BA%BA%E8%B3%BD/"/>
    
  </entry>
  
</feed>
